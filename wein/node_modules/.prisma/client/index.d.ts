
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Student
 * 
 */
export type Student = $Result.DefaultSelection<Prisma.$StudentPayload>
/**
 * Model Consultant
 * 
 */
export type Consultant = $Result.DefaultSelection<Prisma.$ConsultantPayload>
/**
 * Model Admin
 * 
 */
export type Admin = $Result.DefaultSelection<Prisma.$AdminPayload>
/**
 * Model ConsultationSession
 * 
 */
export type ConsultationSession = $Result.DefaultSelection<Prisma.$ConsultationSessionPayload>
/**
 * Model VideoSession
 * 
 */
export type VideoSession = $Result.DefaultSelection<Prisma.$VideoSessionPayload>
/**
 * Model VideoParticipant
 * 
 */
export type VideoParticipant = $Result.DefaultSelection<Prisma.$VideoParticipantPayload>
/**
 * Model ConsultantAvailability
 * 
 */
export type ConsultantAvailability = $Result.DefaultSelection<Prisma.$ConsultantAvailabilityPayload>
/**
 * Model StudentDocument
 * 
 */
export type StudentDocument = $Result.DefaultSelection<Prisma.$StudentDocumentPayload>
/**
 * Model SessionHistory
 * 
 */
export type SessionHistory = $Result.DefaultSelection<Prisma.$SessionHistoryPayload>
/**
 * Model ConsultantPayment
 * 
 */
export type ConsultantPayment = $Result.DefaultSelection<Prisma.$ConsultantPaymentPayload>
/**
 * Model SystemHealthMetric
 * 
 */
export type SystemHealthMetric = $Result.DefaultSelection<Prisma.$SystemHealthMetricPayload>
/**
 * Model InAppNotification
 * 
 */
export type InAppNotification = $Result.DefaultSelection<Prisma.$InAppNotificationPayload>
/**
 * Model ScheduledNotification
 * 
 */
export type ScheduledNotification = $Result.DefaultSelection<Prisma.$ScheduledNotificationPayload>
/**
 * Model NotificationLog
 * 
 */
export type NotificationLog = $Result.DefaultSelection<Prisma.$NotificationLogPayload>
/**
 * Model UserNotificationPreferences
 * 
 */
export type UserNotificationPreferences = $Result.DefaultSelection<Prisma.$UserNotificationPreferencesPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const UserType: {
  STUDENT: 'STUDENT',
  CONSULTANT: 'CONSULTANT',
  ADMIN: 'ADMIN'
};

export type UserType = (typeof UserType)[keyof typeof UserType]


export const UserStatus: {
  ACTIVE: 'ACTIVE',
  INACTIVE: 'INACTIVE',
  SUSPENDED: 'SUSPENDED'
};

export type UserStatus = (typeof UserStatus)[keyof typeof UserStatus]


export const StudentStatus: {
  ENROLLED: 'ENROLLED',
  CONSULTATION_ACCESS_GRANTED: 'CONSULTATION_ACCESS_GRANTED',
  IN_PROGRESS: 'IN_PROGRESS',
  PENDING_VERIFICATION: 'PENDING_VERIFICATION',
  READY_FOR_CERTIFICATION: 'READY_FOR_CERTIFICATION',
  CERTIFIED: 'CERTIFIED',
  SUSPENDED: 'SUSPENDED',
  WITHDRAWN: 'WITHDRAWN'
};

export type StudentStatus = (typeof StudentStatus)[keyof typeof StudentStatus]


export const SessionStatus: {
  SCHEDULED: 'SCHEDULED',
  CONFIRMED: 'CONFIRMED',
  IN_PROGRESS: 'IN_PROGRESS',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED',
  NO_SHOW: 'NO_SHOW',
  RESCHEDULED: 'RESCHEDULED',
  TECHNICAL_ISSUE: 'TECHNICAL_ISSUE'
};

export type SessionStatus = (typeof SessionStatus)[keyof typeof SessionStatus]


export const AvailabilityType: {
  RECURRING_WEEKLY: 'RECURRING_WEEKLY',
  ONE_TIME: 'ONE_TIME',
  BLOCKED_TIME: 'BLOCKED_TIME',
  HOLIDAY_BLOCK: 'HOLIDAY_BLOCK'
};

export type AvailabilityType = (typeof AvailabilityType)[keyof typeof AvailabilityType]


export const DocumentType: {
  CONSULTATION_LOG: 'CONSULTATION_LOG',
  EVALUATION_FORM: 'EVALUATION_FORM',
  REFLECTION_PAPER: 'REFLECTION_PAPER',
  CASE_STUDY: 'CASE_STUDY',
  ADDITIONAL_REQUIREMENT: 'ADDITIONAL_REQUIREMENT',
  MAKEUP_DOCUMENTATION: 'MAKEUP_DOCUMENTATION'
};

export type DocumentType = (typeof DocumentType)[keyof typeof DocumentType]


export const ReviewStatus: {
  PENDING: 'PENDING',
  UNDER_REVIEW: 'UNDER_REVIEW',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED',
  NEEDS_REVISION: 'NEEDS_REVISION',
  AUTO_APPROVED: 'AUTO_APPROVED'
};

export type ReviewStatus = (typeof ReviewStatus)[keyof typeof ReviewStatus]


export const PaymentStatus: {
  PENDING: 'PENDING',
  PROCESSING: 'PROCESSING',
  PAID: 'PAID',
  FAILED: 'FAILED',
  CANCELLED: 'CANCELLED'
};

export type PaymentStatus = (typeof PaymentStatus)[keyof typeof PaymentStatus]


export const ScheduledNotificationStatus: {
  PENDING: 'PENDING',
  SENT: 'SENT',
  FAILED: 'FAILED',
  CANCELLED: 'CANCELLED'
};

export type ScheduledNotificationStatus = (typeof ScheduledNotificationStatus)[keyof typeof ScheduledNotificationStatus]

}

export type UserType = $Enums.UserType

export const UserType: typeof $Enums.UserType

export type UserStatus = $Enums.UserStatus

export const UserStatus: typeof $Enums.UserStatus

export type StudentStatus = $Enums.StudentStatus

export const StudentStatus: typeof $Enums.StudentStatus

export type SessionStatus = $Enums.SessionStatus

export const SessionStatus: typeof $Enums.SessionStatus

export type AvailabilityType = $Enums.AvailabilityType

export const AvailabilityType: typeof $Enums.AvailabilityType

export type DocumentType = $Enums.DocumentType

export const DocumentType: typeof $Enums.DocumentType

export type ReviewStatus = $Enums.ReviewStatus

export const ReviewStatus: typeof $Enums.ReviewStatus

export type PaymentStatus = $Enums.PaymentStatus

export const PaymentStatus: typeof $Enums.PaymentStatus

export type ScheduledNotificationStatus = $Enums.ScheduledNotificationStatus

export const ScheduledNotificationStatus: typeof $Enums.ScheduledNotificationStatus

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.student`: Exposes CRUD operations for the **Student** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Students
    * const students = await prisma.student.findMany()
    * ```
    */
  get student(): Prisma.StudentDelegate<ExtArgs>;

  /**
   * `prisma.consultant`: Exposes CRUD operations for the **Consultant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Consultants
    * const consultants = await prisma.consultant.findMany()
    * ```
    */
  get consultant(): Prisma.ConsultantDelegate<ExtArgs>;

  /**
   * `prisma.admin`: Exposes CRUD operations for the **Admin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Admins
    * const admins = await prisma.admin.findMany()
    * ```
    */
  get admin(): Prisma.AdminDelegate<ExtArgs>;

  /**
   * `prisma.consultationSession`: Exposes CRUD operations for the **ConsultationSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ConsultationSessions
    * const consultationSessions = await prisma.consultationSession.findMany()
    * ```
    */
  get consultationSession(): Prisma.ConsultationSessionDelegate<ExtArgs>;

  /**
   * `prisma.videoSession`: Exposes CRUD operations for the **VideoSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VideoSessions
    * const videoSessions = await prisma.videoSession.findMany()
    * ```
    */
  get videoSession(): Prisma.VideoSessionDelegate<ExtArgs>;

  /**
   * `prisma.videoParticipant`: Exposes CRUD operations for the **VideoParticipant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VideoParticipants
    * const videoParticipants = await prisma.videoParticipant.findMany()
    * ```
    */
  get videoParticipant(): Prisma.VideoParticipantDelegate<ExtArgs>;

  /**
   * `prisma.consultantAvailability`: Exposes CRUD operations for the **ConsultantAvailability** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ConsultantAvailabilities
    * const consultantAvailabilities = await prisma.consultantAvailability.findMany()
    * ```
    */
  get consultantAvailability(): Prisma.ConsultantAvailabilityDelegate<ExtArgs>;

  /**
   * `prisma.studentDocument`: Exposes CRUD operations for the **StudentDocument** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StudentDocuments
    * const studentDocuments = await prisma.studentDocument.findMany()
    * ```
    */
  get studentDocument(): Prisma.StudentDocumentDelegate<ExtArgs>;

  /**
   * `prisma.sessionHistory`: Exposes CRUD operations for the **SessionHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SessionHistories
    * const sessionHistories = await prisma.sessionHistory.findMany()
    * ```
    */
  get sessionHistory(): Prisma.SessionHistoryDelegate<ExtArgs>;

  /**
   * `prisma.consultantPayment`: Exposes CRUD operations for the **ConsultantPayment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ConsultantPayments
    * const consultantPayments = await prisma.consultantPayment.findMany()
    * ```
    */
  get consultantPayment(): Prisma.ConsultantPaymentDelegate<ExtArgs>;

  /**
   * `prisma.systemHealthMetric`: Exposes CRUD operations for the **SystemHealthMetric** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SystemHealthMetrics
    * const systemHealthMetrics = await prisma.systemHealthMetric.findMany()
    * ```
    */
  get systemHealthMetric(): Prisma.SystemHealthMetricDelegate<ExtArgs>;

  /**
   * `prisma.inAppNotification`: Exposes CRUD operations for the **InAppNotification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InAppNotifications
    * const inAppNotifications = await prisma.inAppNotification.findMany()
    * ```
    */
  get inAppNotification(): Prisma.InAppNotificationDelegate<ExtArgs>;

  /**
   * `prisma.scheduledNotification`: Exposes CRUD operations for the **ScheduledNotification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ScheduledNotifications
    * const scheduledNotifications = await prisma.scheduledNotification.findMany()
    * ```
    */
  get scheduledNotification(): Prisma.ScheduledNotificationDelegate<ExtArgs>;

  /**
   * `prisma.notificationLog`: Exposes CRUD operations for the **NotificationLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NotificationLogs
    * const notificationLogs = await prisma.notificationLog.findMany()
    * ```
    */
  get notificationLog(): Prisma.NotificationLogDelegate<ExtArgs>;

  /**
   * `prisma.userNotificationPreferences`: Exposes CRUD operations for the **UserNotificationPreferences** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserNotificationPreferences
    * const userNotificationPreferences = await prisma.userNotificationPreferences.findMany()
    * ```
    */
  get userNotificationPreferences(): Prisma.UserNotificationPreferencesDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Student: 'Student',
    Consultant: 'Consultant',
    Admin: 'Admin',
    ConsultationSession: 'ConsultationSession',
    VideoSession: 'VideoSession',
    VideoParticipant: 'VideoParticipant',
    ConsultantAvailability: 'ConsultantAvailability',
    StudentDocument: 'StudentDocument',
    SessionHistory: 'SessionHistory',
    ConsultantPayment: 'ConsultantPayment',
    SystemHealthMetric: 'SystemHealthMetric',
    InAppNotification: 'InAppNotification',
    ScheduledNotification: 'ScheduledNotification',
    NotificationLog: 'NotificationLog',
    UserNotificationPreferences: 'UserNotificationPreferences'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "student" | "consultant" | "admin" | "consultationSession" | "videoSession" | "videoParticipant" | "consultantAvailability" | "studentDocument" | "sessionHistory" | "consultantPayment" | "systemHealthMetric" | "inAppNotification" | "scheduledNotification" | "notificationLog" | "userNotificationPreferences"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Student: {
        payload: Prisma.$StudentPayload<ExtArgs>
        fields: Prisma.StudentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StudentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StudentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          findFirst: {
            args: Prisma.StudentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StudentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          findMany: {
            args: Prisma.StudentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>[]
          }
          create: {
            args: Prisma.StudentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          createMany: {
            args: Prisma.StudentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StudentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>[]
          }
          delete: {
            args: Prisma.StudentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          update: {
            args: Prisma.StudentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          deleteMany: {
            args: Prisma.StudentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StudentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StudentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          aggregate: {
            args: Prisma.StudentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudent>
          }
          groupBy: {
            args: Prisma.StudentGroupByArgs<ExtArgs>
            result: $Utils.Optional<StudentGroupByOutputType>[]
          }
          count: {
            args: Prisma.StudentCountArgs<ExtArgs>
            result: $Utils.Optional<StudentCountAggregateOutputType> | number
          }
        }
      }
      Consultant: {
        payload: Prisma.$ConsultantPayload<ExtArgs>
        fields: Prisma.ConsultantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConsultantFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsultantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConsultantFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsultantPayload>
          }
          findFirst: {
            args: Prisma.ConsultantFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsultantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConsultantFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsultantPayload>
          }
          findMany: {
            args: Prisma.ConsultantFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsultantPayload>[]
          }
          create: {
            args: Prisma.ConsultantCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsultantPayload>
          }
          createMany: {
            args: Prisma.ConsultantCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ConsultantCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsultantPayload>[]
          }
          delete: {
            args: Prisma.ConsultantDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsultantPayload>
          }
          update: {
            args: Prisma.ConsultantUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsultantPayload>
          }
          deleteMany: {
            args: Prisma.ConsultantDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConsultantUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ConsultantUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsultantPayload>
          }
          aggregate: {
            args: Prisma.ConsultantAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConsultant>
          }
          groupBy: {
            args: Prisma.ConsultantGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConsultantGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConsultantCountArgs<ExtArgs>
            result: $Utils.Optional<ConsultantCountAggregateOutputType> | number
          }
        }
      }
      Admin: {
        payload: Prisma.$AdminPayload<ExtArgs>
        fields: Prisma.AdminFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdminFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdminFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          findFirst: {
            args: Prisma.AdminFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdminFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          findMany: {
            args: Prisma.AdminFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>[]
          }
          create: {
            args: Prisma.AdminCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          createMany: {
            args: Prisma.AdminCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdminCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>[]
          }
          delete: {
            args: Prisma.AdminDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          update: {
            args: Prisma.AdminUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          deleteMany: {
            args: Prisma.AdminDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdminUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AdminUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          aggregate: {
            args: Prisma.AdminAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdmin>
          }
          groupBy: {
            args: Prisma.AdminGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdminGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdminCountArgs<ExtArgs>
            result: $Utils.Optional<AdminCountAggregateOutputType> | number
          }
        }
      }
      ConsultationSession: {
        payload: Prisma.$ConsultationSessionPayload<ExtArgs>
        fields: Prisma.ConsultationSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConsultationSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsultationSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConsultationSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsultationSessionPayload>
          }
          findFirst: {
            args: Prisma.ConsultationSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsultationSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConsultationSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsultationSessionPayload>
          }
          findMany: {
            args: Prisma.ConsultationSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsultationSessionPayload>[]
          }
          create: {
            args: Prisma.ConsultationSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsultationSessionPayload>
          }
          createMany: {
            args: Prisma.ConsultationSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ConsultationSessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsultationSessionPayload>[]
          }
          delete: {
            args: Prisma.ConsultationSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsultationSessionPayload>
          }
          update: {
            args: Prisma.ConsultationSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsultationSessionPayload>
          }
          deleteMany: {
            args: Prisma.ConsultationSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConsultationSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ConsultationSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsultationSessionPayload>
          }
          aggregate: {
            args: Prisma.ConsultationSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConsultationSession>
          }
          groupBy: {
            args: Prisma.ConsultationSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConsultationSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConsultationSessionCountArgs<ExtArgs>
            result: $Utils.Optional<ConsultationSessionCountAggregateOutputType> | number
          }
        }
      }
      VideoSession: {
        payload: Prisma.$VideoSessionPayload<ExtArgs>
        fields: Prisma.VideoSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VideoSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VideoSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoSessionPayload>
          }
          findFirst: {
            args: Prisma.VideoSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VideoSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoSessionPayload>
          }
          findMany: {
            args: Prisma.VideoSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoSessionPayload>[]
          }
          create: {
            args: Prisma.VideoSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoSessionPayload>
          }
          createMany: {
            args: Prisma.VideoSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VideoSessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoSessionPayload>[]
          }
          delete: {
            args: Prisma.VideoSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoSessionPayload>
          }
          update: {
            args: Prisma.VideoSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoSessionPayload>
          }
          deleteMany: {
            args: Prisma.VideoSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VideoSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VideoSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoSessionPayload>
          }
          aggregate: {
            args: Prisma.VideoSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVideoSession>
          }
          groupBy: {
            args: Prisma.VideoSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<VideoSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.VideoSessionCountArgs<ExtArgs>
            result: $Utils.Optional<VideoSessionCountAggregateOutputType> | number
          }
        }
      }
      VideoParticipant: {
        payload: Prisma.$VideoParticipantPayload<ExtArgs>
        fields: Prisma.VideoParticipantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VideoParticipantFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoParticipantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VideoParticipantFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoParticipantPayload>
          }
          findFirst: {
            args: Prisma.VideoParticipantFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoParticipantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VideoParticipantFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoParticipantPayload>
          }
          findMany: {
            args: Prisma.VideoParticipantFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoParticipantPayload>[]
          }
          create: {
            args: Prisma.VideoParticipantCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoParticipantPayload>
          }
          createMany: {
            args: Prisma.VideoParticipantCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VideoParticipantCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoParticipantPayload>[]
          }
          delete: {
            args: Prisma.VideoParticipantDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoParticipantPayload>
          }
          update: {
            args: Prisma.VideoParticipantUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoParticipantPayload>
          }
          deleteMany: {
            args: Prisma.VideoParticipantDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VideoParticipantUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VideoParticipantUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoParticipantPayload>
          }
          aggregate: {
            args: Prisma.VideoParticipantAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVideoParticipant>
          }
          groupBy: {
            args: Prisma.VideoParticipantGroupByArgs<ExtArgs>
            result: $Utils.Optional<VideoParticipantGroupByOutputType>[]
          }
          count: {
            args: Prisma.VideoParticipantCountArgs<ExtArgs>
            result: $Utils.Optional<VideoParticipantCountAggregateOutputType> | number
          }
        }
      }
      ConsultantAvailability: {
        payload: Prisma.$ConsultantAvailabilityPayload<ExtArgs>
        fields: Prisma.ConsultantAvailabilityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConsultantAvailabilityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsultantAvailabilityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConsultantAvailabilityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsultantAvailabilityPayload>
          }
          findFirst: {
            args: Prisma.ConsultantAvailabilityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsultantAvailabilityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConsultantAvailabilityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsultantAvailabilityPayload>
          }
          findMany: {
            args: Prisma.ConsultantAvailabilityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsultantAvailabilityPayload>[]
          }
          create: {
            args: Prisma.ConsultantAvailabilityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsultantAvailabilityPayload>
          }
          createMany: {
            args: Prisma.ConsultantAvailabilityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ConsultantAvailabilityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsultantAvailabilityPayload>[]
          }
          delete: {
            args: Prisma.ConsultantAvailabilityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsultantAvailabilityPayload>
          }
          update: {
            args: Prisma.ConsultantAvailabilityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsultantAvailabilityPayload>
          }
          deleteMany: {
            args: Prisma.ConsultantAvailabilityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConsultantAvailabilityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ConsultantAvailabilityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsultantAvailabilityPayload>
          }
          aggregate: {
            args: Prisma.ConsultantAvailabilityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConsultantAvailability>
          }
          groupBy: {
            args: Prisma.ConsultantAvailabilityGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConsultantAvailabilityGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConsultantAvailabilityCountArgs<ExtArgs>
            result: $Utils.Optional<ConsultantAvailabilityCountAggregateOutputType> | number
          }
        }
      }
      StudentDocument: {
        payload: Prisma.$StudentDocumentPayload<ExtArgs>
        fields: Prisma.StudentDocumentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StudentDocumentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentDocumentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StudentDocumentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentDocumentPayload>
          }
          findFirst: {
            args: Prisma.StudentDocumentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentDocumentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StudentDocumentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentDocumentPayload>
          }
          findMany: {
            args: Prisma.StudentDocumentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentDocumentPayload>[]
          }
          create: {
            args: Prisma.StudentDocumentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentDocumentPayload>
          }
          createMany: {
            args: Prisma.StudentDocumentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StudentDocumentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentDocumentPayload>[]
          }
          delete: {
            args: Prisma.StudentDocumentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentDocumentPayload>
          }
          update: {
            args: Prisma.StudentDocumentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentDocumentPayload>
          }
          deleteMany: {
            args: Prisma.StudentDocumentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StudentDocumentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StudentDocumentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentDocumentPayload>
          }
          aggregate: {
            args: Prisma.StudentDocumentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudentDocument>
          }
          groupBy: {
            args: Prisma.StudentDocumentGroupByArgs<ExtArgs>
            result: $Utils.Optional<StudentDocumentGroupByOutputType>[]
          }
          count: {
            args: Prisma.StudentDocumentCountArgs<ExtArgs>
            result: $Utils.Optional<StudentDocumentCountAggregateOutputType> | number
          }
        }
      }
      SessionHistory: {
        payload: Prisma.$SessionHistoryPayload<ExtArgs>
        fields: Prisma.SessionHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionHistoryPayload>
          }
          findFirst: {
            args: Prisma.SessionHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionHistoryPayload>
          }
          findMany: {
            args: Prisma.SessionHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionHistoryPayload>[]
          }
          create: {
            args: Prisma.SessionHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionHistoryPayload>
          }
          createMany: {
            args: Prisma.SessionHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionHistoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionHistoryPayload>[]
          }
          delete: {
            args: Prisma.SessionHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionHistoryPayload>
          }
          update: {
            args: Prisma.SessionHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionHistoryPayload>
          }
          deleteMany: {
            args: Prisma.SessionHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SessionHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionHistoryPayload>
          }
          aggregate: {
            args: Prisma.SessionHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSessionHistory>
          }
          groupBy: {
            args: Prisma.SessionHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<SessionHistoryCountAggregateOutputType> | number
          }
        }
      }
      ConsultantPayment: {
        payload: Prisma.$ConsultantPaymentPayload<ExtArgs>
        fields: Prisma.ConsultantPaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConsultantPaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsultantPaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConsultantPaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsultantPaymentPayload>
          }
          findFirst: {
            args: Prisma.ConsultantPaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsultantPaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConsultantPaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsultantPaymentPayload>
          }
          findMany: {
            args: Prisma.ConsultantPaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsultantPaymentPayload>[]
          }
          create: {
            args: Prisma.ConsultantPaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsultantPaymentPayload>
          }
          createMany: {
            args: Prisma.ConsultantPaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ConsultantPaymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsultantPaymentPayload>[]
          }
          delete: {
            args: Prisma.ConsultantPaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsultantPaymentPayload>
          }
          update: {
            args: Prisma.ConsultantPaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsultantPaymentPayload>
          }
          deleteMany: {
            args: Prisma.ConsultantPaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConsultantPaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ConsultantPaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsultantPaymentPayload>
          }
          aggregate: {
            args: Prisma.ConsultantPaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConsultantPayment>
          }
          groupBy: {
            args: Prisma.ConsultantPaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConsultantPaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConsultantPaymentCountArgs<ExtArgs>
            result: $Utils.Optional<ConsultantPaymentCountAggregateOutputType> | number
          }
        }
      }
      SystemHealthMetric: {
        payload: Prisma.$SystemHealthMetricPayload<ExtArgs>
        fields: Prisma.SystemHealthMetricFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SystemHealthMetricFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemHealthMetricPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SystemHealthMetricFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemHealthMetricPayload>
          }
          findFirst: {
            args: Prisma.SystemHealthMetricFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemHealthMetricPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SystemHealthMetricFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemHealthMetricPayload>
          }
          findMany: {
            args: Prisma.SystemHealthMetricFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemHealthMetricPayload>[]
          }
          create: {
            args: Prisma.SystemHealthMetricCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemHealthMetricPayload>
          }
          createMany: {
            args: Prisma.SystemHealthMetricCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SystemHealthMetricCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemHealthMetricPayload>[]
          }
          delete: {
            args: Prisma.SystemHealthMetricDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemHealthMetricPayload>
          }
          update: {
            args: Prisma.SystemHealthMetricUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemHealthMetricPayload>
          }
          deleteMany: {
            args: Prisma.SystemHealthMetricDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SystemHealthMetricUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SystemHealthMetricUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemHealthMetricPayload>
          }
          aggregate: {
            args: Prisma.SystemHealthMetricAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSystemHealthMetric>
          }
          groupBy: {
            args: Prisma.SystemHealthMetricGroupByArgs<ExtArgs>
            result: $Utils.Optional<SystemHealthMetricGroupByOutputType>[]
          }
          count: {
            args: Prisma.SystemHealthMetricCountArgs<ExtArgs>
            result: $Utils.Optional<SystemHealthMetricCountAggregateOutputType> | number
          }
        }
      }
      InAppNotification: {
        payload: Prisma.$InAppNotificationPayload<ExtArgs>
        fields: Prisma.InAppNotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InAppNotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InAppNotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InAppNotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InAppNotificationPayload>
          }
          findFirst: {
            args: Prisma.InAppNotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InAppNotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InAppNotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InAppNotificationPayload>
          }
          findMany: {
            args: Prisma.InAppNotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InAppNotificationPayload>[]
          }
          create: {
            args: Prisma.InAppNotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InAppNotificationPayload>
          }
          createMany: {
            args: Prisma.InAppNotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InAppNotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InAppNotificationPayload>[]
          }
          delete: {
            args: Prisma.InAppNotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InAppNotificationPayload>
          }
          update: {
            args: Prisma.InAppNotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InAppNotificationPayload>
          }
          deleteMany: {
            args: Prisma.InAppNotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InAppNotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InAppNotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InAppNotificationPayload>
          }
          aggregate: {
            args: Prisma.InAppNotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInAppNotification>
          }
          groupBy: {
            args: Prisma.InAppNotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<InAppNotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.InAppNotificationCountArgs<ExtArgs>
            result: $Utils.Optional<InAppNotificationCountAggregateOutputType> | number
          }
        }
      }
      ScheduledNotification: {
        payload: Prisma.$ScheduledNotificationPayload<ExtArgs>
        fields: Prisma.ScheduledNotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ScheduledNotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledNotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ScheduledNotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledNotificationPayload>
          }
          findFirst: {
            args: Prisma.ScheduledNotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledNotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ScheduledNotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledNotificationPayload>
          }
          findMany: {
            args: Prisma.ScheduledNotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledNotificationPayload>[]
          }
          create: {
            args: Prisma.ScheduledNotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledNotificationPayload>
          }
          createMany: {
            args: Prisma.ScheduledNotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ScheduledNotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledNotificationPayload>[]
          }
          delete: {
            args: Prisma.ScheduledNotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledNotificationPayload>
          }
          update: {
            args: Prisma.ScheduledNotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledNotificationPayload>
          }
          deleteMany: {
            args: Prisma.ScheduledNotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ScheduledNotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ScheduledNotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledNotificationPayload>
          }
          aggregate: {
            args: Prisma.ScheduledNotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateScheduledNotification>
          }
          groupBy: {
            args: Prisma.ScheduledNotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<ScheduledNotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.ScheduledNotificationCountArgs<ExtArgs>
            result: $Utils.Optional<ScheduledNotificationCountAggregateOutputType> | number
          }
        }
      }
      NotificationLog: {
        payload: Prisma.$NotificationLogPayload<ExtArgs>
        fields: Prisma.NotificationLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationLogPayload>
          }
          findFirst: {
            args: Prisma.NotificationLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationLogPayload>
          }
          findMany: {
            args: Prisma.NotificationLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationLogPayload>[]
          }
          create: {
            args: Prisma.NotificationLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationLogPayload>
          }
          createMany: {
            args: Prisma.NotificationLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationLogPayload>[]
          }
          delete: {
            args: Prisma.NotificationLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationLogPayload>
          }
          update: {
            args: Prisma.NotificationLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationLogPayload>
          }
          deleteMany: {
            args: Prisma.NotificationLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NotificationLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationLogPayload>
          }
          aggregate: {
            args: Prisma.NotificationLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotificationLog>
          }
          groupBy: {
            args: Prisma.NotificationLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationLogCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationLogCountAggregateOutputType> | number
          }
        }
      }
      UserNotificationPreferences: {
        payload: Prisma.$UserNotificationPreferencesPayload<ExtArgs>
        fields: Prisma.UserNotificationPreferencesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserNotificationPreferencesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserNotificationPreferencesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserNotificationPreferencesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserNotificationPreferencesPayload>
          }
          findFirst: {
            args: Prisma.UserNotificationPreferencesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserNotificationPreferencesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserNotificationPreferencesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserNotificationPreferencesPayload>
          }
          findMany: {
            args: Prisma.UserNotificationPreferencesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserNotificationPreferencesPayload>[]
          }
          create: {
            args: Prisma.UserNotificationPreferencesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserNotificationPreferencesPayload>
          }
          createMany: {
            args: Prisma.UserNotificationPreferencesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserNotificationPreferencesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserNotificationPreferencesPayload>[]
          }
          delete: {
            args: Prisma.UserNotificationPreferencesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserNotificationPreferencesPayload>
          }
          update: {
            args: Prisma.UserNotificationPreferencesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserNotificationPreferencesPayload>
          }
          deleteMany: {
            args: Prisma.UserNotificationPreferencesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserNotificationPreferencesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserNotificationPreferencesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserNotificationPreferencesPayload>
          }
          aggregate: {
            args: Prisma.UserNotificationPreferencesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserNotificationPreferences>
          }
          groupBy: {
            args: Prisma.UserNotificationPreferencesGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserNotificationPreferencesGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserNotificationPreferencesCountArgs<ExtArgs>
            result: $Utils.Optional<UserNotificationPreferencesCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type StudentCountOutputType
   */

  export type StudentCountOutputType = {
    consultationSessions: number
    studentDocuments: number
    sessionHistory: number
  }

  export type StudentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    consultationSessions?: boolean | StudentCountOutputTypeCountConsultationSessionsArgs
    studentDocuments?: boolean | StudentCountOutputTypeCountStudentDocumentsArgs
    sessionHistory?: boolean | StudentCountOutputTypeCountSessionHistoryArgs
  }

  // Custom InputTypes
  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentCountOutputType
     */
    select?: StudentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountConsultationSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConsultationSessionWhereInput
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountStudentDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentDocumentWhereInput
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountSessionHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionHistoryWhereInput
  }


  /**
   * Count Type ConsultantCountOutputType
   */

  export type ConsultantCountOutputType = {
    consultationSessions: number
    consultantAvailability: number
    consultantPayments: number
  }

  export type ConsultantCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    consultationSessions?: boolean | ConsultantCountOutputTypeCountConsultationSessionsArgs
    consultantAvailability?: boolean | ConsultantCountOutputTypeCountConsultantAvailabilityArgs
    consultantPayments?: boolean | ConsultantCountOutputTypeCountConsultantPaymentsArgs
  }

  // Custom InputTypes
  /**
   * ConsultantCountOutputType without action
   */
  export type ConsultantCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsultantCountOutputType
     */
    select?: ConsultantCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ConsultantCountOutputType without action
   */
  export type ConsultantCountOutputTypeCountConsultationSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConsultationSessionWhereInput
  }

  /**
   * ConsultantCountOutputType without action
   */
  export type ConsultantCountOutputTypeCountConsultantAvailabilityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConsultantAvailabilityWhereInput
  }

  /**
   * ConsultantCountOutputType without action
   */
  export type ConsultantCountOutputTypeCountConsultantPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConsultantPaymentWhereInput
  }


  /**
   * Count Type VideoSessionCountOutputType
   */

  export type VideoSessionCountOutputType = {
    videoParticipants: number
  }

  export type VideoSessionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    videoParticipants?: boolean | VideoSessionCountOutputTypeCountVideoParticipantsArgs
  }

  // Custom InputTypes
  /**
   * VideoSessionCountOutputType without action
   */
  export type VideoSessionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoSessionCountOutputType
     */
    select?: VideoSessionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * VideoSessionCountOutputType without action
   */
  export type VideoSessionCountOutputTypeCountVideoParticipantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VideoParticipantWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    firstName: string | null
    lastName: string | null
    userType: $Enums.UserType | null
    phone: string | null
    status: $Enums.UserStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    firstName: string | null
    lastName: string | null
    userType: $Enums.UserType | null
    phone: string | null
    status: $Enums.UserStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    password: number
    firstName: number
    lastName: number
    userType: number
    phone: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    password?: true
    firstName?: true
    lastName?: true
    userType?: true
    phone?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    password?: true
    firstName?: true
    lastName?: true
    userType?: true
    phone?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    password?: true
    firstName?: true
    lastName?: true
    userType?: true
    phone?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    password: string
    firstName: string
    lastName: string
    userType: $Enums.UserType
    phone: string | null
    status: $Enums.UserStatus
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    firstName?: boolean
    lastName?: boolean
    userType?: boolean
    phone?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    student?: boolean | User$studentArgs<ExtArgs>
    consultant?: boolean | User$consultantArgs<ExtArgs>
    admin?: boolean | User$adminArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    firstName?: boolean
    lastName?: boolean
    userType?: boolean
    phone?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    password?: boolean
    firstName?: boolean
    lastName?: boolean
    userType?: boolean
    phone?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | User$studentArgs<ExtArgs>
    consultant?: boolean | User$consultantArgs<ExtArgs>
    admin?: boolean | User$adminArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      student: Prisma.$StudentPayload<ExtArgs> | null
      consultant: Prisma.$ConsultantPayload<ExtArgs> | null
      admin: Prisma.$AdminPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      password: string
      firstName: string
      lastName: string
      userType: $Enums.UserType
      phone: string | null
      status: $Enums.UserStatus
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends User$studentArgs<ExtArgs> = {}>(args?: Subset<T, User$studentArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    consultant<T extends User$consultantArgs<ExtArgs> = {}>(args?: Subset<T, User$consultantArgs<ExtArgs>>): Prisma__ConsultantClient<$Result.GetResult<Prisma.$ConsultantPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    admin<T extends User$adminArgs<ExtArgs> = {}>(args?: Subset<T, User$adminArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly firstName: FieldRef<"User", 'String'>
    readonly lastName: FieldRef<"User", 'String'>
    readonly userType: FieldRef<"User", 'UserType'>
    readonly phone: FieldRef<"User", 'String'>
    readonly status: FieldRef<"User", 'UserStatus'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.student
   */
  export type User$studentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    where?: StudentWhereInput
  }

  /**
   * User.consultant
   */
  export type User$consultantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Consultant
     */
    select?: ConsultantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsultantInclude<ExtArgs> | null
    where?: ConsultantWhereInput
  }

  /**
   * User.admin
   */
  export type User$adminArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    where?: AdminWhereInput
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Student
   */

  export type AggregateStudent = {
    _count: StudentCountAggregateOutputType | null
    _avg: StudentAvgAggregateOutputType | null
    _sum: StudentSumAggregateOutputType | null
    _min: StudentMinAggregateOutputType | null
    _max: StudentMaxAggregateOutputType | null
  }

  export type StudentAvgAggregateOutputType = {
    totalVerifiedHours: number | null
    totalVideoHours: number | null
    preferredSessionLength: number | null
  }

  export type StudentSumAggregateOutputType = {
    totalVerifiedHours: number | null
    totalVideoHours: number | null
    preferredSessionLength: number | null
  }

  export type StudentMinAggregateOutputType = {
    id: string | null
    userId: string | null
    kajabiUserId: string | null
    courseCompletionDate: Date | null
    totalVerifiedHours: number | null
    totalVideoHours: number | null
    certificationStatus: $Enums.StudentStatus | null
    preferredSessionLength: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StudentMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    kajabiUserId: string | null
    courseCompletionDate: Date | null
    totalVerifiedHours: number | null
    totalVideoHours: number | null
    certificationStatus: $Enums.StudentStatus | null
    preferredSessionLength: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StudentCountAggregateOutputType = {
    id: number
    userId: number
    kajabiUserId: number
    courseCompletionDate: number
    totalVerifiedHours: number
    totalVideoHours: number
    certificationStatus: number
    preferredSessionLength: number
    consultationPreferences: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StudentAvgAggregateInputType = {
    totalVerifiedHours?: true
    totalVideoHours?: true
    preferredSessionLength?: true
  }

  export type StudentSumAggregateInputType = {
    totalVerifiedHours?: true
    totalVideoHours?: true
    preferredSessionLength?: true
  }

  export type StudentMinAggregateInputType = {
    id?: true
    userId?: true
    kajabiUserId?: true
    courseCompletionDate?: true
    totalVerifiedHours?: true
    totalVideoHours?: true
    certificationStatus?: true
    preferredSessionLength?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StudentMaxAggregateInputType = {
    id?: true
    userId?: true
    kajabiUserId?: true
    courseCompletionDate?: true
    totalVerifiedHours?: true
    totalVideoHours?: true
    certificationStatus?: true
    preferredSessionLength?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StudentCountAggregateInputType = {
    id?: true
    userId?: true
    kajabiUserId?: true
    courseCompletionDate?: true
    totalVerifiedHours?: true
    totalVideoHours?: true
    certificationStatus?: true
    preferredSessionLength?: true
    consultationPreferences?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StudentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Student to aggregate.
     */
    where?: StudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Students
    **/
    _count?: true | StudentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StudentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StudentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentMaxAggregateInputType
  }

  export type GetStudentAggregateType<T extends StudentAggregateArgs> = {
        [P in keyof T & keyof AggregateStudent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudent[P]>
      : GetScalarType<T[P], AggregateStudent[P]>
  }




  export type StudentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentWhereInput
    orderBy?: StudentOrderByWithAggregationInput | StudentOrderByWithAggregationInput[]
    by: StudentScalarFieldEnum[] | StudentScalarFieldEnum
    having?: StudentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentCountAggregateInputType | true
    _avg?: StudentAvgAggregateInputType
    _sum?: StudentSumAggregateInputType
    _min?: StudentMinAggregateInputType
    _max?: StudentMaxAggregateInputType
  }

  export type StudentGroupByOutputType = {
    id: string
    userId: string
    kajabiUserId: string | null
    courseCompletionDate: Date
    totalVerifiedHours: number
    totalVideoHours: number
    certificationStatus: $Enums.StudentStatus
    preferredSessionLength: number
    consultationPreferences: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: StudentCountAggregateOutputType | null
    _avg: StudentAvgAggregateOutputType | null
    _sum: StudentSumAggregateOutputType | null
    _min: StudentMinAggregateOutputType | null
    _max: StudentMaxAggregateOutputType | null
  }

  type GetStudentGroupByPayload<T extends StudentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentGroupByOutputType[P]>
            : GetScalarType<T[P], StudentGroupByOutputType[P]>
        }
      >
    >


  export type StudentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    kajabiUserId?: boolean
    courseCompletionDate?: boolean
    totalVerifiedHours?: boolean
    totalVideoHours?: boolean
    certificationStatus?: boolean
    preferredSessionLength?: boolean
    consultationPreferences?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    consultationSessions?: boolean | Student$consultationSessionsArgs<ExtArgs>
    studentDocuments?: boolean | Student$studentDocumentsArgs<ExtArgs>
    sessionHistory?: boolean | Student$sessionHistoryArgs<ExtArgs>
    _count?: boolean | StudentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["student"]>

  export type StudentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    kajabiUserId?: boolean
    courseCompletionDate?: boolean
    totalVerifiedHours?: boolean
    totalVideoHours?: boolean
    certificationStatus?: boolean
    preferredSessionLength?: boolean
    consultationPreferences?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["student"]>

  export type StudentSelectScalar = {
    id?: boolean
    userId?: boolean
    kajabiUserId?: boolean
    courseCompletionDate?: boolean
    totalVerifiedHours?: boolean
    totalVideoHours?: boolean
    certificationStatus?: boolean
    preferredSessionLength?: boolean
    consultationPreferences?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StudentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    consultationSessions?: boolean | Student$consultationSessionsArgs<ExtArgs>
    studentDocuments?: boolean | Student$studentDocumentsArgs<ExtArgs>
    sessionHistory?: boolean | Student$sessionHistoryArgs<ExtArgs>
    _count?: boolean | StudentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type StudentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $StudentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Student"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      consultationSessions: Prisma.$ConsultationSessionPayload<ExtArgs>[]
      studentDocuments: Prisma.$StudentDocumentPayload<ExtArgs>[]
      sessionHistory: Prisma.$SessionHistoryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      kajabiUserId: string | null
      courseCompletionDate: Date
      totalVerifiedHours: number
      totalVideoHours: number
      certificationStatus: $Enums.StudentStatus
      preferredSessionLength: number
      consultationPreferences: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["student"]>
    composites: {}
  }

  type StudentGetPayload<S extends boolean | null | undefined | StudentDefaultArgs> = $Result.GetResult<Prisma.$StudentPayload, S>

  type StudentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StudentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StudentCountAggregateInputType | true
    }

  export interface StudentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Student'], meta: { name: 'Student' } }
    /**
     * Find zero or one Student that matches the filter.
     * @param {StudentFindUniqueArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StudentFindUniqueArgs>(args: SelectSubset<T, StudentFindUniqueArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Student that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {StudentFindUniqueOrThrowArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StudentFindUniqueOrThrowArgs>(args: SelectSubset<T, StudentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Student that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentFindFirstArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StudentFindFirstArgs>(args?: SelectSubset<T, StudentFindFirstArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Student that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentFindFirstOrThrowArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StudentFindFirstOrThrowArgs>(args?: SelectSubset<T, StudentFindFirstOrThrowArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Students that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Students
     * const students = await prisma.student.findMany()
     * 
     * // Get first 10 Students
     * const students = await prisma.student.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const studentWithIdOnly = await prisma.student.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StudentFindManyArgs>(args?: SelectSubset<T, StudentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Student.
     * @param {StudentCreateArgs} args - Arguments to create a Student.
     * @example
     * // Create one Student
     * const Student = await prisma.student.create({
     *   data: {
     *     // ... data to create a Student
     *   }
     * })
     * 
     */
    create<T extends StudentCreateArgs>(args: SelectSubset<T, StudentCreateArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Students.
     * @param {StudentCreateManyArgs} args - Arguments to create many Students.
     * @example
     * // Create many Students
     * const student = await prisma.student.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StudentCreateManyArgs>(args?: SelectSubset<T, StudentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Students and returns the data saved in the database.
     * @param {StudentCreateManyAndReturnArgs} args - Arguments to create many Students.
     * @example
     * // Create many Students
     * const student = await prisma.student.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Students and only return the `id`
     * const studentWithIdOnly = await prisma.student.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StudentCreateManyAndReturnArgs>(args?: SelectSubset<T, StudentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Student.
     * @param {StudentDeleteArgs} args - Arguments to delete one Student.
     * @example
     * // Delete one Student
     * const Student = await prisma.student.delete({
     *   where: {
     *     // ... filter to delete one Student
     *   }
     * })
     * 
     */
    delete<T extends StudentDeleteArgs>(args: SelectSubset<T, StudentDeleteArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Student.
     * @param {StudentUpdateArgs} args - Arguments to update one Student.
     * @example
     * // Update one Student
     * const student = await prisma.student.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StudentUpdateArgs>(args: SelectSubset<T, StudentUpdateArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Students.
     * @param {StudentDeleteManyArgs} args - Arguments to filter Students to delete.
     * @example
     * // Delete a few Students
     * const { count } = await prisma.student.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StudentDeleteManyArgs>(args?: SelectSubset<T, StudentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Students.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Students
     * const student = await prisma.student.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StudentUpdateManyArgs>(args: SelectSubset<T, StudentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Student.
     * @param {StudentUpsertArgs} args - Arguments to update or create a Student.
     * @example
     * // Update or create a Student
     * const student = await prisma.student.upsert({
     *   create: {
     *     // ... data to create a Student
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Student we want to update
     *   }
     * })
     */
    upsert<T extends StudentUpsertArgs>(args: SelectSubset<T, StudentUpsertArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Students.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentCountArgs} args - Arguments to filter Students to count.
     * @example
     * // Count the number of Students
     * const count = await prisma.student.count({
     *   where: {
     *     // ... the filter for the Students we want to count
     *   }
     * })
    **/
    count<T extends StudentCountArgs>(
      args?: Subset<T, StudentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Student.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentAggregateArgs>(args: Subset<T, StudentAggregateArgs>): Prisma.PrismaPromise<GetStudentAggregateType<T>>

    /**
     * Group by Student.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudentGroupByArgs['orderBy'] }
        : { orderBy?: StudentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Student model
   */
  readonly fields: StudentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Student.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StudentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    consultationSessions<T extends Student$consultationSessionsArgs<ExtArgs> = {}>(args?: Subset<T, Student$consultationSessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConsultationSessionPayload<ExtArgs>, T, "findMany"> | Null>
    studentDocuments<T extends Student$studentDocumentsArgs<ExtArgs> = {}>(args?: Subset<T, Student$studentDocumentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentDocumentPayload<ExtArgs>, T, "findMany"> | Null>
    sessionHistory<T extends Student$sessionHistoryArgs<ExtArgs> = {}>(args?: Subset<T, Student$sessionHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionHistoryPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Student model
   */ 
  interface StudentFieldRefs {
    readonly id: FieldRef<"Student", 'String'>
    readonly userId: FieldRef<"Student", 'String'>
    readonly kajabiUserId: FieldRef<"Student", 'String'>
    readonly courseCompletionDate: FieldRef<"Student", 'DateTime'>
    readonly totalVerifiedHours: FieldRef<"Student", 'Float'>
    readonly totalVideoHours: FieldRef<"Student", 'Float'>
    readonly certificationStatus: FieldRef<"Student", 'StudentStatus'>
    readonly preferredSessionLength: FieldRef<"Student", 'Int'>
    readonly consultationPreferences: FieldRef<"Student", 'Json'>
    readonly createdAt: FieldRef<"Student", 'DateTime'>
    readonly updatedAt: FieldRef<"Student", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Student findUnique
   */
  export type StudentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Student to fetch.
     */
    where: StudentWhereUniqueInput
  }

  /**
   * Student findUniqueOrThrow
   */
  export type StudentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Student to fetch.
     */
    where: StudentWhereUniqueInput
  }

  /**
   * Student findFirst
   */
  export type StudentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Student to fetch.
     */
    where?: StudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Students.
     */
    cursor?: StudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Students.
     */
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * Student findFirstOrThrow
   */
  export type StudentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Student to fetch.
     */
    where?: StudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Students.
     */
    cursor?: StudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Students.
     */
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * Student findMany
   */
  export type StudentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Students to fetch.
     */
    where?: StudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Students.
     */
    cursor?: StudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * Student create
   */
  export type StudentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * The data needed to create a Student.
     */
    data: XOR<StudentCreateInput, StudentUncheckedCreateInput>
  }

  /**
   * Student createMany
   */
  export type StudentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Students.
     */
    data: StudentCreateManyInput | StudentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Student createManyAndReturn
   */
  export type StudentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Students.
     */
    data: StudentCreateManyInput | StudentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Student update
   */
  export type StudentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * The data needed to update a Student.
     */
    data: XOR<StudentUpdateInput, StudentUncheckedUpdateInput>
    /**
     * Choose, which Student to update.
     */
    where: StudentWhereUniqueInput
  }

  /**
   * Student updateMany
   */
  export type StudentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Students.
     */
    data: XOR<StudentUpdateManyMutationInput, StudentUncheckedUpdateManyInput>
    /**
     * Filter which Students to update
     */
    where?: StudentWhereInput
  }

  /**
   * Student upsert
   */
  export type StudentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * The filter to search for the Student to update in case it exists.
     */
    where: StudentWhereUniqueInput
    /**
     * In case the Student found by the `where` argument doesn't exist, create a new Student with this data.
     */
    create: XOR<StudentCreateInput, StudentUncheckedCreateInput>
    /**
     * In case the Student was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudentUpdateInput, StudentUncheckedUpdateInput>
  }

  /**
   * Student delete
   */
  export type StudentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter which Student to delete.
     */
    where: StudentWhereUniqueInput
  }

  /**
   * Student deleteMany
   */
  export type StudentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Students to delete
     */
    where?: StudentWhereInput
  }

  /**
   * Student.consultationSessions
   */
  export type Student$consultationSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsultationSession
     */
    select?: ConsultationSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsultationSessionInclude<ExtArgs> | null
    where?: ConsultationSessionWhereInput
    orderBy?: ConsultationSessionOrderByWithRelationInput | ConsultationSessionOrderByWithRelationInput[]
    cursor?: ConsultationSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConsultationSessionScalarFieldEnum | ConsultationSessionScalarFieldEnum[]
  }

  /**
   * Student.studentDocuments
   */
  export type Student$studentDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentDocument
     */
    select?: StudentDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentDocumentInclude<ExtArgs> | null
    where?: StudentDocumentWhereInput
    orderBy?: StudentDocumentOrderByWithRelationInput | StudentDocumentOrderByWithRelationInput[]
    cursor?: StudentDocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentDocumentScalarFieldEnum | StudentDocumentScalarFieldEnum[]
  }

  /**
   * Student.sessionHistory
   */
  export type Student$sessionHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionHistory
     */
    select?: SessionHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionHistoryInclude<ExtArgs> | null
    where?: SessionHistoryWhereInput
    orderBy?: SessionHistoryOrderByWithRelationInput | SessionHistoryOrderByWithRelationInput[]
    cursor?: SessionHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionHistoryScalarFieldEnum | SessionHistoryScalarFieldEnum[]
  }

  /**
   * Student without action
   */
  export type StudentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
  }


  /**
   * Model Consultant
   */

  export type AggregateConsultant = {
    _count: ConsultantCountAggregateOutputType | null
    _avg: ConsultantAvgAggregateOutputType | null
    _sum: ConsultantSumAggregateOutputType | null
    _min: ConsultantMinAggregateOutputType | null
    _max: ConsultantMaxAggregateOutputType | null
  }

  export type ConsultantAvgAggregateOutputType = {
    hourlyRate: number | null
  }

  export type ConsultantSumAggregateOutputType = {
    hourlyRate: number | null
  }

  export type ConsultantMinAggregateOutputType = {
    id: string | null
    userId: string | null
    bio: string | null
    hourlyRate: number | null
    isActive: boolean | null
    timezone: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConsultantMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    bio: string | null
    hourlyRate: number | null
    isActive: boolean | null
    timezone: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConsultantCountAggregateOutputType = {
    id: number
    userId: number
    bio: number
    specialties: number
    hourlyRate: number
    isActive: number
    timezone: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ConsultantAvgAggregateInputType = {
    hourlyRate?: true
  }

  export type ConsultantSumAggregateInputType = {
    hourlyRate?: true
  }

  export type ConsultantMinAggregateInputType = {
    id?: true
    userId?: true
    bio?: true
    hourlyRate?: true
    isActive?: true
    timezone?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConsultantMaxAggregateInputType = {
    id?: true
    userId?: true
    bio?: true
    hourlyRate?: true
    isActive?: true
    timezone?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConsultantCountAggregateInputType = {
    id?: true
    userId?: true
    bio?: true
    specialties?: true
    hourlyRate?: true
    isActive?: true
    timezone?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ConsultantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Consultant to aggregate.
     */
    where?: ConsultantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Consultants to fetch.
     */
    orderBy?: ConsultantOrderByWithRelationInput | ConsultantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConsultantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Consultants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Consultants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Consultants
    **/
    _count?: true | ConsultantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ConsultantAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ConsultantSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConsultantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConsultantMaxAggregateInputType
  }

  export type GetConsultantAggregateType<T extends ConsultantAggregateArgs> = {
        [P in keyof T & keyof AggregateConsultant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConsultant[P]>
      : GetScalarType<T[P], AggregateConsultant[P]>
  }




  export type ConsultantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConsultantWhereInput
    orderBy?: ConsultantOrderByWithAggregationInput | ConsultantOrderByWithAggregationInput[]
    by: ConsultantScalarFieldEnum[] | ConsultantScalarFieldEnum
    having?: ConsultantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConsultantCountAggregateInputType | true
    _avg?: ConsultantAvgAggregateInputType
    _sum?: ConsultantSumAggregateInputType
    _min?: ConsultantMinAggregateInputType
    _max?: ConsultantMaxAggregateInputType
  }

  export type ConsultantGroupByOutputType = {
    id: string
    userId: string
    bio: string | null
    specialties: string[]
    hourlyRate: number
    isActive: boolean
    timezone: string
    createdAt: Date
    updatedAt: Date
    _count: ConsultantCountAggregateOutputType | null
    _avg: ConsultantAvgAggregateOutputType | null
    _sum: ConsultantSumAggregateOutputType | null
    _min: ConsultantMinAggregateOutputType | null
    _max: ConsultantMaxAggregateOutputType | null
  }

  type GetConsultantGroupByPayload<T extends ConsultantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConsultantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConsultantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConsultantGroupByOutputType[P]>
            : GetScalarType<T[P], ConsultantGroupByOutputType[P]>
        }
      >
    >


  export type ConsultantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    bio?: boolean
    specialties?: boolean
    hourlyRate?: boolean
    isActive?: boolean
    timezone?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    consultationSessions?: boolean | Consultant$consultationSessionsArgs<ExtArgs>
    consultantAvailability?: boolean | Consultant$consultantAvailabilityArgs<ExtArgs>
    consultantPayments?: boolean | Consultant$consultantPaymentsArgs<ExtArgs>
    _count?: boolean | ConsultantCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["consultant"]>

  export type ConsultantSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    bio?: boolean
    specialties?: boolean
    hourlyRate?: boolean
    isActive?: boolean
    timezone?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["consultant"]>

  export type ConsultantSelectScalar = {
    id?: boolean
    userId?: boolean
    bio?: boolean
    specialties?: boolean
    hourlyRate?: boolean
    isActive?: boolean
    timezone?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ConsultantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    consultationSessions?: boolean | Consultant$consultationSessionsArgs<ExtArgs>
    consultantAvailability?: boolean | Consultant$consultantAvailabilityArgs<ExtArgs>
    consultantPayments?: boolean | Consultant$consultantPaymentsArgs<ExtArgs>
    _count?: boolean | ConsultantCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ConsultantIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ConsultantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Consultant"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      consultationSessions: Prisma.$ConsultationSessionPayload<ExtArgs>[]
      consultantAvailability: Prisma.$ConsultantAvailabilityPayload<ExtArgs>[]
      consultantPayments: Prisma.$ConsultantPaymentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      bio: string | null
      specialties: string[]
      hourlyRate: number
      isActive: boolean
      timezone: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["consultant"]>
    composites: {}
  }

  type ConsultantGetPayload<S extends boolean | null | undefined | ConsultantDefaultArgs> = $Result.GetResult<Prisma.$ConsultantPayload, S>

  type ConsultantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ConsultantFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ConsultantCountAggregateInputType | true
    }

  export interface ConsultantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Consultant'], meta: { name: 'Consultant' } }
    /**
     * Find zero or one Consultant that matches the filter.
     * @param {ConsultantFindUniqueArgs} args - Arguments to find a Consultant
     * @example
     * // Get one Consultant
     * const consultant = await prisma.consultant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConsultantFindUniqueArgs>(args: SelectSubset<T, ConsultantFindUniqueArgs<ExtArgs>>): Prisma__ConsultantClient<$Result.GetResult<Prisma.$ConsultantPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Consultant that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ConsultantFindUniqueOrThrowArgs} args - Arguments to find a Consultant
     * @example
     * // Get one Consultant
     * const consultant = await prisma.consultant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConsultantFindUniqueOrThrowArgs>(args: SelectSubset<T, ConsultantFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConsultantClient<$Result.GetResult<Prisma.$ConsultantPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Consultant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsultantFindFirstArgs} args - Arguments to find a Consultant
     * @example
     * // Get one Consultant
     * const consultant = await prisma.consultant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConsultantFindFirstArgs>(args?: SelectSubset<T, ConsultantFindFirstArgs<ExtArgs>>): Prisma__ConsultantClient<$Result.GetResult<Prisma.$ConsultantPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Consultant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsultantFindFirstOrThrowArgs} args - Arguments to find a Consultant
     * @example
     * // Get one Consultant
     * const consultant = await prisma.consultant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConsultantFindFirstOrThrowArgs>(args?: SelectSubset<T, ConsultantFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConsultantClient<$Result.GetResult<Prisma.$ConsultantPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Consultants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsultantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Consultants
     * const consultants = await prisma.consultant.findMany()
     * 
     * // Get first 10 Consultants
     * const consultants = await prisma.consultant.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const consultantWithIdOnly = await prisma.consultant.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ConsultantFindManyArgs>(args?: SelectSubset<T, ConsultantFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConsultantPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Consultant.
     * @param {ConsultantCreateArgs} args - Arguments to create a Consultant.
     * @example
     * // Create one Consultant
     * const Consultant = await prisma.consultant.create({
     *   data: {
     *     // ... data to create a Consultant
     *   }
     * })
     * 
     */
    create<T extends ConsultantCreateArgs>(args: SelectSubset<T, ConsultantCreateArgs<ExtArgs>>): Prisma__ConsultantClient<$Result.GetResult<Prisma.$ConsultantPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Consultants.
     * @param {ConsultantCreateManyArgs} args - Arguments to create many Consultants.
     * @example
     * // Create many Consultants
     * const consultant = await prisma.consultant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConsultantCreateManyArgs>(args?: SelectSubset<T, ConsultantCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Consultants and returns the data saved in the database.
     * @param {ConsultantCreateManyAndReturnArgs} args - Arguments to create many Consultants.
     * @example
     * // Create many Consultants
     * const consultant = await prisma.consultant.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Consultants and only return the `id`
     * const consultantWithIdOnly = await prisma.consultant.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ConsultantCreateManyAndReturnArgs>(args?: SelectSubset<T, ConsultantCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConsultantPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Consultant.
     * @param {ConsultantDeleteArgs} args - Arguments to delete one Consultant.
     * @example
     * // Delete one Consultant
     * const Consultant = await prisma.consultant.delete({
     *   where: {
     *     // ... filter to delete one Consultant
     *   }
     * })
     * 
     */
    delete<T extends ConsultantDeleteArgs>(args: SelectSubset<T, ConsultantDeleteArgs<ExtArgs>>): Prisma__ConsultantClient<$Result.GetResult<Prisma.$ConsultantPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Consultant.
     * @param {ConsultantUpdateArgs} args - Arguments to update one Consultant.
     * @example
     * // Update one Consultant
     * const consultant = await prisma.consultant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConsultantUpdateArgs>(args: SelectSubset<T, ConsultantUpdateArgs<ExtArgs>>): Prisma__ConsultantClient<$Result.GetResult<Prisma.$ConsultantPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Consultants.
     * @param {ConsultantDeleteManyArgs} args - Arguments to filter Consultants to delete.
     * @example
     * // Delete a few Consultants
     * const { count } = await prisma.consultant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConsultantDeleteManyArgs>(args?: SelectSubset<T, ConsultantDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Consultants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsultantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Consultants
     * const consultant = await prisma.consultant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConsultantUpdateManyArgs>(args: SelectSubset<T, ConsultantUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Consultant.
     * @param {ConsultantUpsertArgs} args - Arguments to update or create a Consultant.
     * @example
     * // Update or create a Consultant
     * const consultant = await prisma.consultant.upsert({
     *   create: {
     *     // ... data to create a Consultant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Consultant we want to update
     *   }
     * })
     */
    upsert<T extends ConsultantUpsertArgs>(args: SelectSubset<T, ConsultantUpsertArgs<ExtArgs>>): Prisma__ConsultantClient<$Result.GetResult<Prisma.$ConsultantPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Consultants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsultantCountArgs} args - Arguments to filter Consultants to count.
     * @example
     * // Count the number of Consultants
     * const count = await prisma.consultant.count({
     *   where: {
     *     // ... the filter for the Consultants we want to count
     *   }
     * })
    **/
    count<T extends ConsultantCountArgs>(
      args?: Subset<T, ConsultantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConsultantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Consultant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsultantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConsultantAggregateArgs>(args: Subset<T, ConsultantAggregateArgs>): Prisma.PrismaPromise<GetConsultantAggregateType<T>>

    /**
     * Group by Consultant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsultantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConsultantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConsultantGroupByArgs['orderBy'] }
        : { orderBy?: ConsultantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConsultantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConsultantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Consultant model
   */
  readonly fields: ConsultantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Consultant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConsultantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    consultationSessions<T extends Consultant$consultationSessionsArgs<ExtArgs> = {}>(args?: Subset<T, Consultant$consultationSessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConsultationSessionPayload<ExtArgs>, T, "findMany"> | Null>
    consultantAvailability<T extends Consultant$consultantAvailabilityArgs<ExtArgs> = {}>(args?: Subset<T, Consultant$consultantAvailabilityArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConsultantAvailabilityPayload<ExtArgs>, T, "findMany"> | Null>
    consultantPayments<T extends Consultant$consultantPaymentsArgs<ExtArgs> = {}>(args?: Subset<T, Consultant$consultantPaymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConsultantPaymentPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Consultant model
   */ 
  interface ConsultantFieldRefs {
    readonly id: FieldRef<"Consultant", 'String'>
    readonly userId: FieldRef<"Consultant", 'String'>
    readonly bio: FieldRef<"Consultant", 'String'>
    readonly specialties: FieldRef<"Consultant", 'String[]'>
    readonly hourlyRate: FieldRef<"Consultant", 'Float'>
    readonly isActive: FieldRef<"Consultant", 'Boolean'>
    readonly timezone: FieldRef<"Consultant", 'String'>
    readonly createdAt: FieldRef<"Consultant", 'DateTime'>
    readonly updatedAt: FieldRef<"Consultant", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Consultant findUnique
   */
  export type ConsultantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Consultant
     */
    select?: ConsultantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsultantInclude<ExtArgs> | null
    /**
     * Filter, which Consultant to fetch.
     */
    where: ConsultantWhereUniqueInput
  }

  /**
   * Consultant findUniqueOrThrow
   */
  export type ConsultantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Consultant
     */
    select?: ConsultantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsultantInclude<ExtArgs> | null
    /**
     * Filter, which Consultant to fetch.
     */
    where: ConsultantWhereUniqueInput
  }

  /**
   * Consultant findFirst
   */
  export type ConsultantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Consultant
     */
    select?: ConsultantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsultantInclude<ExtArgs> | null
    /**
     * Filter, which Consultant to fetch.
     */
    where?: ConsultantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Consultants to fetch.
     */
    orderBy?: ConsultantOrderByWithRelationInput | ConsultantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Consultants.
     */
    cursor?: ConsultantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Consultants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Consultants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Consultants.
     */
    distinct?: ConsultantScalarFieldEnum | ConsultantScalarFieldEnum[]
  }

  /**
   * Consultant findFirstOrThrow
   */
  export type ConsultantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Consultant
     */
    select?: ConsultantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsultantInclude<ExtArgs> | null
    /**
     * Filter, which Consultant to fetch.
     */
    where?: ConsultantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Consultants to fetch.
     */
    orderBy?: ConsultantOrderByWithRelationInput | ConsultantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Consultants.
     */
    cursor?: ConsultantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Consultants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Consultants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Consultants.
     */
    distinct?: ConsultantScalarFieldEnum | ConsultantScalarFieldEnum[]
  }

  /**
   * Consultant findMany
   */
  export type ConsultantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Consultant
     */
    select?: ConsultantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsultantInclude<ExtArgs> | null
    /**
     * Filter, which Consultants to fetch.
     */
    where?: ConsultantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Consultants to fetch.
     */
    orderBy?: ConsultantOrderByWithRelationInput | ConsultantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Consultants.
     */
    cursor?: ConsultantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Consultants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Consultants.
     */
    skip?: number
    distinct?: ConsultantScalarFieldEnum | ConsultantScalarFieldEnum[]
  }

  /**
   * Consultant create
   */
  export type ConsultantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Consultant
     */
    select?: ConsultantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsultantInclude<ExtArgs> | null
    /**
     * The data needed to create a Consultant.
     */
    data: XOR<ConsultantCreateInput, ConsultantUncheckedCreateInput>
  }

  /**
   * Consultant createMany
   */
  export type ConsultantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Consultants.
     */
    data: ConsultantCreateManyInput | ConsultantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Consultant createManyAndReturn
   */
  export type ConsultantCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Consultant
     */
    select?: ConsultantSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Consultants.
     */
    data: ConsultantCreateManyInput | ConsultantCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsultantIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Consultant update
   */
  export type ConsultantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Consultant
     */
    select?: ConsultantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsultantInclude<ExtArgs> | null
    /**
     * The data needed to update a Consultant.
     */
    data: XOR<ConsultantUpdateInput, ConsultantUncheckedUpdateInput>
    /**
     * Choose, which Consultant to update.
     */
    where: ConsultantWhereUniqueInput
  }

  /**
   * Consultant updateMany
   */
  export type ConsultantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Consultants.
     */
    data: XOR<ConsultantUpdateManyMutationInput, ConsultantUncheckedUpdateManyInput>
    /**
     * Filter which Consultants to update
     */
    where?: ConsultantWhereInput
  }

  /**
   * Consultant upsert
   */
  export type ConsultantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Consultant
     */
    select?: ConsultantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsultantInclude<ExtArgs> | null
    /**
     * The filter to search for the Consultant to update in case it exists.
     */
    where: ConsultantWhereUniqueInput
    /**
     * In case the Consultant found by the `where` argument doesn't exist, create a new Consultant with this data.
     */
    create: XOR<ConsultantCreateInput, ConsultantUncheckedCreateInput>
    /**
     * In case the Consultant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConsultantUpdateInput, ConsultantUncheckedUpdateInput>
  }

  /**
   * Consultant delete
   */
  export type ConsultantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Consultant
     */
    select?: ConsultantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsultantInclude<ExtArgs> | null
    /**
     * Filter which Consultant to delete.
     */
    where: ConsultantWhereUniqueInput
  }

  /**
   * Consultant deleteMany
   */
  export type ConsultantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Consultants to delete
     */
    where?: ConsultantWhereInput
  }

  /**
   * Consultant.consultationSessions
   */
  export type Consultant$consultationSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsultationSession
     */
    select?: ConsultationSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsultationSessionInclude<ExtArgs> | null
    where?: ConsultationSessionWhereInput
    orderBy?: ConsultationSessionOrderByWithRelationInput | ConsultationSessionOrderByWithRelationInput[]
    cursor?: ConsultationSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConsultationSessionScalarFieldEnum | ConsultationSessionScalarFieldEnum[]
  }

  /**
   * Consultant.consultantAvailability
   */
  export type Consultant$consultantAvailabilityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsultantAvailability
     */
    select?: ConsultantAvailabilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsultantAvailabilityInclude<ExtArgs> | null
    where?: ConsultantAvailabilityWhereInput
    orderBy?: ConsultantAvailabilityOrderByWithRelationInput | ConsultantAvailabilityOrderByWithRelationInput[]
    cursor?: ConsultantAvailabilityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConsultantAvailabilityScalarFieldEnum | ConsultantAvailabilityScalarFieldEnum[]
  }

  /**
   * Consultant.consultantPayments
   */
  export type Consultant$consultantPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsultantPayment
     */
    select?: ConsultantPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsultantPaymentInclude<ExtArgs> | null
    where?: ConsultantPaymentWhereInput
    orderBy?: ConsultantPaymentOrderByWithRelationInput | ConsultantPaymentOrderByWithRelationInput[]
    cursor?: ConsultantPaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConsultantPaymentScalarFieldEnum | ConsultantPaymentScalarFieldEnum[]
  }

  /**
   * Consultant without action
   */
  export type ConsultantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Consultant
     */
    select?: ConsultantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsultantInclude<ExtArgs> | null
  }


  /**
   * Model Admin
   */

  export type AggregateAdmin = {
    _count: AdminCountAggregateOutputType | null
    _min: AdminMinAggregateOutputType | null
    _max: AdminMaxAggregateOutputType | null
  }

  export type AdminMinAggregateOutputType = {
    id: string | null
    userId: string | null
    role: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdminMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    role: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdminCountAggregateOutputType = {
    id: number
    userId: number
    role: number
    permissions: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AdminMinAggregateInputType = {
    id?: true
    userId?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdminMaxAggregateInputType = {
    id?: true
    userId?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdminCountAggregateInputType = {
    id?: true
    userId?: true
    role?: true
    permissions?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AdminAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Admin to aggregate.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Admins
    **/
    _count?: true | AdminCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminMaxAggregateInputType
  }

  export type GetAdminAggregateType<T extends AdminAggregateArgs> = {
        [P in keyof T & keyof AggregateAdmin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdmin[P]>
      : GetScalarType<T[P], AggregateAdmin[P]>
  }




  export type AdminGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminWhereInput
    orderBy?: AdminOrderByWithAggregationInput | AdminOrderByWithAggregationInput[]
    by: AdminScalarFieldEnum[] | AdminScalarFieldEnum
    having?: AdminScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminCountAggregateInputType | true
    _min?: AdminMinAggregateInputType
    _max?: AdminMaxAggregateInputType
  }

  export type AdminGroupByOutputType = {
    id: string
    userId: string
    role: string
    permissions: string[]
    createdAt: Date
    updatedAt: Date
    _count: AdminCountAggregateOutputType | null
    _min: AdminMinAggregateOutputType | null
    _max: AdminMaxAggregateOutputType | null
  }

  type GetAdminGroupByPayload<T extends AdminGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminGroupByOutputType[P]>
            : GetScalarType<T[P], AdminGroupByOutputType[P]>
        }
      >
    >


  export type AdminSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    role?: boolean
    permissions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["admin"]>

  export type AdminSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    role?: boolean
    permissions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["admin"]>

  export type AdminSelectScalar = {
    id?: boolean
    userId?: boolean
    role?: boolean
    permissions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AdminInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AdminIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AdminPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Admin"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      role: string
      permissions: string[]
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["admin"]>
    composites: {}
  }

  type AdminGetPayload<S extends boolean | null | undefined | AdminDefaultArgs> = $Result.GetResult<Prisma.$AdminPayload, S>

  type AdminCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AdminFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AdminCountAggregateInputType | true
    }

  export interface AdminDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Admin'], meta: { name: 'Admin' } }
    /**
     * Find zero or one Admin that matches the filter.
     * @param {AdminFindUniqueArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdminFindUniqueArgs>(args: SelectSubset<T, AdminFindUniqueArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Admin that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AdminFindUniqueOrThrowArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdminFindUniqueOrThrowArgs>(args: SelectSubset<T, AdminFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Admin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindFirstArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdminFindFirstArgs>(args?: SelectSubset<T, AdminFindFirstArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Admin that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindFirstOrThrowArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdminFindFirstOrThrowArgs>(args?: SelectSubset<T, AdminFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Admins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Admins
     * const admins = await prisma.admin.findMany()
     * 
     * // Get first 10 Admins
     * const admins = await prisma.admin.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminWithIdOnly = await prisma.admin.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdminFindManyArgs>(args?: SelectSubset<T, AdminFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Admin.
     * @param {AdminCreateArgs} args - Arguments to create a Admin.
     * @example
     * // Create one Admin
     * const Admin = await prisma.admin.create({
     *   data: {
     *     // ... data to create a Admin
     *   }
     * })
     * 
     */
    create<T extends AdminCreateArgs>(args: SelectSubset<T, AdminCreateArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Admins.
     * @param {AdminCreateManyArgs} args - Arguments to create many Admins.
     * @example
     * // Create many Admins
     * const admin = await prisma.admin.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdminCreateManyArgs>(args?: SelectSubset<T, AdminCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Admins and returns the data saved in the database.
     * @param {AdminCreateManyAndReturnArgs} args - Arguments to create many Admins.
     * @example
     * // Create many Admins
     * const admin = await prisma.admin.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Admins and only return the `id`
     * const adminWithIdOnly = await prisma.admin.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdminCreateManyAndReturnArgs>(args?: SelectSubset<T, AdminCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Admin.
     * @param {AdminDeleteArgs} args - Arguments to delete one Admin.
     * @example
     * // Delete one Admin
     * const Admin = await prisma.admin.delete({
     *   where: {
     *     // ... filter to delete one Admin
     *   }
     * })
     * 
     */
    delete<T extends AdminDeleteArgs>(args: SelectSubset<T, AdminDeleteArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Admin.
     * @param {AdminUpdateArgs} args - Arguments to update one Admin.
     * @example
     * // Update one Admin
     * const admin = await prisma.admin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdminUpdateArgs>(args: SelectSubset<T, AdminUpdateArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Admins.
     * @param {AdminDeleteManyArgs} args - Arguments to filter Admins to delete.
     * @example
     * // Delete a few Admins
     * const { count } = await prisma.admin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdminDeleteManyArgs>(args?: SelectSubset<T, AdminDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Admins
     * const admin = await prisma.admin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdminUpdateManyArgs>(args: SelectSubset<T, AdminUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Admin.
     * @param {AdminUpsertArgs} args - Arguments to update or create a Admin.
     * @example
     * // Update or create a Admin
     * const admin = await prisma.admin.upsert({
     *   create: {
     *     // ... data to create a Admin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Admin we want to update
     *   }
     * })
     */
    upsert<T extends AdminUpsertArgs>(args: SelectSubset<T, AdminUpsertArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminCountArgs} args - Arguments to filter Admins to count.
     * @example
     * // Count the number of Admins
     * const count = await prisma.admin.count({
     *   where: {
     *     // ... the filter for the Admins we want to count
     *   }
     * })
    **/
    count<T extends AdminCountArgs>(
      args?: Subset<T, AdminCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminAggregateArgs>(args: Subset<T, AdminAggregateArgs>): Prisma.PrismaPromise<GetAdminAggregateType<T>>

    /**
     * Group by Admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminGroupByArgs['orderBy'] }
        : { orderBy?: AdminGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Admin model
   */
  readonly fields: AdminFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Admin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdminClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Admin model
   */ 
  interface AdminFieldRefs {
    readonly id: FieldRef<"Admin", 'String'>
    readonly userId: FieldRef<"Admin", 'String'>
    readonly role: FieldRef<"Admin", 'String'>
    readonly permissions: FieldRef<"Admin", 'String[]'>
    readonly createdAt: FieldRef<"Admin", 'DateTime'>
    readonly updatedAt: FieldRef<"Admin", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Admin findUnique
   */
  export type AdminFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin findUniqueOrThrow
   */
  export type AdminFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin findFirst
   */
  export type AdminFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Admins.
     */
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * Admin findFirstOrThrow
   */
  export type AdminFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Admins.
     */
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * Admin findMany
   */
  export type AdminFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admins to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * Admin create
   */
  export type AdminCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * The data needed to create a Admin.
     */
    data: XOR<AdminCreateInput, AdminUncheckedCreateInput>
  }

  /**
   * Admin createMany
   */
  export type AdminCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Admins.
     */
    data: AdminCreateManyInput | AdminCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Admin createManyAndReturn
   */
  export type AdminCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Admins.
     */
    data: AdminCreateManyInput | AdminCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Admin update
   */
  export type AdminUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * The data needed to update a Admin.
     */
    data: XOR<AdminUpdateInput, AdminUncheckedUpdateInput>
    /**
     * Choose, which Admin to update.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin updateMany
   */
  export type AdminUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Admins.
     */
    data: XOR<AdminUpdateManyMutationInput, AdminUncheckedUpdateManyInput>
    /**
     * Filter which Admins to update
     */
    where?: AdminWhereInput
  }

  /**
   * Admin upsert
   */
  export type AdminUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * The filter to search for the Admin to update in case it exists.
     */
    where: AdminWhereUniqueInput
    /**
     * In case the Admin found by the `where` argument doesn't exist, create a new Admin with this data.
     */
    create: XOR<AdminCreateInput, AdminUncheckedCreateInput>
    /**
     * In case the Admin was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdminUpdateInput, AdminUncheckedUpdateInput>
  }

  /**
   * Admin delete
   */
  export type AdminDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter which Admin to delete.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin deleteMany
   */
  export type AdminDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Admins to delete
     */
    where?: AdminWhereInput
  }

  /**
   * Admin without action
   */
  export type AdminDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
  }


  /**
   * Model ConsultationSession
   */

  export type AggregateConsultationSession = {
    _count: ConsultationSessionCountAggregateOutputType | null
    _avg: ConsultationSessionAvgAggregateOutputType | null
    _sum: ConsultationSessionSumAggregateOutputType | null
    _min: ConsultationSessionMinAggregateOutputType | null
    _max: ConsultationSessionMaxAggregateOutputType | null
  }

  export type ConsultationSessionAvgAggregateOutputType = {
    sessionRating: number | null
  }

  export type ConsultationSessionSumAggregateOutputType = {
    sessionRating: number | null
  }

  export type ConsultationSessionMinAggregateOutputType = {
    id: string | null
    studentId: string | null
    consultantId: string | null
    scheduledStart: Date | null
    scheduledEnd: Date | null
    actualStart: Date | null
    actualEnd: Date | null
    status: $Enums.SessionStatus | null
    sessionType: string | null
    studentVerifiedAt: Date | null
    consultantVerifiedAt: Date | null
    studentNotes: string | null
    consultantNotes: string | null
    sessionRating: number | null
    technicalIssuesReported: boolean | null
    makeupSessionFor: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConsultationSessionMaxAggregateOutputType = {
    id: string | null
    studentId: string | null
    consultantId: string | null
    scheduledStart: Date | null
    scheduledEnd: Date | null
    actualStart: Date | null
    actualEnd: Date | null
    status: $Enums.SessionStatus | null
    sessionType: string | null
    studentVerifiedAt: Date | null
    consultantVerifiedAt: Date | null
    studentNotes: string | null
    consultantNotes: string | null
    sessionRating: number | null
    technicalIssuesReported: boolean | null
    makeupSessionFor: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConsultationSessionCountAggregateOutputType = {
    id: number
    studentId: number
    consultantId: number
    scheduledStart: number
    scheduledEnd: number
    actualStart: number
    actualEnd: number
    status: number
    sessionType: number
    studentVerifiedAt: number
    consultantVerifiedAt: number
    studentNotes: number
    consultantNotes: number
    sessionRating: number
    technicalIssuesReported: number
    makeupSessionFor: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ConsultationSessionAvgAggregateInputType = {
    sessionRating?: true
  }

  export type ConsultationSessionSumAggregateInputType = {
    sessionRating?: true
  }

  export type ConsultationSessionMinAggregateInputType = {
    id?: true
    studentId?: true
    consultantId?: true
    scheduledStart?: true
    scheduledEnd?: true
    actualStart?: true
    actualEnd?: true
    status?: true
    sessionType?: true
    studentVerifiedAt?: true
    consultantVerifiedAt?: true
    studentNotes?: true
    consultantNotes?: true
    sessionRating?: true
    technicalIssuesReported?: true
    makeupSessionFor?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConsultationSessionMaxAggregateInputType = {
    id?: true
    studentId?: true
    consultantId?: true
    scheduledStart?: true
    scheduledEnd?: true
    actualStart?: true
    actualEnd?: true
    status?: true
    sessionType?: true
    studentVerifiedAt?: true
    consultantVerifiedAt?: true
    studentNotes?: true
    consultantNotes?: true
    sessionRating?: true
    technicalIssuesReported?: true
    makeupSessionFor?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConsultationSessionCountAggregateInputType = {
    id?: true
    studentId?: true
    consultantId?: true
    scheduledStart?: true
    scheduledEnd?: true
    actualStart?: true
    actualEnd?: true
    status?: true
    sessionType?: true
    studentVerifiedAt?: true
    consultantVerifiedAt?: true
    studentNotes?: true
    consultantNotes?: true
    sessionRating?: true
    technicalIssuesReported?: true
    makeupSessionFor?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ConsultationSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConsultationSession to aggregate.
     */
    where?: ConsultationSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConsultationSessions to fetch.
     */
    orderBy?: ConsultationSessionOrderByWithRelationInput | ConsultationSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConsultationSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConsultationSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConsultationSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ConsultationSessions
    **/
    _count?: true | ConsultationSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ConsultationSessionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ConsultationSessionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConsultationSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConsultationSessionMaxAggregateInputType
  }

  export type GetConsultationSessionAggregateType<T extends ConsultationSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateConsultationSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConsultationSession[P]>
      : GetScalarType<T[P], AggregateConsultationSession[P]>
  }




  export type ConsultationSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConsultationSessionWhereInput
    orderBy?: ConsultationSessionOrderByWithAggregationInput | ConsultationSessionOrderByWithAggregationInput[]
    by: ConsultationSessionScalarFieldEnum[] | ConsultationSessionScalarFieldEnum
    having?: ConsultationSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConsultationSessionCountAggregateInputType | true
    _avg?: ConsultationSessionAvgAggregateInputType
    _sum?: ConsultationSessionSumAggregateInputType
    _min?: ConsultationSessionMinAggregateInputType
    _max?: ConsultationSessionMaxAggregateInputType
  }

  export type ConsultationSessionGroupByOutputType = {
    id: string
    studentId: string
    consultantId: string
    scheduledStart: Date
    scheduledEnd: Date
    actualStart: Date | null
    actualEnd: Date | null
    status: $Enums.SessionStatus
    sessionType: string
    studentVerifiedAt: Date | null
    consultantVerifiedAt: Date | null
    studentNotes: string | null
    consultantNotes: string | null
    sessionRating: number | null
    technicalIssuesReported: boolean
    makeupSessionFor: string | null
    createdAt: Date
    updatedAt: Date
    _count: ConsultationSessionCountAggregateOutputType | null
    _avg: ConsultationSessionAvgAggregateOutputType | null
    _sum: ConsultationSessionSumAggregateOutputType | null
    _min: ConsultationSessionMinAggregateOutputType | null
    _max: ConsultationSessionMaxAggregateOutputType | null
  }

  type GetConsultationSessionGroupByPayload<T extends ConsultationSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConsultationSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConsultationSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConsultationSessionGroupByOutputType[P]>
            : GetScalarType<T[P], ConsultationSessionGroupByOutputType[P]>
        }
      >
    >


  export type ConsultationSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    consultantId?: boolean
    scheduledStart?: boolean
    scheduledEnd?: boolean
    actualStart?: boolean
    actualEnd?: boolean
    status?: boolean
    sessionType?: boolean
    studentVerifiedAt?: boolean
    consultantVerifiedAt?: boolean
    studentNotes?: boolean
    consultantNotes?: boolean
    sessionRating?: boolean
    technicalIssuesReported?: boolean
    makeupSessionFor?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    consultant?: boolean | ConsultantDefaultArgs<ExtArgs>
    videoSession?: boolean | ConsultationSession$videoSessionArgs<ExtArgs>
  }, ExtArgs["result"]["consultationSession"]>

  export type ConsultationSessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    consultantId?: boolean
    scheduledStart?: boolean
    scheduledEnd?: boolean
    actualStart?: boolean
    actualEnd?: boolean
    status?: boolean
    sessionType?: boolean
    studentVerifiedAt?: boolean
    consultantVerifiedAt?: boolean
    studentNotes?: boolean
    consultantNotes?: boolean
    sessionRating?: boolean
    technicalIssuesReported?: boolean
    makeupSessionFor?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    consultant?: boolean | ConsultantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["consultationSession"]>

  export type ConsultationSessionSelectScalar = {
    id?: boolean
    studentId?: boolean
    consultantId?: boolean
    scheduledStart?: boolean
    scheduledEnd?: boolean
    actualStart?: boolean
    actualEnd?: boolean
    status?: boolean
    sessionType?: boolean
    studentVerifiedAt?: boolean
    consultantVerifiedAt?: boolean
    studentNotes?: boolean
    consultantNotes?: boolean
    sessionRating?: boolean
    technicalIssuesReported?: boolean
    makeupSessionFor?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ConsultationSessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    consultant?: boolean | ConsultantDefaultArgs<ExtArgs>
    videoSession?: boolean | ConsultationSession$videoSessionArgs<ExtArgs>
  }
  export type ConsultationSessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    consultant?: boolean | ConsultantDefaultArgs<ExtArgs>
  }

  export type $ConsultationSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ConsultationSession"
    objects: {
      student: Prisma.$StudentPayload<ExtArgs>
      consultant: Prisma.$ConsultantPayload<ExtArgs>
      videoSession: Prisma.$VideoSessionPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      studentId: string
      consultantId: string
      scheduledStart: Date
      scheduledEnd: Date
      actualStart: Date | null
      actualEnd: Date | null
      status: $Enums.SessionStatus
      sessionType: string
      studentVerifiedAt: Date | null
      consultantVerifiedAt: Date | null
      studentNotes: string | null
      consultantNotes: string | null
      sessionRating: number | null
      technicalIssuesReported: boolean
      makeupSessionFor: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["consultationSession"]>
    composites: {}
  }

  type ConsultationSessionGetPayload<S extends boolean | null | undefined | ConsultationSessionDefaultArgs> = $Result.GetResult<Prisma.$ConsultationSessionPayload, S>

  type ConsultationSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ConsultationSessionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ConsultationSessionCountAggregateInputType | true
    }

  export interface ConsultationSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ConsultationSession'], meta: { name: 'ConsultationSession' } }
    /**
     * Find zero or one ConsultationSession that matches the filter.
     * @param {ConsultationSessionFindUniqueArgs} args - Arguments to find a ConsultationSession
     * @example
     * // Get one ConsultationSession
     * const consultationSession = await prisma.consultationSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConsultationSessionFindUniqueArgs>(args: SelectSubset<T, ConsultationSessionFindUniqueArgs<ExtArgs>>): Prisma__ConsultationSessionClient<$Result.GetResult<Prisma.$ConsultationSessionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ConsultationSession that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ConsultationSessionFindUniqueOrThrowArgs} args - Arguments to find a ConsultationSession
     * @example
     * // Get one ConsultationSession
     * const consultationSession = await prisma.consultationSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConsultationSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, ConsultationSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConsultationSessionClient<$Result.GetResult<Prisma.$ConsultationSessionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ConsultationSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsultationSessionFindFirstArgs} args - Arguments to find a ConsultationSession
     * @example
     * // Get one ConsultationSession
     * const consultationSession = await prisma.consultationSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConsultationSessionFindFirstArgs>(args?: SelectSubset<T, ConsultationSessionFindFirstArgs<ExtArgs>>): Prisma__ConsultationSessionClient<$Result.GetResult<Prisma.$ConsultationSessionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ConsultationSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsultationSessionFindFirstOrThrowArgs} args - Arguments to find a ConsultationSession
     * @example
     * // Get one ConsultationSession
     * const consultationSession = await prisma.consultationSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConsultationSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, ConsultationSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConsultationSessionClient<$Result.GetResult<Prisma.$ConsultationSessionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ConsultationSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsultationSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ConsultationSessions
     * const consultationSessions = await prisma.consultationSession.findMany()
     * 
     * // Get first 10 ConsultationSessions
     * const consultationSessions = await prisma.consultationSession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const consultationSessionWithIdOnly = await prisma.consultationSession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ConsultationSessionFindManyArgs>(args?: SelectSubset<T, ConsultationSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConsultationSessionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ConsultationSession.
     * @param {ConsultationSessionCreateArgs} args - Arguments to create a ConsultationSession.
     * @example
     * // Create one ConsultationSession
     * const ConsultationSession = await prisma.consultationSession.create({
     *   data: {
     *     // ... data to create a ConsultationSession
     *   }
     * })
     * 
     */
    create<T extends ConsultationSessionCreateArgs>(args: SelectSubset<T, ConsultationSessionCreateArgs<ExtArgs>>): Prisma__ConsultationSessionClient<$Result.GetResult<Prisma.$ConsultationSessionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ConsultationSessions.
     * @param {ConsultationSessionCreateManyArgs} args - Arguments to create many ConsultationSessions.
     * @example
     * // Create many ConsultationSessions
     * const consultationSession = await prisma.consultationSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConsultationSessionCreateManyArgs>(args?: SelectSubset<T, ConsultationSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ConsultationSessions and returns the data saved in the database.
     * @param {ConsultationSessionCreateManyAndReturnArgs} args - Arguments to create many ConsultationSessions.
     * @example
     * // Create many ConsultationSessions
     * const consultationSession = await prisma.consultationSession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ConsultationSessions and only return the `id`
     * const consultationSessionWithIdOnly = await prisma.consultationSession.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ConsultationSessionCreateManyAndReturnArgs>(args?: SelectSubset<T, ConsultationSessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConsultationSessionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ConsultationSession.
     * @param {ConsultationSessionDeleteArgs} args - Arguments to delete one ConsultationSession.
     * @example
     * // Delete one ConsultationSession
     * const ConsultationSession = await prisma.consultationSession.delete({
     *   where: {
     *     // ... filter to delete one ConsultationSession
     *   }
     * })
     * 
     */
    delete<T extends ConsultationSessionDeleteArgs>(args: SelectSubset<T, ConsultationSessionDeleteArgs<ExtArgs>>): Prisma__ConsultationSessionClient<$Result.GetResult<Prisma.$ConsultationSessionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ConsultationSession.
     * @param {ConsultationSessionUpdateArgs} args - Arguments to update one ConsultationSession.
     * @example
     * // Update one ConsultationSession
     * const consultationSession = await prisma.consultationSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConsultationSessionUpdateArgs>(args: SelectSubset<T, ConsultationSessionUpdateArgs<ExtArgs>>): Prisma__ConsultationSessionClient<$Result.GetResult<Prisma.$ConsultationSessionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ConsultationSessions.
     * @param {ConsultationSessionDeleteManyArgs} args - Arguments to filter ConsultationSessions to delete.
     * @example
     * // Delete a few ConsultationSessions
     * const { count } = await prisma.consultationSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConsultationSessionDeleteManyArgs>(args?: SelectSubset<T, ConsultationSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConsultationSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsultationSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ConsultationSessions
     * const consultationSession = await prisma.consultationSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConsultationSessionUpdateManyArgs>(args: SelectSubset<T, ConsultationSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ConsultationSession.
     * @param {ConsultationSessionUpsertArgs} args - Arguments to update or create a ConsultationSession.
     * @example
     * // Update or create a ConsultationSession
     * const consultationSession = await prisma.consultationSession.upsert({
     *   create: {
     *     // ... data to create a ConsultationSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ConsultationSession we want to update
     *   }
     * })
     */
    upsert<T extends ConsultationSessionUpsertArgs>(args: SelectSubset<T, ConsultationSessionUpsertArgs<ExtArgs>>): Prisma__ConsultationSessionClient<$Result.GetResult<Prisma.$ConsultationSessionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ConsultationSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsultationSessionCountArgs} args - Arguments to filter ConsultationSessions to count.
     * @example
     * // Count the number of ConsultationSessions
     * const count = await prisma.consultationSession.count({
     *   where: {
     *     // ... the filter for the ConsultationSessions we want to count
     *   }
     * })
    **/
    count<T extends ConsultationSessionCountArgs>(
      args?: Subset<T, ConsultationSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConsultationSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ConsultationSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsultationSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConsultationSessionAggregateArgs>(args: Subset<T, ConsultationSessionAggregateArgs>): Prisma.PrismaPromise<GetConsultationSessionAggregateType<T>>

    /**
     * Group by ConsultationSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsultationSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConsultationSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConsultationSessionGroupByArgs['orderBy'] }
        : { orderBy?: ConsultationSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConsultationSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConsultationSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ConsultationSession model
   */
  readonly fields: ConsultationSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ConsultationSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConsultationSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    consultant<T extends ConsultantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ConsultantDefaultArgs<ExtArgs>>): Prisma__ConsultantClient<$Result.GetResult<Prisma.$ConsultantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    videoSession<T extends ConsultationSession$videoSessionArgs<ExtArgs> = {}>(args?: Subset<T, ConsultationSession$videoSessionArgs<ExtArgs>>): Prisma__VideoSessionClient<$Result.GetResult<Prisma.$VideoSessionPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ConsultationSession model
   */ 
  interface ConsultationSessionFieldRefs {
    readonly id: FieldRef<"ConsultationSession", 'String'>
    readonly studentId: FieldRef<"ConsultationSession", 'String'>
    readonly consultantId: FieldRef<"ConsultationSession", 'String'>
    readonly scheduledStart: FieldRef<"ConsultationSession", 'DateTime'>
    readonly scheduledEnd: FieldRef<"ConsultationSession", 'DateTime'>
    readonly actualStart: FieldRef<"ConsultationSession", 'DateTime'>
    readonly actualEnd: FieldRef<"ConsultationSession", 'DateTime'>
    readonly status: FieldRef<"ConsultationSession", 'SessionStatus'>
    readonly sessionType: FieldRef<"ConsultationSession", 'String'>
    readonly studentVerifiedAt: FieldRef<"ConsultationSession", 'DateTime'>
    readonly consultantVerifiedAt: FieldRef<"ConsultationSession", 'DateTime'>
    readonly studentNotes: FieldRef<"ConsultationSession", 'String'>
    readonly consultantNotes: FieldRef<"ConsultationSession", 'String'>
    readonly sessionRating: FieldRef<"ConsultationSession", 'Int'>
    readonly technicalIssuesReported: FieldRef<"ConsultationSession", 'Boolean'>
    readonly makeupSessionFor: FieldRef<"ConsultationSession", 'String'>
    readonly createdAt: FieldRef<"ConsultationSession", 'DateTime'>
    readonly updatedAt: FieldRef<"ConsultationSession", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ConsultationSession findUnique
   */
  export type ConsultationSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsultationSession
     */
    select?: ConsultationSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsultationSessionInclude<ExtArgs> | null
    /**
     * Filter, which ConsultationSession to fetch.
     */
    where: ConsultationSessionWhereUniqueInput
  }

  /**
   * ConsultationSession findUniqueOrThrow
   */
  export type ConsultationSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsultationSession
     */
    select?: ConsultationSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsultationSessionInclude<ExtArgs> | null
    /**
     * Filter, which ConsultationSession to fetch.
     */
    where: ConsultationSessionWhereUniqueInput
  }

  /**
   * ConsultationSession findFirst
   */
  export type ConsultationSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsultationSession
     */
    select?: ConsultationSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsultationSessionInclude<ExtArgs> | null
    /**
     * Filter, which ConsultationSession to fetch.
     */
    where?: ConsultationSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConsultationSessions to fetch.
     */
    orderBy?: ConsultationSessionOrderByWithRelationInput | ConsultationSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConsultationSessions.
     */
    cursor?: ConsultationSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConsultationSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConsultationSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConsultationSessions.
     */
    distinct?: ConsultationSessionScalarFieldEnum | ConsultationSessionScalarFieldEnum[]
  }

  /**
   * ConsultationSession findFirstOrThrow
   */
  export type ConsultationSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsultationSession
     */
    select?: ConsultationSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsultationSessionInclude<ExtArgs> | null
    /**
     * Filter, which ConsultationSession to fetch.
     */
    where?: ConsultationSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConsultationSessions to fetch.
     */
    orderBy?: ConsultationSessionOrderByWithRelationInput | ConsultationSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConsultationSessions.
     */
    cursor?: ConsultationSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConsultationSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConsultationSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConsultationSessions.
     */
    distinct?: ConsultationSessionScalarFieldEnum | ConsultationSessionScalarFieldEnum[]
  }

  /**
   * ConsultationSession findMany
   */
  export type ConsultationSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsultationSession
     */
    select?: ConsultationSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsultationSessionInclude<ExtArgs> | null
    /**
     * Filter, which ConsultationSessions to fetch.
     */
    where?: ConsultationSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConsultationSessions to fetch.
     */
    orderBy?: ConsultationSessionOrderByWithRelationInput | ConsultationSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ConsultationSessions.
     */
    cursor?: ConsultationSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConsultationSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConsultationSessions.
     */
    skip?: number
    distinct?: ConsultationSessionScalarFieldEnum | ConsultationSessionScalarFieldEnum[]
  }

  /**
   * ConsultationSession create
   */
  export type ConsultationSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsultationSession
     */
    select?: ConsultationSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsultationSessionInclude<ExtArgs> | null
    /**
     * The data needed to create a ConsultationSession.
     */
    data: XOR<ConsultationSessionCreateInput, ConsultationSessionUncheckedCreateInput>
  }

  /**
   * ConsultationSession createMany
   */
  export type ConsultationSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ConsultationSessions.
     */
    data: ConsultationSessionCreateManyInput | ConsultationSessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ConsultationSession createManyAndReturn
   */
  export type ConsultationSessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsultationSession
     */
    select?: ConsultationSessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ConsultationSessions.
     */
    data: ConsultationSessionCreateManyInput | ConsultationSessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsultationSessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ConsultationSession update
   */
  export type ConsultationSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsultationSession
     */
    select?: ConsultationSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsultationSessionInclude<ExtArgs> | null
    /**
     * The data needed to update a ConsultationSession.
     */
    data: XOR<ConsultationSessionUpdateInput, ConsultationSessionUncheckedUpdateInput>
    /**
     * Choose, which ConsultationSession to update.
     */
    where: ConsultationSessionWhereUniqueInput
  }

  /**
   * ConsultationSession updateMany
   */
  export type ConsultationSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ConsultationSessions.
     */
    data: XOR<ConsultationSessionUpdateManyMutationInput, ConsultationSessionUncheckedUpdateManyInput>
    /**
     * Filter which ConsultationSessions to update
     */
    where?: ConsultationSessionWhereInput
  }

  /**
   * ConsultationSession upsert
   */
  export type ConsultationSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsultationSession
     */
    select?: ConsultationSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsultationSessionInclude<ExtArgs> | null
    /**
     * The filter to search for the ConsultationSession to update in case it exists.
     */
    where: ConsultationSessionWhereUniqueInput
    /**
     * In case the ConsultationSession found by the `where` argument doesn't exist, create a new ConsultationSession with this data.
     */
    create: XOR<ConsultationSessionCreateInput, ConsultationSessionUncheckedCreateInput>
    /**
     * In case the ConsultationSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConsultationSessionUpdateInput, ConsultationSessionUncheckedUpdateInput>
  }

  /**
   * ConsultationSession delete
   */
  export type ConsultationSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsultationSession
     */
    select?: ConsultationSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsultationSessionInclude<ExtArgs> | null
    /**
     * Filter which ConsultationSession to delete.
     */
    where: ConsultationSessionWhereUniqueInput
  }

  /**
   * ConsultationSession deleteMany
   */
  export type ConsultationSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConsultationSessions to delete
     */
    where?: ConsultationSessionWhereInput
  }

  /**
   * ConsultationSession.videoSession
   */
  export type ConsultationSession$videoSessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoSession
     */
    select?: VideoSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoSessionInclude<ExtArgs> | null
    where?: VideoSessionWhereInput
  }

  /**
   * ConsultationSession without action
   */
  export type ConsultationSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsultationSession
     */
    select?: ConsultationSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsultationSessionInclude<ExtArgs> | null
  }


  /**
   * Model VideoSession
   */

  export type AggregateVideoSession = {
    _count: VideoSessionCountAggregateOutputType | null
    _avg: VideoSessionAvgAggregateOutputType | null
    _sum: VideoSessionSumAggregateOutputType | null
    _min: VideoSessionMinAggregateOutputType | null
    _max: VideoSessionMaxAggregateOutputType | null
  }

  export type VideoSessionAvgAggregateOutputType = {
    recordingDurationSeconds: number | null
    connectionQualityAvg: number | null
    bandwidthUsageMb: number | null
  }

  export type VideoSessionSumAggregateOutputType = {
    recordingDurationSeconds: number | null
    connectionQualityAvg: number | null
    bandwidthUsageMb: number | null
  }

  export type VideoSessionMinAggregateOutputType = {
    id: string | null
    consultationSessionId: string | null
    roomId: string | null
    recordingEnabled: boolean | null
    recordingUrl: string | null
    recordingDurationSeconds: number | null
    videoQuality: string | null
    connectionQualityAvg: number | null
    bandwidthUsageMb: number | null
    createdAt: Date | null
  }

  export type VideoSessionMaxAggregateOutputType = {
    id: string | null
    consultationSessionId: string | null
    roomId: string | null
    recordingEnabled: boolean | null
    recordingUrl: string | null
    recordingDurationSeconds: number | null
    videoQuality: string | null
    connectionQualityAvg: number | null
    bandwidthUsageMb: number | null
    createdAt: Date | null
  }

  export type VideoSessionCountAggregateOutputType = {
    id: number
    consultationSessionId: number
    roomId: number
    recordingEnabled: number
    recordingUrl: number
    recordingDurationSeconds: number
    videoQuality: number
    connectionQualityAvg: number
    bandwidthUsageMb: number
    technicalIssues: number
    sessionMetadata: number
    createdAt: number
    _all: number
  }


  export type VideoSessionAvgAggregateInputType = {
    recordingDurationSeconds?: true
    connectionQualityAvg?: true
    bandwidthUsageMb?: true
  }

  export type VideoSessionSumAggregateInputType = {
    recordingDurationSeconds?: true
    connectionQualityAvg?: true
    bandwidthUsageMb?: true
  }

  export type VideoSessionMinAggregateInputType = {
    id?: true
    consultationSessionId?: true
    roomId?: true
    recordingEnabled?: true
    recordingUrl?: true
    recordingDurationSeconds?: true
    videoQuality?: true
    connectionQualityAvg?: true
    bandwidthUsageMb?: true
    createdAt?: true
  }

  export type VideoSessionMaxAggregateInputType = {
    id?: true
    consultationSessionId?: true
    roomId?: true
    recordingEnabled?: true
    recordingUrl?: true
    recordingDurationSeconds?: true
    videoQuality?: true
    connectionQualityAvg?: true
    bandwidthUsageMb?: true
    createdAt?: true
  }

  export type VideoSessionCountAggregateInputType = {
    id?: true
    consultationSessionId?: true
    roomId?: true
    recordingEnabled?: true
    recordingUrl?: true
    recordingDurationSeconds?: true
    videoQuality?: true
    connectionQualityAvg?: true
    bandwidthUsageMb?: true
    technicalIssues?: true
    sessionMetadata?: true
    createdAt?: true
    _all?: true
  }

  export type VideoSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VideoSession to aggregate.
     */
    where?: VideoSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VideoSessions to fetch.
     */
    orderBy?: VideoSessionOrderByWithRelationInput | VideoSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VideoSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VideoSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VideoSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VideoSessions
    **/
    _count?: true | VideoSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VideoSessionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VideoSessionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VideoSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VideoSessionMaxAggregateInputType
  }

  export type GetVideoSessionAggregateType<T extends VideoSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateVideoSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVideoSession[P]>
      : GetScalarType<T[P], AggregateVideoSession[P]>
  }




  export type VideoSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VideoSessionWhereInput
    orderBy?: VideoSessionOrderByWithAggregationInput | VideoSessionOrderByWithAggregationInput[]
    by: VideoSessionScalarFieldEnum[] | VideoSessionScalarFieldEnum
    having?: VideoSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VideoSessionCountAggregateInputType | true
    _avg?: VideoSessionAvgAggregateInputType
    _sum?: VideoSessionSumAggregateInputType
    _min?: VideoSessionMinAggregateInputType
    _max?: VideoSessionMaxAggregateInputType
  }

  export type VideoSessionGroupByOutputType = {
    id: string
    consultationSessionId: string
    roomId: string
    recordingEnabled: boolean
    recordingUrl: string | null
    recordingDurationSeconds: number | null
    videoQuality: string
    connectionQualityAvg: number | null
    bandwidthUsageMb: number | null
    technicalIssues: JsonValue | null
    sessionMetadata: JsonValue | null
    createdAt: Date
    _count: VideoSessionCountAggregateOutputType | null
    _avg: VideoSessionAvgAggregateOutputType | null
    _sum: VideoSessionSumAggregateOutputType | null
    _min: VideoSessionMinAggregateOutputType | null
    _max: VideoSessionMaxAggregateOutputType | null
  }

  type GetVideoSessionGroupByPayload<T extends VideoSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VideoSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VideoSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VideoSessionGroupByOutputType[P]>
            : GetScalarType<T[P], VideoSessionGroupByOutputType[P]>
        }
      >
    >


  export type VideoSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    consultationSessionId?: boolean
    roomId?: boolean
    recordingEnabled?: boolean
    recordingUrl?: boolean
    recordingDurationSeconds?: boolean
    videoQuality?: boolean
    connectionQualityAvg?: boolean
    bandwidthUsageMb?: boolean
    technicalIssues?: boolean
    sessionMetadata?: boolean
    createdAt?: boolean
    consultationSession?: boolean | ConsultationSessionDefaultArgs<ExtArgs>
    videoParticipants?: boolean | VideoSession$videoParticipantsArgs<ExtArgs>
    _count?: boolean | VideoSessionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["videoSession"]>

  export type VideoSessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    consultationSessionId?: boolean
    roomId?: boolean
    recordingEnabled?: boolean
    recordingUrl?: boolean
    recordingDurationSeconds?: boolean
    videoQuality?: boolean
    connectionQualityAvg?: boolean
    bandwidthUsageMb?: boolean
    technicalIssues?: boolean
    sessionMetadata?: boolean
    createdAt?: boolean
    consultationSession?: boolean | ConsultationSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["videoSession"]>

  export type VideoSessionSelectScalar = {
    id?: boolean
    consultationSessionId?: boolean
    roomId?: boolean
    recordingEnabled?: boolean
    recordingUrl?: boolean
    recordingDurationSeconds?: boolean
    videoQuality?: boolean
    connectionQualityAvg?: boolean
    bandwidthUsageMb?: boolean
    technicalIssues?: boolean
    sessionMetadata?: boolean
    createdAt?: boolean
  }

  export type VideoSessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    consultationSession?: boolean | ConsultationSessionDefaultArgs<ExtArgs>
    videoParticipants?: boolean | VideoSession$videoParticipantsArgs<ExtArgs>
    _count?: boolean | VideoSessionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type VideoSessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    consultationSession?: boolean | ConsultationSessionDefaultArgs<ExtArgs>
  }

  export type $VideoSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VideoSession"
    objects: {
      consultationSession: Prisma.$ConsultationSessionPayload<ExtArgs>
      videoParticipants: Prisma.$VideoParticipantPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      consultationSessionId: string
      roomId: string
      recordingEnabled: boolean
      recordingUrl: string | null
      recordingDurationSeconds: number | null
      videoQuality: string
      connectionQualityAvg: number | null
      bandwidthUsageMb: number | null
      technicalIssues: Prisma.JsonValue | null
      sessionMetadata: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["videoSession"]>
    composites: {}
  }

  type VideoSessionGetPayload<S extends boolean | null | undefined | VideoSessionDefaultArgs> = $Result.GetResult<Prisma.$VideoSessionPayload, S>

  type VideoSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<VideoSessionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: VideoSessionCountAggregateInputType | true
    }

  export interface VideoSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VideoSession'], meta: { name: 'VideoSession' } }
    /**
     * Find zero or one VideoSession that matches the filter.
     * @param {VideoSessionFindUniqueArgs} args - Arguments to find a VideoSession
     * @example
     * // Get one VideoSession
     * const videoSession = await prisma.videoSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VideoSessionFindUniqueArgs>(args: SelectSubset<T, VideoSessionFindUniqueArgs<ExtArgs>>): Prisma__VideoSessionClient<$Result.GetResult<Prisma.$VideoSessionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one VideoSession that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {VideoSessionFindUniqueOrThrowArgs} args - Arguments to find a VideoSession
     * @example
     * // Get one VideoSession
     * const videoSession = await prisma.videoSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VideoSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, VideoSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VideoSessionClient<$Result.GetResult<Prisma.$VideoSessionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first VideoSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoSessionFindFirstArgs} args - Arguments to find a VideoSession
     * @example
     * // Get one VideoSession
     * const videoSession = await prisma.videoSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VideoSessionFindFirstArgs>(args?: SelectSubset<T, VideoSessionFindFirstArgs<ExtArgs>>): Prisma__VideoSessionClient<$Result.GetResult<Prisma.$VideoSessionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first VideoSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoSessionFindFirstOrThrowArgs} args - Arguments to find a VideoSession
     * @example
     * // Get one VideoSession
     * const videoSession = await prisma.videoSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VideoSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, VideoSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__VideoSessionClient<$Result.GetResult<Prisma.$VideoSessionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more VideoSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VideoSessions
     * const videoSessions = await prisma.videoSession.findMany()
     * 
     * // Get first 10 VideoSessions
     * const videoSessions = await prisma.videoSession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const videoSessionWithIdOnly = await prisma.videoSession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VideoSessionFindManyArgs>(args?: SelectSubset<T, VideoSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VideoSessionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a VideoSession.
     * @param {VideoSessionCreateArgs} args - Arguments to create a VideoSession.
     * @example
     * // Create one VideoSession
     * const VideoSession = await prisma.videoSession.create({
     *   data: {
     *     // ... data to create a VideoSession
     *   }
     * })
     * 
     */
    create<T extends VideoSessionCreateArgs>(args: SelectSubset<T, VideoSessionCreateArgs<ExtArgs>>): Prisma__VideoSessionClient<$Result.GetResult<Prisma.$VideoSessionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many VideoSessions.
     * @param {VideoSessionCreateManyArgs} args - Arguments to create many VideoSessions.
     * @example
     * // Create many VideoSessions
     * const videoSession = await prisma.videoSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VideoSessionCreateManyArgs>(args?: SelectSubset<T, VideoSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VideoSessions and returns the data saved in the database.
     * @param {VideoSessionCreateManyAndReturnArgs} args - Arguments to create many VideoSessions.
     * @example
     * // Create many VideoSessions
     * const videoSession = await prisma.videoSession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VideoSessions and only return the `id`
     * const videoSessionWithIdOnly = await prisma.videoSession.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VideoSessionCreateManyAndReturnArgs>(args?: SelectSubset<T, VideoSessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VideoSessionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a VideoSession.
     * @param {VideoSessionDeleteArgs} args - Arguments to delete one VideoSession.
     * @example
     * // Delete one VideoSession
     * const VideoSession = await prisma.videoSession.delete({
     *   where: {
     *     // ... filter to delete one VideoSession
     *   }
     * })
     * 
     */
    delete<T extends VideoSessionDeleteArgs>(args: SelectSubset<T, VideoSessionDeleteArgs<ExtArgs>>): Prisma__VideoSessionClient<$Result.GetResult<Prisma.$VideoSessionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one VideoSession.
     * @param {VideoSessionUpdateArgs} args - Arguments to update one VideoSession.
     * @example
     * // Update one VideoSession
     * const videoSession = await prisma.videoSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VideoSessionUpdateArgs>(args: SelectSubset<T, VideoSessionUpdateArgs<ExtArgs>>): Prisma__VideoSessionClient<$Result.GetResult<Prisma.$VideoSessionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more VideoSessions.
     * @param {VideoSessionDeleteManyArgs} args - Arguments to filter VideoSessions to delete.
     * @example
     * // Delete a few VideoSessions
     * const { count } = await prisma.videoSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VideoSessionDeleteManyArgs>(args?: SelectSubset<T, VideoSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VideoSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VideoSessions
     * const videoSession = await prisma.videoSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VideoSessionUpdateManyArgs>(args: SelectSubset<T, VideoSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one VideoSession.
     * @param {VideoSessionUpsertArgs} args - Arguments to update or create a VideoSession.
     * @example
     * // Update or create a VideoSession
     * const videoSession = await prisma.videoSession.upsert({
     *   create: {
     *     // ... data to create a VideoSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VideoSession we want to update
     *   }
     * })
     */
    upsert<T extends VideoSessionUpsertArgs>(args: SelectSubset<T, VideoSessionUpsertArgs<ExtArgs>>): Prisma__VideoSessionClient<$Result.GetResult<Prisma.$VideoSessionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of VideoSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoSessionCountArgs} args - Arguments to filter VideoSessions to count.
     * @example
     * // Count the number of VideoSessions
     * const count = await prisma.videoSession.count({
     *   where: {
     *     // ... the filter for the VideoSessions we want to count
     *   }
     * })
    **/
    count<T extends VideoSessionCountArgs>(
      args?: Subset<T, VideoSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VideoSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VideoSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VideoSessionAggregateArgs>(args: Subset<T, VideoSessionAggregateArgs>): Prisma.PrismaPromise<GetVideoSessionAggregateType<T>>

    /**
     * Group by VideoSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VideoSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VideoSessionGroupByArgs['orderBy'] }
        : { orderBy?: VideoSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VideoSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVideoSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VideoSession model
   */
  readonly fields: VideoSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VideoSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VideoSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    consultationSession<T extends ConsultationSessionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ConsultationSessionDefaultArgs<ExtArgs>>): Prisma__ConsultationSessionClient<$Result.GetResult<Prisma.$ConsultationSessionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    videoParticipants<T extends VideoSession$videoParticipantsArgs<ExtArgs> = {}>(args?: Subset<T, VideoSession$videoParticipantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VideoParticipantPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VideoSession model
   */ 
  interface VideoSessionFieldRefs {
    readonly id: FieldRef<"VideoSession", 'String'>
    readonly consultationSessionId: FieldRef<"VideoSession", 'String'>
    readonly roomId: FieldRef<"VideoSession", 'String'>
    readonly recordingEnabled: FieldRef<"VideoSession", 'Boolean'>
    readonly recordingUrl: FieldRef<"VideoSession", 'String'>
    readonly recordingDurationSeconds: FieldRef<"VideoSession", 'Int'>
    readonly videoQuality: FieldRef<"VideoSession", 'String'>
    readonly connectionQualityAvg: FieldRef<"VideoSession", 'Float'>
    readonly bandwidthUsageMb: FieldRef<"VideoSession", 'Float'>
    readonly technicalIssues: FieldRef<"VideoSession", 'Json'>
    readonly sessionMetadata: FieldRef<"VideoSession", 'Json'>
    readonly createdAt: FieldRef<"VideoSession", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VideoSession findUnique
   */
  export type VideoSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoSession
     */
    select?: VideoSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoSessionInclude<ExtArgs> | null
    /**
     * Filter, which VideoSession to fetch.
     */
    where: VideoSessionWhereUniqueInput
  }

  /**
   * VideoSession findUniqueOrThrow
   */
  export type VideoSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoSession
     */
    select?: VideoSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoSessionInclude<ExtArgs> | null
    /**
     * Filter, which VideoSession to fetch.
     */
    where: VideoSessionWhereUniqueInput
  }

  /**
   * VideoSession findFirst
   */
  export type VideoSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoSession
     */
    select?: VideoSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoSessionInclude<ExtArgs> | null
    /**
     * Filter, which VideoSession to fetch.
     */
    where?: VideoSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VideoSessions to fetch.
     */
    orderBy?: VideoSessionOrderByWithRelationInput | VideoSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VideoSessions.
     */
    cursor?: VideoSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VideoSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VideoSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VideoSessions.
     */
    distinct?: VideoSessionScalarFieldEnum | VideoSessionScalarFieldEnum[]
  }

  /**
   * VideoSession findFirstOrThrow
   */
  export type VideoSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoSession
     */
    select?: VideoSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoSessionInclude<ExtArgs> | null
    /**
     * Filter, which VideoSession to fetch.
     */
    where?: VideoSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VideoSessions to fetch.
     */
    orderBy?: VideoSessionOrderByWithRelationInput | VideoSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VideoSessions.
     */
    cursor?: VideoSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VideoSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VideoSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VideoSessions.
     */
    distinct?: VideoSessionScalarFieldEnum | VideoSessionScalarFieldEnum[]
  }

  /**
   * VideoSession findMany
   */
  export type VideoSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoSession
     */
    select?: VideoSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoSessionInclude<ExtArgs> | null
    /**
     * Filter, which VideoSessions to fetch.
     */
    where?: VideoSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VideoSessions to fetch.
     */
    orderBy?: VideoSessionOrderByWithRelationInput | VideoSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VideoSessions.
     */
    cursor?: VideoSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VideoSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VideoSessions.
     */
    skip?: number
    distinct?: VideoSessionScalarFieldEnum | VideoSessionScalarFieldEnum[]
  }

  /**
   * VideoSession create
   */
  export type VideoSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoSession
     */
    select?: VideoSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoSessionInclude<ExtArgs> | null
    /**
     * The data needed to create a VideoSession.
     */
    data: XOR<VideoSessionCreateInput, VideoSessionUncheckedCreateInput>
  }

  /**
   * VideoSession createMany
   */
  export type VideoSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VideoSessions.
     */
    data: VideoSessionCreateManyInput | VideoSessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VideoSession createManyAndReturn
   */
  export type VideoSessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoSession
     */
    select?: VideoSessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many VideoSessions.
     */
    data: VideoSessionCreateManyInput | VideoSessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoSessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VideoSession update
   */
  export type VideoSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoSession
     */
    select?: VideoSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoSessionInclude<ExtArgs> | null
    /**
     * The data needed to update a VideoSession.
     */
    data: XOR<VideoSessionUpdateInput, VideoSessionUncheckedUpdateInput>
    /**
     * Choose, which VideoSession to update.
     */
    where: VideoSessionWhereUniqueInput
  }

  /**
   * VideoSession updateMany
   */
  export type VideoSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VideoSessions.
     */
    data: XOR<VideoSessionUpdateManyMutationInput, VideoSessionUncheckedUpdateManyInput>
    /**
     * Filter which VideoSessions to update
     */
    where?: VideoSessionWhereInput
  }

  /**
   * VideoSession upsert
   */
  export type VideoSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoSession
     */
    select?: VideoSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoSessionInclude<ExtArgs> | null
    /**
     * The filter to search for the VideoSession to update in case it exists.
     */
    where: VideoSessionWhereUniqueInput
    /**
     * In case the VideoSession found by the `where` argument doesn't exist, create a new VideoSession with this data.
     */
    create: XOR<VideoSessionCreateInput, VideoSessionUncheckedCreateInput>
    /**
     * In case the VideoSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VideoSessionUpdateInput, VideoSessionUncheckedUpdateInput>
  }

  /**
   * VideoSession delete
   */
  export type VideoSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoSession
     */
    select?: VideoSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoSessionInclude<ExtArgs> | null
    /**
     * Filter which VideoSession to delete.
     */
    where: VideoSessionWhereUniqueInput
  }

  /**
   * VideoSession deleteMany
   */
  export type VideoSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VideoSessions to delete
     */
    where?: VideoSessionWhereInput
  }

  /**
   * VideoSession.videoParticipants
   */
  export type VideoSession$videoParticipantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoParticipant
     */
    select?: VideoParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoParticipantInclude<ExtArgs> | null
    where?: VideoParticipantWhereInput
    orderBy?: VideoParticipantOrderByWithRelationInput | VideoParticipantOrderByWithRelationInput[]
    cursor?: VideoParticipantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VideoParticipantScalarFieldEnum | VideoParticipantScalarFieldEnum[]
  }

  /**
   * VideoSession without action
   */
  export type VideoSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoSession
     */
    select?: VideoSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoSessionInclude<ExtArgs> | null
  }


  /**
   * Model VideoParticipant
   */

  export type AggregateVideoParticipant = {
    _count: VideoParticipantCountAggregateOutputType | null
    _avg: VideoParticipantAvgAggregateOutputType | null
    _sum: VideoParticipantSumAggregateOutputType | null
    _min: VideoParticipantMinAggregateOutputType | null
    _max: VideoParticipantMaxAggregateOutputType | null
  }

  export type VideoParticipantAvgAggregateOutputType = {
    totalDurationSeconds: number | null
    audioQualityAvg: number | null
    videoQualityAvg: number | null
    screenShareDurationSeconds: number | null
    chatMessagesCount: number | null
    connectionInterruptions: number | null
  }

  export type VideoParticipantSumAggregateOutputType = {
    totalDurationSeconds: number | null
    audioQualityAvg: number | null
    videoQualityAvg: number | null
    screenShareDurationSeconds: number | null
    chatMessagesCount: number | null
    connectionInterruptions: number | null
  }

  export type VideoParticipantMinAggregateOutputType = {
    id: string | null
    videoSessionId: string | null
    userId: string | null
    userType: $Enums.UserType | null
    joinTime: Date | null
    leaveTime: Date | null
    totalDurationSeconds: number | null
    audioQualityAvg: number | null
    videoQualityAvg: number | null
    screenShareDurationSeconds: number | null
    chatMessagesCount: number | null
    connectionInterruptions: number | null
    createdAt: Date | null
  }

  export type VideoParticipantMaxAggregateOutputType = {
    id: string | null
    videoSessionId: string | null
    userId: string | null
    userType: $Enums.UserType | null
    joinTime: Date | null
    leaveTime: Date | null
    totalDurationSeconds: number | null
    audioQualityAvg: number | null
    videoQualityAvg: number | null
    screenShareDurationSeconds: number | null
    chatMessagesCount: number | null
    connectionInterruptions: number | null
    createdAt: Date | null
  }

  export type VideoParticipantCountAggregateOutputType = {
    id: number
    videoSessionId: number
    userId: number
    userType: number
    joinTime: number
    leaveTime: number
    totalDurationSeconds: number
    audioQualityAvg: number
    videoQualityAvg: number
    screenShareDurationSeconds: number
    chatMessagesCount: number
    connectionInterruptions: number
    createdAt: number
    _all: number
  }


  export type VideoParticipantAvgAggregateInputType = {
    totalDurationSeconds?: true
    audioQualityAvg?: true
    videoQualityAvg?: true
    screenShareDurationSeconds?: true
    chatMessagesCount?: true
    connectionInterruptions?: true
  }

  export type VideoParticipantSumAggregateInputType = {
    totalDurationSeconds?: true
    audioQualityAvg?: true
    videoQualityAvg?: true
    screenShareDurationSeconds?: true
    chatMessagesCount?: true
    connectionInterruptions?: true
  }

  export type VideoParticipantMinAggregateInputType = {
    id?: true
    videoSessionId?: true
    userId?: true
    userType?: true
    joinTime?: true
    leaveTime?: true
    totalDurationSeconds?: true
    audioQualityAvg?: true
    videoQualityAvg?: true
    screenShareDurationSeconds?: true
    chatMessagesCount?: true
    connectionInterruptions?: true
    createdAt?: true
  }

  export type VideoParticipantMaxAggregateInputType = {
    id?: true
    videoSessionId?: true
    userId?: true
    userType?: true
    joinTime?: true
    leaveTime?: true
    totalDurationSeconds?: true
    audioQualityAvg?: true
    videoQualityAvg?: true
    screenShareDurationSeconds?: true
    chatMessagesCount?: true
    connectionInterruptions?: true
    createdAt?: true
  }

  export type VideoParticipantCountAggregateInputType = {
    id?: true
    videoSessionId?: true
    userId?: true
    userType?: true
    joinTime?: true
    leaveTime?: true
    totalDurationSeconds?: true
    audioQualityAvg?: true
    videoQualityAvg?: true
    screenShareDurationSeconds?: true
    chatMessagesCount?: true
    connectionInterruptions?: true
    createdAt?: true
    _all?: true
  }

  export type VideoParticipantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VideoParticipant to aggregate.
     */
    where?: VideoParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VideoParticipants to fetch.
     */
    orderBy?: VideoParticipantOrderByWithRelationInput | VideoParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VideoParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VideoParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VideoParticipants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VideoParticipants
    **/
    _count?: true | VideoParticipantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VideoParticipantAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VideoParticipantSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VideoParticipantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VideoParticipantMaxAggregateInputType
  }

  export type GetVideoParticipantAggregateType<T extends VideoParticipantAggregateArgs> = {
        [P in keyof T & keyof AggregateVideoParticipant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVideoParticipant[P]>
      : GetScalarType<T[P], AggregateVideoParticipant[P]>
  }




  export type VideoParticipantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VideoParticipantWhereInput
    orderBy?: VideoParticipantOrderByWithAggregationInput | VideoParticipantOrderByWithAggregationInput[]
    by: VideoParticipantScalarFieldEnum[] | VideoParticipantScalarFieldEnum
    having?: VideoParticipantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VideoParticipantCountAggregateInputType | true
    _avg?: VideoParticipantAvgAggregateInputType
    _sum?: VideoParticipantSumAggregateInputType
    _min?: VideoParticipantMinAggregateInputType
    _max?: VideoParticipantMaxAggregateInputType
  }

  export type VideoParticipantGroupByOutputType = {
    id: string
    videoSessionId: string
    userId: string
    userType: $Enums.UserType
    joinTime: Date
    leaveTime: Date | null
    totalDurationSeconds: number | null
    audioQualityAvg: number | null
    videoQualityAvg: number | null
    screenShareDurationSeconds: number
    chatMessagesCount: number
    connectionInterruptions: number
    createdAt: Date
    _count: VideoParticipantCountAggregateOutputType | null
    _avg: VideoParticipantAvgAggregateOutputType | null
    _sum: VideoParticipantSumAggregateOutputType | null
    _min: VideoParticipantMinAggregateOutputType | null
    _max: VideoParticipantMaxAggregateOutputType | null
  }

  type GetVideoParticipantGroupByPayload<T extends VideoParticipantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VideoParticipantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VideoParticipantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VideoParticipantGroupByOutputType[P]>
            : GetScalarType<T[P], VideoParticipantGroupByOutputType[P]>
        }
      >
    >


  export type VideoParticipantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    videoSessionId?: boolean
    userId?: boolean
    userType?: boolean
    joinTime?: boolean
    leaveTime?: boolean
    totalDurationSeconds?: boolean
    audioQualityAvg?: boolean
    videoQualityAvg?: boolean
    screenShareDurationSeconds?: boolean
    chatMessagesCount?: boolean
    connectionInterruptions?: boolean
    createdAt?: boolean
    videoSession?: boolean | VideoSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["videoParticipant"]>

  export type VideoParticipantSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    videoSessionId?: boolean
    userId?: boolean
    userType?: boolean
    joinTime?: boolean
    leaveTime?: boolean
    totalDurationSeconds?: boolean
    audioQualityAvg?: boolean
    videoQualityAvg?: boolean
    screenShareDurationSeconds?: boolean
    chatMessagesCount?: boolean
    connectionInterruptions?: boolean
    createdAt?: boolean
    videoSession?: boolean | VideoSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["videoParticipant"]>

  export type VideoParticipantSelectScalar = {
    id?: boolean
    videoSessionId?: boolean
    userId?: boolean
    userType?: boolean
    joinTime?: boolean
    leaveTime?: boolean
    totalDurationSeconds?: boolean
    audioQualityAvg?: boolean
    videoQualityAvg?: boolean
    screenShareDurationSeconds?: boolean
    chatMessagesCount?: boolean
    connectionInterruptions?: boolean
    createdAt?: boolean
  }

  export type VideoParticipantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    videoSession?: boolean | VideoSessionDefaultArgs<ExtArgs>
  }
  export type VideoParticipantIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    videoSession?: boolean | VideoSessionDefaultArgs<ExtArgs>
  }

  export type $VideoParticipantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VideoParticipant"
    objects: {
      videoSession: Prisma.$VideoSessionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      videoSessionId: string
      userId: string
      userType: $Enums.UserType
      joinTime: Date
      leaveTime: Date | null
      totalDurationSeconds: number | null
      audioQualityAvg: number | null
      videoQualityAvg: number | null
      screenShareDurationSeconds: number
      chatMessagesCount: number
      connectionInterruptions: number
      createdAt: Date
    }, ExtArgs["result"]["videoParticipant"]>
    composites: {}
  }

  type VideoParticipantGetPayload<S extends boolean | null | undefined | VideoParticipantDefaultArgs> = $Result.GetResult<Prisma.$VideoParticipantPayload, S>

  type VideoParticipantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<VideoParticipantFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: VideoParticipantCountAggregateInputType | true
    }

  export interface VideoParticipantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VideoParticipant'], meta: { name: 'VideoParticipant' } }
    /**
     * Find zero or one VideoParticipant that matches the filter.
     * @param {VideoParticipantFindUniqueArgs} args - Arguments to find a VideoParticipant
     * @example
     * // Get one VideoParticipant
     * const videoParticipant = await prisma.videoParticipant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VideoParticipantFindUniqueArgs>(args: SelectSubset<T, VideoParticipantFindUniqueArgs<ExtArgs>>): Prisma__VideoParticipantClient<$Result.GetResult<Prisma.$VideoParticipantPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one VideoParticipant that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {VideoParticipantFindUniqueOrThrowArgs} args - Arguments to find a VideoParticipant
     * @example
     * // Get one VideoParticipant
     * const videoParticipant = await prisma.videoParticipant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VideoParticipantFindUniqueOrThrowArgs>(args: SelectSubset<T, VideoParticipantFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VideoParticipantClient<$Result.GetResult<Prisma.$VideoParticipantPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first VideoParticipant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoParticipantFindFirstArgs} args - Arguments to find a VideoParticipant
     * @example
     * // Get one VideoParticipant
     * const videoParticipant = await prisma.videoParticipant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VideoParticipantFindFirstArgs>(args?: SelectSubset<T, VideoParticipantFindFirstArgs<ExtArgs>>): Prisma__VideoParticipantClient<$Result.GetResult<Prisma.$VideoParticipantPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first VideoParticipant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoParticipantFindFirstOrThrowArgs} args - Arguments to find a VideoParticipant
     * @example
     * // Get one VideoParticipant
     * const videoParticipant = await prisma.videoParticipant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VideoParticipantFindFirstOrThrowArgs>(args?: SelectSubset<T, VideoParticipantFindFirstOrThrowArgs<ExtArgs>>): Prisma__VideoParticipantClient<$Result.GetResult<Prisma.$VideoParticipantPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more VideoParticipants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoParticipantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VideoParticipants
     * const videoParticipants = await prisma.videoParticipant.findMany()
     * 
     * // Get first 10 VideoParticipants
     * const videoParticipants = await prisma.videoParticipant.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const videoParticipantWithIdOnly = await prisma.videoParticipant.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VideoParticipantFindManyArgs>(args?: SelectSubset<T, VideoParticipantFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VideoParticipantPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a VideoParticipant.
     * @param {VideoParticipantCreateArgs} args - Arguments to create a VideoParticipant.
     * @example
     * // Create one VideoParticipant
     * const VideoParticipant = await prisma.videoParticipant.create({
     *   data: {
     *     // ... data to create a VideoParticipant
     *   }
     * })
     * 
     */
    create<T extends VideoParticipantCreateArgs>(args: SelectSubset<T, VideoParticipantCreateArgs<ExtArgs>>): Prisma__VideoParticipantClient<$Result.GetResult<Prisma.$VideoParticipantPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many VideoParticipants.
     * @param {VideoParticipantCreateManyArgs} args - Arguments to create many VideoParticipants.
     * @example
     * // Create many VideoParticipants
     * const videoParticipant = await prisma.videoParticipant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VideoParticipantCreateManyArgs>(args?: SelectSubset<T, VideoParticipantCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VideoParticipants and returns the data saved in the database.
     * @param {VideoParticipantCreateManyAndReturnArgs} args - Arguments to create many VideoParticipants.
     * @example
     * // Create many VideoParticipants
     * const videoParticipant = await prisma.videoParticipant.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VideoParticipants and only return the `id`
     * const videoParticipantWithIdOnly = await prisma.videoParticipant.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VideoParticipantCreateManyAndReturnArgs>(args?: SelectSubset<T, VideoParticipantCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VideoParticipantPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a VideoParticipant.
     * @param {VideoParticipantDeleteArgs} args - Arguments to delete one VideoParticipant.
     * @example
     * // Delete one VideoParticipant
     * const VideoParticipant = await prisma.videoParticipant.delete({
     *   where: {
     *     // ... filter to delete one VideoParticipant
     *   }
     * })
     * 
     */
    delete<T extends VideoParticipantDeleteArgs>(args: SelectSubset<T, VideoParticipantDeleteArgs<ExtArgs>>): Prisma__VideoParticipantClient<$Result.GetResult<Prisma.$VideoParticipantPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one VideoParticipant.
     * @param {VideoParticipantUpdateArgs} args - Arguments to update one VideoParticipant.
     * @example
     * // Update one VideoParticipant
     * const videoParticipant = await prisma.videoParticipant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VideoParticipantUpdateArgs>(args: SelectSubset<T, VideoParticipantUpdateArgs<ExtArgs>>): Prisma__VideoParticipantClient<$Result.GetResult<Prisma.$VideoParticipantPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more VideoParticipants.
     * @param {VideoParticipantDeleteManyArgs} args - Arguments to filter VideoParticipants to delete.
     * @example
     * // Delete a few VideoParticipants
     * const { count } = await prisma.videoParticipant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VideoParticipantDeleteManyArgs>(args?: SelectSubset<T, VideoParticipantDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VideoParticipants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoParticipantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VideoParticipants
     * const videoParticipant = await prisma.videoParticipant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VideoParticipantUpdateManyArgs>(args: SelectSubset<T, VideoParticipantUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one VideoParticipant.
     * @param {VideoParticipantUpsertArgs} args - Arguments to update or create a VideoParticipant.
     * @example
     * // Update or create a VideoParticipant
     * const videoParticipant = await prisma.videoParticipant.upsert({
     *   create: {
     *     // ... data to create a VideoParticipant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VideoParticipant we want to update
     *   }
     * })
     */
    upsert<T extends VideoParticipantUpsertArgs>(args: SelectSubset<T, VideoParticipantUpsertArgs<ExtArgs>>): Prisma__VideoParticipantClient<$Result.GetResult<Prisma.$VideoParticipantPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of VideoParticipants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoParticipantCountArgs} args - Arguments to filter VideoParticipants to count.
     * @example
     * // Count the number of VideoParticipants
     * const count = await prisma.videoParticipant.count({
     *   where: {
     *     // ... the filter for the VideoParticipants we want to count
     *   }
     * })
    **/
    count<T extends VideoParticipantCountArgs>(
      args?: Subset<T, VideoParticipantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VideoParticipantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VideoParticipant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoParticipantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VideoParticipantAggregateArgs>(args: Subset<T, VideoParticipantAggregateArgs>): Prisma.PrismaPromise<GetVideoParticipantAggregateType<T>>

    /**
     * Group by VideoParticipant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoParticipantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VideoParticipantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VideoParticipantGroupByArgs['orderBy'] }
        : { orderBy?: VideoParticipantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VideoParticipantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVideoParticipantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VideoParticipant model
   */
  readonly fields: VideoParticipantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VideoParticipant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VideoParticipantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    videoSession<T extends VideoSessionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VideoSessionDefaultArgs<ExtArgs>>): Prisma__VideoSessionClient<$Result.GetResult<Prisma.$VideoSessionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VideoParticipant model
   */ 
  interface VideoParticipantFieldRefs {
    readonly id: FieldRef<"VideoParticipant", 'String'>
    readonly videoSessionId: FieldRef<"VideoParticipant", 'String'>
    readonly userId: FieldRef<"VideoParticipant", 'String'>
    readonly userType: FieldRef<"VideoParticipant", 'UserType'>
    readonly joinTime: FieldRef<"VideoParticipant", 'DateTime'>
    readonly leaveTime: FieldRef<"VideoParticipant", 'DateTime'>
    readonly totalDurationSeconds: FieldRef<"VideoParticipant", 'Int'>
    readonly audioQualityAvg: FieldRef<"VideoParticipant", 'Float'>
    readonly videoQualityAvg: FieldRef<"VideoParticipant", 'Float'>
    readonly screenShareDurationSeconds: FieldRef<"VideoParticipant", 'Int'>
    readonly chatMessagesCount: FieldRef<"VideoParticipant", 'Int'>
    readonly connectionInterruptions: FieldRef<"VideoParticipant", 'Int'>
    readonly createdAt: FieldRef<"VideoParticipant", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VideoParticipant findUnique
   */
  export type VideoParticipantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoParticipant
     */
    select?: VideoParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoParticipantInclude<ExtArgs> | null
    /**
     * Filter, which VideoParticipant to fetch.
     */
    where: VideoParticipantWhereUniqueInput
  }

  /**
   * VideoParticipant findUniqueOrThrow
   */
  export type VideoParticipantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoParticipant
     */
    select?: VideoParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoParticipantInclude<ExtArgs> | null
    /**
     * Filter, which VideoParticipant to fetch.
     */
    where: VideoParticipantWhereUniqueInput
  }

  /**
   * VideoParticipant findFirst
   */
  export type VideoParticipantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoParticipant
     */
    select?: VideoParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoParticipantInclude<ExtArgs> | null
    /**
     * Filter, which VideoParticipant to fetch.
     */
    where?: VideoParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VideoParticipants to fetch.
     */
    orderBy?: VideoParticipantOrderByWithRelationInput | VideoParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VideoParticipants.
     */
    cursor?: VideoParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VideoParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VideoParticipants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VideoParticipants.
     */
    distinct?: VideoParticipantScalarFieldEnum | VideoParticipantScalarFieldEnum[]
  }

  /**
   * VideoParticipant findFirstOrThrow
   */
  export type VideoParticipantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoParticipant
     */
    select?: VideoParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoParticipantInclude<ExtArgs> | null
    /**
     * Filter, which VideoParticipant to fetch.
     */
    where?: VideoParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VideoParticipants to fetch.
     */
    orderBy?: VideoParticipantOrderByWithRelationInput | VideoParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VideoParticipants.
     */
    cursor?: VideoParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VideoParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VideoParticipants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VideoParticipants.
     */
    distinct?: VideoParticipantScalarFieldEnum | VideoParticipantScalarFieldEnum[]
  }

  /**
   * VideoParticipant findMany
   */
  export type VideoParticipantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoParticipant
     */
    select?: VideoParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoParticipantInclude<ExtArgs> | null
    /**
     * Filter, which VideoParticipants to fetch.
     */
    where?: VideoParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VideoParticipants to fetch.
     */
    orderBy?: VideoParticipantOrderByWithRelationInput | VideoParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VideoParticipants.
     */
    cursor?: VideoParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VideoParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VideoParticipants.
     */
    skip?: number
    distinct?: VideoParticipantScalarFieldEnum | VideoParticipantScalarFieldEnum[]
  }

  /**
   * VideoParticipant create
   */
  export type VideoParticipantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoParticipant
     */
    select?: VideoParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoParticipantInclude<ExtArgs> | null
    /**
     * The data needed to create a VideoParticipant.
     */
    data: XOR<VideoParticipantCreateInput, VideoParticipantUncheckedCreateInput>
  }

  /**
   * VideoParticipant createMany
   */
  export type VideoParticipantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VideoParticipants.
     */
    data: VideoParticipantCreateManyInput | VideoParticipantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VideoParticipant createManyAndReturn
   */
  export type VideoParticipantCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoParticipant
     */
    select?: VideoParticipantSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many VideoParticipants.
     */
    data: VideoParticipantCreateManyInput | VideoParticipantCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoParticipantIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VideoParticipant update
   */
  export type VideoParticipantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoParticipant
     */
    select?: VideoParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoParticipantInclude<ExtArgs> | null
    /**
     * The data needed to update a VideoParticipant.
     */
    data: XOR<VideoParticipantUpdateInput, VideoParticipantUncheckedUpdateInput>
    /**
     * Choose, which VideoParticipant to update.
     */
    where: VideoParticipantWhereUniqueInput
  }

  /**
   * VideoParticipant updateMany
   */
  export type VideoParticipantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VideoParticipants.
     */
    data: XOR<VideoParticipantUpdateManyMutationInput, VideoParticipantUncheckedUpdateManyInput>
    /**
     * Filter which VideoParticipants to update
     */
    where?: VideoParticipantWhereInput
  }

  /**
   * VideoParticipant upsert
   */
  export type VideoParticipantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoParticipant
     */
    select?: VideoParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoParticipantInclude<ExtArgs> | null
    /**
     * The filter to search for the VideoParticipant to update in case it exists.
     */
    where: VideoParticipantWhereUniqueInput
    /**
     * In case the VideoParticipant found by the `where` argument doesn't exist, create a new VideoParticipant with this data.
     */
    create: XOR<VideoParticipantCreateInput, VideoParticipantUncheckedCreateInput>
    /**
     * In case the VideoParticipant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VideoParticipantUpdateInput, VideoParticipantUncheckedUpdateInput>
  }

  /**
   * VideoParticipant delete
   */
  export type VideoParticipantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoParticipant
     */
    select?: VideoParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoParticipantInclude<ExtArgs> | null
    /**
     * Filter which VideoParticipant to delete.
     */
    where: VideoParticipantWhereUniqueInput
  }

  /**
   * VideoParticipant deleteMany
   */
  export type VideoParticipantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VideoParticipants to delete
     */
    where?: VideoParticipantWhereInput
  }

  /**
   * VideoParticipant without action
   */
  export type VideoParticipantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoParticipant
     */
    select?: VideoParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoParticipantInclude<ExtArgs> | null
  }


  /**
   * Model ConsultantAvailability
   */

  export type AggregateConsultantAvailability = {
    _count: ConsultantAvailabilityCountAggregateOutputType | null
    _avg: ConsultantAvailabilityAvgAggregateOutputType | null
    _sum: ConsultantAvailabilitySumAggregateOutputType | null
    _min: ConsultantAvailabilityMinAggregateOutputType | null
    _max: ConsultantAvailabilityMaxAggregateOutputType | null
  }

  export type ConsultantAvailabilityAvgAggregateOutputType = {
    dayOfWeek: number | null
    maxSessions: number | null
    bufferMinutes: number | null
    bookingWindowDays: number | null
    minimumNoticeHours: number | null
  }

  export type ConsultantAvailabilitySumAggregateOutputType = {
    dayOfWeek: number | null
    maxSessions: number | null
    bufferMinutes: number | null
    bookingWindowDays: number | null
    minimumNoticeHours: number | null
  }

  export type ConsultantAvailabilityMinAggregateOutputType = {
    id: string | null
    consultantId: string | null
    availabilityType: $Enums.AvailabilityType | null
    dayOfWeek: number | null
    specificDate: Date | null
    startTime: string | null
    endTime: string | null
    maxSessions: number | null
    bufferMinutes: number | null
    isAvailable: boolean | null
    bookingWindowDays: number | null
    minimumNoticeHours: number | null
    autoApprove: boolean | null
    timezone: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConsultantAvailabilityMaxAggregateOutputType = {
    id: string | null
    consultantId: string | null
    availabilityType: $Enums.AvailabilityType | null
    dayOfWeek: number | null
    specificDate: Date | null
    startTime: string | null
    endTime: string | null
    maxSessions: number | null
    bufferMinutes: number | null
    isAvailable: boolean | null
    bookingWindowDays: number | null
    minimumNoticeHours: number | null
    autoApprove: boolean | null
    timezone: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConsultantAvailabilityCountAggregateOutputType = {
    id: number
    consultantId: number
    availabilityType: number
    dayOfWeek: number
    specificDate: number
    startTime: number
    endTime: number
    maxSessions: number
    bufferMinutes: number
    isAvailable: number
    bookingWindowDays: number
    minimumNoticeHours: number
    autoApprove: number
    timezone: number
    recurringPattern: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ConsultantAvailabilityAvgAggregateInputType = {
    dayOfWeek?: true
    maxSessions?: true
    bufferMinutes?: true
    bookingWindowDays?: true
    minimumNoticeHours?: true
  }

  export type ConsultantAvailabilitySumAggregateInputType = {
    dayOfWeek?: true
    maxSessions?: true
    bufferMinutes?: true
    bookingWindowDays?: true
    minimumNoticeHours?: true
  }

  export type ConsultantAvailabilityMinAggregateInputType = {
    id?: true
    consultantId?: true
    availabilityType?: true
    dayOfWeek?: true
    specificDate?: true
    startTime?: true
    endTime?: true
    maxSessions?: true
    bufferMinutes?: true
    isAvailable?: true
    bookingWindowDays?: true
    minimumNoticeHours?: true
    autoApprove?: true
    timezone?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConsultantAvailabilityMaxAggregateInputType = {
    id?: true
    consultantId?: true
    availabilityType?: true
    dayOfWeek?: true
    specificDate?: true
    startTime?: true
    endTime?: true
    maxSessions?: true
    bufferMinutes?: true
    isAvailable?: true
    bookingWindowDays?: true
    minimumNoticeHours?: true
    autoApprove?: true
    timezone?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConsultantAvailabilityCountAggregateInputType = {
    id?: true
    consultantId?: true
    availabilityType?: true
    dayOfWeek?: true
    specificDate?: true
    startTime?: true
    endTime?: true
    maxSessions?: true
    bufferMinutes?: true
    isAvailable?: true
    bookingWindowDays?: true
    minimumNoticeHours?: true
    autoApprove?: true
    timezone?: true
    recurringPattern?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ConsultantAvailabilityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConsultantAvailability to aggregate.
     */
    where?: ConsultantAvailabilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConsultantAvailabilities to fetch.
     */
    orderBy?: ConsultantAvailabilityOrderByWithRelationInput | ConsultantAvailabilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConsultantAvailabilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConsultantAvailabilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConsultantAvailabilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ConsultantAvailabilities
    **/
    _count?: true | ConsultantAvailabilityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ConsultantAvailabilityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ConsultantAvailabilitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConsultantAvailabilityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConsultantAvailabilityMaxAggregateInputType
  }

  export type GetConsultantAvailabilityAggregateType<T extends ConsultantAvailabilityAggregateArgs> = {
        [P in keyof T & keyof AggregateConsultantAvailability]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConsultantAvailability[P]>
      : GetScalarType<T[P], AggregateConsultantAvailability[P]>
  }




  export type ConsultantAvailabilityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConsultantAvailabilityWhereInput
    orderBy?: ConsultantAvailabilityOrderByWithAggregationInput | ConsultantAvailabilityOrderByWithAggregationInput[]
    by: ConsultantAvailabilityScalarFieldEnum[] | ConsultantAvailabilityScalarFieldEnum
    having?: ConsultantAvailabilityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConsultantAvailabilityCountAggregateInputType | true
    _avg?: ConsultantAvailabilityAvgAggregateInputType
    _sum?: ConsultantAvailabilitySumAggregateInputType
    _min?: ConsultantAvailabilityMinAggregateInputType
    _max?: ConsultantAvailabilityMaxAggregateInputType
  }

  export type ConsultantAvailabilityGroupByOutputType = {
    id: string
    consultantId: string
    availabilityType: $Enums.AvailabilityType
    dayOfWeek: number | null
    specificDate: Date | null
    startTime: string
    endTime: string
    maxSessions: number
    bufferMinutes: number
    isAvailable: boolean
    bookingWindowDays: number
    minimumNoticeHours: number
    autoApprove: boolean
    timezone: string
    recurringPattern: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: ConsultantAvailabilityCountAggregateOutputType | null
    _avg: ConsultantAvailabilityAvgAggregateOutputType | null
    _sum: ConsultantAvailabilitySumAggregateOutputType | null
    _min: ConsultantAvailabilityMinAggregateOutputType | null
    _max: ConsultantAvailabilityMaxAggregateOutputType | null
  }

  type GetConsultantAvailabilityGroupByPayload<T extends ConsultantAvailabilityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConsultantAvailabilityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConsultantAvailabilityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConsultantAvailabilityGroupByOutputType[P]>
            : GetScalarType<T[P], ConsultantAvailabilityGroupByOutputType[P]>
        }
      >
    >


  export type ConsultantAvailabilitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    consultantId?: boolean
    availabilityType?: boolean
    dayOfWeek?: boolean
    specificDate?: boolean
    startTime?: boolean
    endTime?: boolean
    maxSessions?: boolean
    bufferMinutes?: boolean
    isAvailable?: boolean
    bookingWindowDays?: boolean
    minimumNoticeHours?: boolean
    autoApprove?: boolean
    timezone?: boolean
    recurringPattern?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    consultant?: boolean | ConsultantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["consultantAvailability"]>

  export type ConsultantAvailabilitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    consultantId?: boolean
    availabilityType?: boolean
    dayOfWeek?: boolean
    specificDate?: boolean
    startTime?: boolean
    endTime?: boolean
    maxSessions?: boolean
    bufferMinutes?: boolean
    isAvailable?: boolean
    bookingWindowDays?: boolean
    minimumNoticeHours?: boolean
    autoApprove?: boolean
    timezone?: boolean
    recurringPattern?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    consultant?: boolean | ConsultantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["consultantAvailability"]>

  export type ConsultantAvailabilitySelectScalar = {
    id?: boolean
    consultantId?: boolean
    availabilityType?: boolean
    dayOfWeek?: boolean
    specificDate?: boolean
    startTime?: boolean
    endTime?: boolean
    maxSessions?: boolean
    bufferMinutes?: boolean
    isAvailable?: boolean
    bookingWindowDays?: boolean
    minimumNoticeHours?: boolean
    autoApprove?: boolean
    timezone?: boolean
    recurringPattern?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ConsultantAvailabilityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    consultant?: boolean | ConsultantDefaultArgs<ExtArgs>
  }
  export type ConsultantAvailabilityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    consultant?: boolean | ConsultantDefaultArgs<ExtArgs>
  }

  export type $ConsultantAvailabilityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ConsultantAvailability"
    objects: {
      consultant: Prisma.$ConsultantPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      consultantId: string
      availabilityType: $Enums.AvailabilityType
      dayOfWeek: number | null
      specificDate: Date | null
      startTime: string
      endTime: string
      maxSessions: number
      bufferMinutes: number
      isAvailable: boolean
      bookingWindowDays: number
      minimumNoticeHours: number
      autoApprove: boolean
      timezone: string
      recurringPattern: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["consultantAvailability"]>
    composites: {}
  }

  type ConsultantAvailabilityGetPayload<S extends boolean | null | undefined | ConsultantAvailabilityDefaultArgs> = $Result.GetResult<Prisma.$ConsultantAvailabilityPayload, S>

  type ConsultantAvailabilityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ConsultantAvailabilityFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ConsultantAvailabilityCountAggregateInputType | true
    }

  export interface ConsultantAvailabilityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ConsultantAvailability'], meta: { name: 'ConsultantAvailability' } }
    /**
     * Find zero or one ConsultantAvailability that matches the filter.
     * @param {ConsultantAvailabilityFindUniqueArgs} args - Arguments to find a ConsultantAvailability
     * @example
     * // Get one ConsultantAvailability
     * const consultantAvailability = await prisma.consultantAvailability.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConsultantAvailabilityFindUniqueArgs>(args: SelectSubset<T, ConsultantAvailabilityFindUniqueArgs<ExtArgs>>): Prisma__ConsultantAvailabilityClient<$Result.GetResult<Prisma.$ConsultantAvailabilityPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ConsultantAvailability that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ConsultantAvailabilityFindUniqueOrThrowArgs} args - Arguments to find a ConsultantAvailability
     * @example
     * // Get one ConsultantAvailability
     * const consultantAvailability = await prisma.consultantAvailability.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConsultantAvailabilityFindUniqueOrThrowArgs>(args: SelectSubset<T, ConsultantAvailabilityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConsultantAvailabilityClient<$Result.GetResult<Prisma.$ConsultantAvailabilityPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ConsultantAvailability that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsultantAvailabilityFindFirstArgs} args - Arguments to find a ConsultantAvailability
     * @example
     * // Get one ConsultantAvailability
     * const consultantAvailability = await prisma.consultantAvailability.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConsultantAvailabilityFindFirstArgs>(args?: SelectSubset<T, ConsultantAvailabilityFindFirstArgs<ExtArgs>>): Prisma__ConsultantAvailabilityClient<$Result.GetResult<Prisma.$ConsultantAvailabilityPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ConsultantAvailability that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsultantAvailabilityFindFirstOrThrowArgs} args - Arguments to find a ConsultantAvailability
     * @example
     * // Get one ConsultantAvailability
     * const consultantAvailability = await prisma.consultantAvailability.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConsultantAvailabilityFindFirstOrThrowArgs>(args?: SelectSubset<T, ConsultantAvailabilityFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConsultantAvailabilityClient<$Result.GetResult<Prisma.$ConsultantAvailabilityPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ConsultantAvailabilities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsultantAvailabilityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ConsultantAvailabilities
     * const consultantAvailabilities = await prisma.consultantAvailability.findMany()
     * 
     * // Get first 10 ConsultantAvailabilities
     * const consultantAvailabilities = await prisma.consultantAvailability.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const consultantAvailabilityWithIdOnly = await prisma.consultantAvailability.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ConsultantAvailabilityFindManyArgs>(args?: SelectSubset<T, ConsultantAvailabilityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConsultantAvailabilityPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ConsultantAvailability.
     * @param {ConsultantAvailabilityCreateArgs} args - Arguments to create a ConsultantAvailability.
     * @example
     * // Create one ConsultantAvailability
     * const ConsultantAvailability = await prisma.consultantAvailability.create({
     *   data: {
     *     // ... data to create a ConsultantAvailability
     *   }
     * })
     * 
     */
    create<T extends ConsultantAvailabilityCreateArgs>(args: SelectSubset<T, ConsultantAvailabilityCreateArgs<ExtArgs>>): Prisma__ConsultantAvailabilityClient<$Result.GetResult<Prisma.$ConsultantAvailabilityPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ConsultantAvailabilities.
     * @param {ConsultantAvailabilityCreateManyArgs} args - Arguments to create many ConsultantAvailabilities.
     * @example
     * // Create many ConsultantAvailabilities
     * const consultantAvailability = await prisma.consultantAvailability.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConsultantAvailabilityCreateManyArgs>(args?: SelectSubset<T, ConsultantAvailabilityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ConsultantAvailabilities and returns the data saved in the database.
     * @param {ConsultantAvailabilityCreateManyAndReturnArgs} args - Arguments to create many ConsultantAvailabilities.
     * @example
     * // Create many ConsultantAvailabilities
     * const consultantAvailability = await prisma.consultantAvailability.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ConsultantAvailabilities and only return the `id`
     * const consultantAvailabilityWithIdOnly = await prisma.consultantAvailability.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ConsultantAvailabilityCreateManyAndReturnArgs>(args?: SelectSubset<T, ConsultantAvailabilityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConsultantAvailabilityPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ConsultantAvailability.
     * @param {ConsultantAvailabilityDeleteArgs} args - Arguments to delete one ConsultantAvailability.
     * @example
     * // Delete one ConsultantAvailability
     * const ConsultantAvailability = await prisma.consultantAvailability.delete({
     *   where: {
     *     // ... filter to delete one ConsultantAvailability
     *   }
     * })
     * 
     */
    delete<T extends ConsultantAvailabilityDeleteArgs>(args: SelectSubset<T, ConsultantAvailabilityDeleteArgs<ExtArgs>>): Prisma__ConsultantAvailabilityClient<$Result.GetResult<Prisma.$ConsultantAvailabilityPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ConsultantAvailability.
     * @param {ConsultantAvailabilityUpdateArgs} args - Arguments to update one ConsultantAvailability.
     * @example
     * // Update one ConsultantAvailability
     * const consultantAvailability = await prisma.consultantAvailability.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConsultantAvailabilityUpdateArgs>(args: SelectSubset<T, ConsultantAvailabilityUpdateArgs<ExtArgs>>): Prisma__ConsultantAvailabilityClient<$Result.GetResult<Prisma.$ConsultantAvailabilityPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ConsultantAvailabilities.
     * @param {ConsultantAvailabilityDeleteManyArgs} args - Arguments to filter ConsultantAvailabilities to delete.
     * @example
     * // Delete a few ConsultantAvailabilities
     * const { count } = await prisma.consultantAvailability.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConsultantAvailabilityDeleteManyArgs>(args?: SelectSubset<T, ConsultantAvailabilityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConsultantAvailabilities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsultantAvailabilityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ConsultantAvailabilities
     * const consultantAvailability = await prisma.consultantAvailability.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConsultantAvailabilityUpdateManyArgs>(args: SelectSubset<T, ConsultantAvailabilityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ConsultantAvailability.
     * @param {ConsultantAvailabilityUpsertArgs} args - Arguments to update or create a ConsultantAvailability.
     * @example
     * // Update or create a ConsultantAvailability
     * const consultantAvailability = await prisma.consultantAvailability.upsert({
     *   create: {
     *     // ... data to create a ConsultantAvailability
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ConsultantAvailability we want to update
     *   }
     * })
     */
    upsert<T extends ConsultantAvailabilityUpsertArgs>(args: SelectSubset<T, ConsultantAvailabilityUpsertArgs<ExtArgs>>): Prisma__ConsultantAvailabilityClient<$Result.GetResult<Prisma.$ConsultantAvailabilityPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ConsultantAvailabilities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsultantAvailabilityCountArgs} args - Arguments to filter ConsultantAvailabilities to count.
     * @example
     * // Count the number of ConsultantAvailabilities
     * const count = await prisma.consultantAvailability.count({
     *   where: {
     *     // ... the filter for the ConsultantAvailabilities we want to count
     *   }
     * })
    **/
    count<T extends ConsultantAvailabilityCountArgs>(
      args?: Subset<T, ConsultantAvailabilityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConsultantAvailabilityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ConsultantAvailability.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsultantAvailabilityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConsultantAvailabilityAggregateArgs>(args: Subset<T, ConsultantAvailabilityAggregateArgs>): Prisma.PrismaPromise<GetConsultantAvailabilityAggregateType<T>>

    /**
     * Group by ConsultantAvailability.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsultantAvailabilityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConsultantAvailabilityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConsultantAvailabilityGroupByArgs['orderBy'] }
        : { orderBy?: ConsultantAvailabilityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConsultantAvailabilityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConsultantAvailabilityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ConsultantAvailability model
   */
  readonly fields: ConsultantAvailabilityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ConsultantAvailability.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConsultantAvailabilityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    consultant<T extends ConsultantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ConsultantDefaultArgs<ExtArgs>>): Prisma__ConsultantClient<$Result.GetResult<Prisma.$ConsultantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ConsultantAvailability model
   */ 
  interface ConsultantAvailabilityFieldRefs {
    readonly id: FieldRef<"ConsultantAvailability", 'String'>
    readonly consultantId: FieldRef<"ConsultantAvailability", 'String'>
    readonly availabilityType: FieldRef<"ConsultantAvailability", 'AvailabilityType'>
    readonly dayOfWeek: FieldRef<"ConsultantAvailability", 'Int'>
    readonly specificDate: FieldRef<"ConsultantAvailability", 'DateTime'>
    readonly startTime: FieldRef<"ConsultantAvailability", 'String'>
    readonly endTime: FieldRef<"ConsultantAvailability", 'String'>
    readonly maxSessions: FieldRef<"ConsultantAvailability", 'Int'>
    readonly bufferMinutes: FieldRef<"ConsultantAvailability", 'Int'>
    readonly isAvailable: FieldRef<"ConsultantAvailability", 'Boolean'>
    readonly bookingWindowDays: FieldRef<"ConsultantAvailability", 'Int'>
    readonly minimumNoticeHours: FieldRef<"ConsultantAvailability", 'Int'>
    readonly autoApprove: FieldRef<"ConsultantAvailability", 'Boolean'>
    readonly timezone: FieldRef<"ConsultantAvailability", 'String'>
    readonly recurringPattern: FieldRef<"ConsultantAvailability", 'Json'>
    readonly createdAt: FieldRef<"ConsultantAvailability", 'DateTime'>
    readonly updatedAt: FieldRef<"ConsultantAvailability", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ConsultantAvailability findUnique
   */
  export type ConsultantAvailabilityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsultantAvailability
     */
    select?: ConsultantAvailabilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsultantAvailabilityInclude<ExtArgs> | null
    /**
     * Filter, which ConsultantAvailability to fetch.
     */
    where: ConsultantAvailabilityWhereUniqueInput
  }

  /**
   * ConsultantAvailability findUniqueOrThrow
   */
  export type ConsultantAvailabilityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsultantAvailability
     */
    select?: ConsultantAvailabilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsultantAvailabilityInclude<ExtArgs> | null
    /**
     * Filter, which ConsultantAvailability to fetch.
     */
    where: ConsultantAvailabilityWhereUniqueInput
  }

  /**
   * ConsultantAvailability findFirst
   */
  export type ConsultantAvailabilityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsultantAvailability
     */
    select?: ConsultantAvailabilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsultantAvailabilityInclude<ExtArgs> | null
    /**
     * Filter, which ConsultantAvailability to fetch.
     */
    where?: ConsultantAvailabilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConsultantAvailabilities to fetch.
     */
    orderBy?: ConsultantAvailabilityOrderByWithRelationInput | ConsultantAvailabilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConsultantAvailabilities.
     */
    cursor?: ConsultantAvailabilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConsultantAvailabilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConsultantAvailabilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConsultantAvailabilities.
     */
    distinct?: ConsultantAvailabilityScalarFieldEnum | ConsultantAvailabilityScalarFieldEnum[]
  }

  /**
   * ConsultantAvailability findFirstOrThrow
   */
  export type ConsultantAvailabilityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsultantAvailability
     */
    select?: ConsultantAvailabilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsultantAvailabilityInclude<ExtArgs> | null
    /**
     * Filter, which ConsultantAvailability to fetch.
     */
    where?: ConsultantAvailabilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConsultantAvailabilities to fetch.
     */
    orderBy?: ConsultantAvailabilityOrderByWithRelationInput | ConsultantAvailabilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConsultantAvailabilities.
     */
    cursor?: ConsultantAvailabilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConsultantAvailabilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConsultantAvailabilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConsultantAvailabilities.
     */
    distinct?: ConsultantAvailabilityScalarFieldEnum | ConsultantAvailabilityScalarFieldEnum[]
  }

  /**
   * ConsultantAvailability findMany
   */
  export type ConsultantAvailabilityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsultantAvailability
     */
    select?: ConsultantAvailabilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsultantAvailabilityInclude<ExtArgs> | null
    /**
     * Filter, which ConsultantAvailabilities to fetch.
     */
    where?: ConsultantAvailabilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConsultantAvailabilities to fetch.
     */
    orderBy?: ConsultantAvailabilityOrderByWithRelationInput | ConsultantAvailabilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ConsultantAvailabilities.
     */
    cursor?: ConsultantAvailabilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConsultantAvailabilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConsultantAvailabilities.
     */
    skip?: number
    distinct?: ConsultantAvailabilityScalarFieldEnum | ConsultantAvailabilityScalarFieldEnum[]
  }

  /**
   * ConsultantAvailability create
   */
  export type ConsultantAvailabilityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsultantAvailability
     */
    select?: ConsultantAvailabilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsultantAvailabilityInclude<ExtArgs> | null
    /**
     * The data needed to create a ConsultantAvailability.
     */
    data: XOR<ConsultantAvailabilityCreateInput, ConsultantAvailabilityUncheckedCreateInput>
  }

  /**
   * ConsultantAvailability createMany
   */
  export type ConsultantAvailabilityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ConsultantAvailabilities.
     */
    data: ConsultantAvailabilityCreateManyInput | ConsultantAvailabilityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ConsultantAvailability createManyAndReturn
   */
  export type ConsultantAvailabilityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsultantAvailability
     */
    select?: ConsultantAvailabilitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ConsultantAvailabilities.
     */
    data: ConsultantAvailabilityCreateManyInput | ConsultantAvailabilityCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsultantAvailabilityIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ConsultantAvailability update
   */
  export type ConsultantAvailabilityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsultantAvailability
     */
    select?: ConsultantAvailabilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsultantAvailabilityInclude<ExtArgs> | null
    /**
     * The data needed to update a ConsultantAvailability.
     */
    data: XOR<ConsultantAvailabilityUpdateInput, ConsultantAvailabilityUncheckedUpdateInput>
    /**
     * Choose, which ConsultantAvailability to update.
     */
    where: ConsultantAvailabilityWhereUniqueInput
  }

  /**
   * ConsultantAvailability updateMany
   */
  export type ConsultantAvailabilityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ConsultantAvailabilities.
     */
    data: XOR<ConsultantAvailabilityUpdateManyMutationInput, ConsultantAvailabilityUncheckedUpdateManyInput>
    /**
     * Filter which ConsultantAvailabilities to update
     */
    where?: ConsultantAvailabilityWhereInput
  }

  /**
   * ConsultantAvailability upsert
   */
  export type ConsultantAvailabilityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsultantAvailability
     */
    select?: ConsultantAvailabilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsultantAvailabilityInclude<ExtArgs> | null
    /**
     * The filter to search for the ConsultantAvailability to update in case it exists.
     */
    where: ConsultantAvailabilityWhereUniqueInput
    /**
     * In case the ConsultantAvailability found by the `where` argument doesn't exist, create a new ConsultantAvailability with this data.
     */
    create: XOR<ConsultantAvailabilityCreateInput, ConsultantAvailabilityUncheckedCreateInput>
    /**
     * In case the ConsultantAvailability was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConsultantAvailabilityUpdateInput, ConsultantAvailabilityUncheckedUpdateInput>
  }

  /**
   * ConsultantAvailability delete
   */
  export type ConsultantAvailabilityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsultantAvailability
     */
    select?: ConsultantAvailabilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsultantAvailabilityInclude<ExtArgs> | null
    /**
     * Filter which ConsultantAvailability to delete.
     */
    where: ConsultantAvailabilityWhereUniqueInput
  }

  /**
   * ConsultantAvailability deleteMany
   */
  export type ConsultantAvailabilityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConsultantAvailabilities to delete
     */
    where?: ConsultantAvailabilityWhereInput
  }

  /**
   * ConsultantAvailability without action
   */
  export type ConsultantAvailabilityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsultantAvailability
     */
    select?: ConsultantAvailabilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsultantAvailabilityInclude<ExtArgs> | null
  }


  /**
   * Model StudentDocument
   */

  export type AggregateStudentDocument = {
    _count: StudentDocumentCountAggregateOutputType | null
    _avg: StudentDocumentAvgAggregateOutputType | null
    _sum: StudentDocumentSumAggregateOutputType | null
    _min: StudentDocumentMinAggregateOutputType | null
    _max: StudentDocumentMaxAggregateOutputType | null
  }

  export type StudentDocumentAvgAggregateOutputType = {
    fileSizeBytes: number | null
    versionNumber: number | null
    autoValidationScore: number | null
  }

  export type StudentDocumentSumAggregateOutputType = {
    fileSizeBytes: number | null
    versionNumber: number | null
    autoValidationScore: number | null
  }

  export type StudentDocumentMinAggregateOutputType = {
    id: string | null
    studentId: string | null
    documentType: $Enums.DocumentType | null
    fileName: string | null
    fileSizeBytes: number | null
    filePath: string | null
    mimeType: string | null
    extractedText: string | null
    uploadTimestamp: Date | null
    reviewStatus: $Enums.ReviewStatus | null
    reviewedBy: string | null
    reviewedAt: Date | null
    reviewNotes: string | null
    versionNumber: number | null
    replacesDocumentId: string | null
    autoValidationScore: number | null
    requiresManualReview: boolean | null
    createdAt: Date | null
  }

  export type StudentDocumentMaxAggregateOutputType = {
    id: string | null
    studentId: string | null
    documentType: $Enums.DocumentType | null
    fileName: string | null
    fileSizeBytes: number | null
    filePath: string | null
    mimeType: string | null
    extractedText: string | null
    uploadTimestamp: Date | null
    reviewStatus: $Enums.ReviewStatus | null
    reviewedBy: string | null
    reviewedAt: Date | null
    reviewNotes: string | null
    versionNumber: number | null
    replacesDocumentId: string | null
    autoValidationScore: number | null
    requiresManualReview: boolean | null
    createdAt: Date | null
  }

  export type StudentDocumentCountAggregateOutputType = {
    id: number
    studentId: number
    documentType: number
    fileName: number
    fileSizeBytes: number
    filePath: number
    mimeType: number
    extractedText: number
    uploadTimestamp: number
    reviewStatus: number
    reviewedBy: number
    reviewedAt: number
    reviewNotes: number
    versionNumber: number
    replacesDocumentId: number
    autoValidationScore: number
    requiresManualReview: number
    createdAt: number
    _all: number
  }


  export type StudentDocumentAvgAggregateInputType = {
    fileSizeBytes?: true
    versionNumber?: true
    autoValidationScore?: true
  }

  export type StudentDocumentSumAggregateInputType = {
    fileSizeBytes?: true
    versionNumber?: true
    autoValidationScore?: true
  }

  export type StudentDocumentMinAggregateInputType = {
    id?: true
    studentId?: true
    documentType?: true
    fileName?: true
    fileSizeBytes?: true
    filePath?: true
    mimeType?: true
    extractedText?: true
    uploadTimestamp?: true
    reviewStatus?: true
    reviewedBy?: true
    reviewedAt?: true
    reviewNotes?: true
    versionNumber?: true
    replacesDocumentId?: true
    autoValidationScore?: true
    requiresManualReview?: true
    createdAt?: true
  }

  export type StudentDocumentMaxAggregateInputType = {
    id?: true
    studentId?: true
    documentType?: true
    fileName?: true
    fileSizeBytes?: true
    filePath?: true
    mimeType?: true
    extractedText?: true
    uploadTimestamp?: true
    reviewStatus?: true
    reviewedBy?: true
    reviewedAt?: true
    reviewNotes?: true
    versionNumber?: true
    replacesDocumentId?: true
    autoValidationScore?: true
    requiresManualReview?: true
    createdAt?: true
  }

  export type StudentDocumentCountAggregateInputType = {
    id?: true
    studentId?: true
    documentType?: true
    fileName?: true
    fileSizeBytes?: true
    filePath?: true
    mimeType?: true
    extractedText?: true
    uploadTimestamp?: true
    reviewStatus?: true
    reviewedBy?: true
    reviewedAt?: true
    reviewNotes?: true
    versionNumber?: true
    replacesDocumentId?: true
    autoValidationScore?: true
    requiresManualReview?: true
    createdAt?: true
    _all?: true
  }

  export type StudentDocumentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentDocument to aggregate.
     */
    where?: StudentDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentDocuments to fetch.
     */
    orderBy?: StudentDocumentOrderByWithRelationInput | StudentDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StudentDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StudentDocuments
    **/
    _count?: true | StudentDocumentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StudentDocumentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StudentDocumentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentDocumentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentDocumentMaxAggregateInputType
  }

  export type GetStudentDocumentAggregateType<T extends StudentDocumentAggregateArgs> = {
        [P in keyof T & keyof AggregateStudentDocument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudentDocument[P]>
      : GetScalarType<T[P], AggregateStudentDocument[P]>
  }




  export type StudentDocumentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentDocumentWhereInput
    orderBy?: StudentDocumentOrderByWithAggregationInput | StudentDocumentOrderByWithAggregationInput[]
    by: StudentDocumentScalarFieldEnum[] | StudentDocumentScalarFieldEnum
    having?: StudentDocumentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentDocumentCountAggregateInputType | true
    _avg?: StudentDocumentAvgAggregateInputType
    _sum?: StudentDocumentSumAggregateInputType
    _min?: StudentDocumentMinAggregateInputType
    _max?: StudentDocumentMaxAggregateInputType
  }

  export type StudentDocumentGroupByOutputType = {
    id: string
    studentId: string
    documentType: $Enums.DocumentType
    fileName: string
    fileSizeBytes: number
    filePath: string
    mimeType: string
    extractedText: string | null
    uploadTimestamp: Date
    reviewStatus: $Enums.ReviewStatus
    reviewedBy: string | null
    reviewedAt: Date | null
    reviewNotes: string | null
    versionNumber: number
    replacesDocumentId: string | null
    autoValidationScore: number | null
    requiresManualReview: boolean
    createdAt: Date
    _count: StudentDocumentCountAggregateOutputType | null
    _avg: StudentDocumentAvgAggregateOutputType | null
    _sum: StudentDocumentSumAggregateOutputType | null
    _min: StudentDocumentMinAggregateOutputType | null
    _max: StudentDocumentMaxAggregateOutputType | null
  }

  type GetStudentDocumentGroupByPayload<T extends StudentDocumentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudentDocumentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentDocumentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentDocumentGroupByOutputType[P]>
            : GetScalarType<T[P], StudentDocumentGroupByOutputType[P]>
        }
      >
    >


  export type StudentDocumentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    documentType?: boolean
    fileName?: boolean
    fileSizeBytes?: boolean
    filePath?: boolean
    mimeType?: boolean
    extractedText?: boolean
    uploadTimestamp?: boolean
    reviewStatus?: boolean
    reviewedBy?: boolean
    reviewedAt?: boolean
    reviewNotes?: boolean
    versionNumber?: boolean
    replacesDocumentId?: boolean
    autoValidationScore?: boolean
    requiresManualReview?: boolean
    createdAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentDocument"]>

  export type StudentDocumentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    documentType?: boolean
    fileName?: boolean
    fileSizeBytes?: boolean
    filePath?: boolean
    mimeType?: boolean
    extractedText?: boolean
    uploadTimestamp?: boolean
    reviewStatus?: boolean
    reviewedBy?: boolean
    reviewedAt?: boolean
    reviewNotes?: boolean
    versionNumber?: boolean
    replacesDocumentId?: boolean
    autoValidationScore?: boolean
    requiresManualReview?: boolean
    createdAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentDocument"]>

  export type StudentDocumentSelectScalar = {
    id?: boolean
    studentId?: boolean
    documentType?: boolean
    fileName?: boolean
    fileSizeBytes?: boolean
    filePath?: boolean
    mimeType?: boolean
    extractedText?: boolean
    uploadTimestamp?: boolean
    reviewStatus?: boolean
    reviewedBy?: boolean
    reviewedAt?: boolean
    reviewNotes?: boolean
    versionNumber?: boolean
    replacesDocumentId?: boolean
    autoValidationScore?: boolean
    requiresManualReview?: boolean
    createdAt?: boolean
  }

  export type StudentDocumentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }
  export type StudentDocumentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }

  export type $StudentDocumentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StudentDocument"
    objects: {
      student: Prisma.$StudentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      studentId: string
      documentType: $Enums.DocumentType
      fileName: string
      fileSizeBytes: number
      filePath: string
      mimeType: string
      extractedText: string | null
      uploadTimestamp: Date
      reviewStatus: $Enums.ReviewStatus
      reviewedBy: string | null
      reviewedAt: Date | null
      reviewNotes: string | null
      versionNumber: number
      replacesDocumentId: string | null
      autoValidationScore: number | null
      requiresManualReview: boolean
      createdAt: Date
    }, ExtArgs["result"]["studentDocument"]>
    composites: {}
  }

  type StudentDocumentGetPayload<S extends boolean | null | undefined | StudentDocumentDefaultArgs> = $Result.GetResult<Prisma.$StudentDocumentPayload, S>

  type StudentDocumentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StudentDocumentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StudentDocumentCountAggregateInputType | true
    }

  export interface StudentDocumentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StudentDocument'], meta: { name: 'StudentDocument' } }
    /**
     * Find zero or one StudentDocument that matches the filter.
     * @param {StudentDocumentFindUniqueArgs} args - Arguments to find a StudentDocument
     * @example
     * // Get one StudentDocument
     * const studentDocument = await prisma.studentDocument.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StudentDocumentFindUniqueArgs>(args: SelectSubset<T, StudentDocumentFindUniqueArgs<ExtArgs>>): Prisma__StudentDocumentClient<$Result.GetResult<Prisma.$StudentDocumentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one StudentDocument that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {StudentDocumentFindUniqueOrThrowArgs} args - Arguments to find a StudentDocument
     * @example
     * // Get one StudentDocument
     * const studentDocument = await prisma.studentDocument.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StudentDocumentFindUniqueOrThrowArgs>(args: SelectSubset<T, StudentDocumentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StudentDocumentClient<$Result.GetResult<Prisma.$StudentDocumentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first StudentDocument that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentDocumentFindFirstArgs} args - Arguments to find a StudentDocument
     * @example
     * // Get one StudentDocument
     * const studentDocument = await prisma.studentDocument.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StudentDocumentFindFirstArgs>(args?: SelectSubset<T, StudentDocumentFindFirstArgs<ExtArgs>>): Prisma__StudentDocumentClient<$Result.GetResult<Prisma.$StudentDocumentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first StudentDocument that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentDocumentFindFirstOrThrowArgs} args - Arguments to find a StudentDocument
     * @example
     * // Get one StudentDocument
     * const studentDocument = await prisma.studentDocument.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StudentDocumentFindFirstOrThrowArgs>(args?: SelectSubset<T, StudentDocumentFindFirstOrThrowArgs<ExtArgs>>): Prisma__StudentDocumentClient<$Result.GetResult<Prisma.$StudentDocumentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more StudentDocuments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentDocumentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StudentDocuments
     * const studentDocuments = await prisma.studentDocument.findMany()
     * 
     * // Get first 10 StudentDocuments
     * const studentDocuments = await prisma.studentDocument.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const studentDocumentWithIdOnly = await prisma.studentDocument.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StudentDocumentFindManyArgs>(args?: SelectSubset<T, StudentDocumentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentDocumentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a StudentDocument.
     * @param {StudentDocumentCreateArgs} args - Arguments to create a StudentDocument.
     * @example
     * // Create one StudentDocument
     * const StudentDocument = await prisma.studentDocument.create({
     *   data: {
     *     // ... data to create a StudentDocument
     *   }
     * })
     * 
     */
    create<T extends StudentDocumentCreateArgs>(args: SelectSubset<T, StudentDocumentCreateArgs<ExtArgs>>): Prisma__StudentDocumentClient<$Result.GetResult<Prisma.$StudentDocumentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many StudentDocuments.
     * @param {StudentDocumentCreateManyArgs} args - Arguments to create many StudentDocuments.
     * @example
     * // Create many StudentDocuments
     * const studentDocument = await prisma.studentDocument.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StudentDocumentCreateManyArgs>(args?: SelectSubset<T, StudentDocumentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StudentDocuments and returns the data saved in the database.
     * @param {StudentDocumentCreateManyAndReturnArgs} args - Arguments to create many StudentDocuments.
     * @example
     * // Create many StudentDocuments
     * const studentDocument = await prisma.studentDocument.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StudentDocuments and only return the `id`
     * const studentDocumentWithIdOnly = await prisma.studentDocument.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StudentDocumentCreateManyAndReturnArgs>(args?: SelectSubset<T, StudentDocumentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentDocumentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a StudentDocument.
     * @param {StudentDocumentDeleteArgs} args - Arguments to delete one StudentDocument.
     * @example
     * // Delete one StudentDocument
     * const StudentDocument = await prisma.studentDocument.delete({
     *   where: {
     *     // ... filter to delete one StudentDocument
     *   }
     * })
     * 
     */
    delete<T extends StudentDocumentDeleteArgs>(args: SelectSubset<T, StudentDocumentDeleteArgs<ExtArgs>>): Prisma__StudentDocumentClient<$Result.GetResult<Prisma.$StudentDocumentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one StudentDocument.
     * @param {StudentDocumentUpdateArgs} args - Arguments to update one StudentDocument.
     * @example
     * // Update one StudentDocument
     * const studentDocument = await prisma.studentDocument.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StudentDocumentUpdateArgs>(args: SelectSubset<T, StudentDocumentUpdateArgs<ExtArgs>>): Prisma__StudentDocumentClient<$Result.GetResult<Prisma.$StudentDocumentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more StudentDocuments.
     * @param {StudentDocumentDeleteManyArgs} args - Arguments to filter StudentDocuments to delete.
     * @example
     * // Delete a few StudentDocuments
     * const { count } = await prisma.studentDocument.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StudentDocumentDeleteManyArgs>(args?: SelectSubset<T, StudentDocumentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudentDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentDocumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StudentDocuments
     * const studentDocument = await prisma.studentDocument.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StudentDocumentUpdateManyArgs>(args: SelectSubset<T, StudentDocumentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StudentDocument.
     * @param {StudentDocumentUpsertArgs} args - Arguments to update or create a StudentDocument.
     * @example
     * // Update or create a StudentDocument
     * const studentDocument = await prisma.studentDocument.upsert({
     *   create: {
     *     // ... data to create a StudentDocument
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StudentDocument we want to update
     *   }
     * })
     */
    upsert<T extends StudentDocumentUpsertArgs>(args: SelectSubset<T, StudentDocumentUpsertArgs<ExtArgs>>): Prisma__StudentDocumentClient<$Result.GetResult<Prisma.$StudentDocumentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of StudentDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentDocumentCountArgs} args - Arguments to filter StudentDocuments to count.
     * @example
     * // Count the number of StudentDocuments
     * const count = await prisma.studentDocument.count({
     *   where: {
     *     // ... the filter for the StudentDocuments we want to count
     *   }
     * })
    **/
    count<T extends StudentDocumentCountArgs>(
      args?: Subset<T, StudentDocumentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentDocumentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StudentDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentDocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentDocumentAggregateArgs>(args: Subset<T, StudentDocumentAggregateArgs>): Prisma.PrismaPromise<GetStudentDocumentAggregateType<T>>

    /**
     * Group by StudentDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentDocumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudentDocumentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudentDocumentGroupByArgs['orderBy'] }
        : { orderBy?: StudentDocumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudentDocumentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentDocumentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StudentDocument model
   */
  readonly fields: StudentDocumentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StudentDocument.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StudentDocumentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StudentDocument model
   */ 
  interface StudentDocumentFieldRefs {
    readonly id: FieldRef<"StudentDocument", 'String'>
    readonly studentId: FieldRef<"StudentDocument", 'String'>
    readonly documentType: FieldRef<"StudentDocument", 'DocumentType'>
    readonly fileName: FieldRef<"StudentDocument", 'String'>
    readonly fileSizeBytes: FieldRef<"StudentDocument", 'Int'>
    readonly filePath: FieldRef<"StudentDocument", 'String'>
    readonly mimeType: FieldRef<"StudentDocument", 'String'>
    readonly extractedText: FieldRef<"StudentDocument", 'String'>
    readonly uploadTimestamp: FieldRef<"StudentDocument", 'DateTime'>
    readonly reviewStatus: FieldRef<"StudentDocument", 'ReviewStatus'>
    readonly reviewedBy: FieldRef<"StudentDocument", 'String'>
    readonly reviewedAt: FieldRef<"StudentDocument", 'DateTime'>
    readonly reviewNotes: FieldRef<"StudentDocument", 'String'>
    readonly versionNumber: FieldRef<"StudentDocument", 'Int'>
    readonly replacesDocumentId: FieldRef<"StudentDocument", 'String'>
    readonly autoValidationScore: FieldRef<"StudentDocument", 'Float'>
    readonly requiresManualReview: FieldRef<"StudentDocument", 'Boolean'>
    readonly createdAt: FieldRef<"StudentDocument", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StudentDocument findUnique
   */
  export type StudentDocumentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentDocument
     */
    select?: StudentDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentDocumentInclude<ExtArgs> | null
    /**
     * Filter, which StudentDocument to fetch.
     */
    where: StudentDocumentWhereUniqueInput
  }

  /**
   * StudentDocument findUniqueOrThrow
   */
  export type StudentDocumentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentDocument
     */
    select?: StudentDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentDocumentInclude<ExtArgs> | null
    /**
     * Filter, which StudentDocument to fetch.
     */
    where: StudentDocumentWhereUniqueInput
  }

  /**
   * StudentDocument findFirst
   */
  export type StudentDocumentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentDocument
     */
    select?: StudentDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentDocumentInclude<ExtArgs> | null
    /**
     * Filter, which StudentDocument to fetch.
     */
    where?: StudentDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentDocuments to fetch.
     */
    orderBy?: StudentDocumentOrderByWithRelationInput | StudentDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentDocuments.
     */
    cursor?: StudentDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentDocuments.
     */
    distinct?: StudentDocumentScalarFieldEnum | StudentDocumentScalarFieldEnum[]
  }

  /**
   * StudentDocument findFirstOrThrow
   */
  export type StudentDocumentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentDocument
     */
    select?: StudentDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentDocumentInclude<ExtArgs> | null
    /**
     * Filter, which StudentDocument to fetch.
     */
    where?: StudentDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentDocuments to fetch.
     */
    orderBy?: StudentDocumentOrderByWithRelationInput | StudentDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentDocuments.
     */
    cursor?: StudentDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentDocuments.
     */
    distinct?: StudentDocumentScalarFieldEnum | StudentDocumentScalarFieldEnum[]
  }

  /**
   * StudentDocument findMany
   */
  export type StudentDocumentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentDocument
     */
    select?: StudentDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentDocumentInclude<ExtArgs> | null
    /**
     * Filter, which StudentDocuments to fetch.
     */
    where?: StudentDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentDocuments to fetch.
     */
    orderBy?: StudentDocumentOrderByWithRelationInput | StudentDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StudentDocuments.
     */
    cursor?: StudentDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentDocuments.
     */
    skip?: number
    distinct?: StudentDocumentScalarFieldEnum | StudentDocumentScalarFieldEnum[]
  }

  /**
   * StudentDocument create
   */
  export type StudentDocumentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentDocument
     */
    select?: StudentDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentDocumentInclude<ExtArgs> | null
    /**
     * The data needed to create a StudentDocument.
     */
    data: XOR<StudentDocumentCreateInput, StudentDocumentUncheckedCreateInput>
  }

  /**
   * StudentDocument createMany
   */
  export type StudentDocumentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StudentDocuments.
     */
    data: StudentDocumentCreateManyInput | StudentDocumentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StudentDocument createManyAndReturn
   */
  export type StudentDocumentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentDocument
     */
    select?: StudentDocumentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many StudentDocuments.
     */
    data: StudentDocumentCreateManyInput | StudentDocumentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentDocumentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StudentDocument update
   */
  export type StudentDocumentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentDocument
     */
    select?: StudentDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentDocumentInclude<ExtArgs> | null
    /**
     * The data needed to update a StudentDocument.
     */
    data: XOR<StudentDocumentUpdateInput, StudentDocumentUncheckedUpdateInput>
    /**
     * Choose, which StudentDocument to update.
     */
    where: StudentDocumentWhereUniqueInput
  }

  /**
   * StudentDocument updateMany
   */
  export type StudentDocumentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StudentDocuments.
     */
    data: XOR<StudentDocumentUpdateManyMutationInput, StudentDocumentUncheckedUpdateManyInput>
    /**
     * Filter which StudentDocuments to update
     */
    where?: StudentDocumentWhereInput
  }

  /**
   * StudentDocument upsert
   */
  export type StudentDocumentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentDocument
     */
    select?: StudentDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentDocumentInclude<ExtArgs> | null
    /**
     * The filter to search for the StudentDocument to update in case it exists.
     */
    where: StudentDocumentWhereUniqueInput
    /**
     * In case the StudentDocument found by the `where` argument doesn't exist, create a new StudentDocument with this data.
     */
    create: XOR<StudentDocumentCreateInput, StudentDocumentUncheckedCreateInput>
    /**
     * In case the StudentDocument was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudentDocumentUpdateInput, StudentDocumentUncheckedUpdateInput>
  }

  /**
   * StudentDocument delete
   */
  export type StudentDocumentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentDocument
     */
    select?: StudentDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentDocumentInclude<ExtArgs> | null
    /**
     * Filter which StudentDocument to delete.
     */
    where: StudentDocumentWhereUniqueInput
  }

  /**
   * StudentDocument deleteMany
   */
  export type StudentDocumentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentDocuments to delete
     */
    where?: StudentDocumentWhereInput
  }

  /**
   * StudentDocument without action
   */
  export type StudentDocumentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentDocument
     */
    select?: StudentDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentDocumentInclude<ExtArgs> | null
  }


  /**
   * Model SessionHistory
   */

  export type AggregateSessionHistory = {
    _count: SessionHistoryCountAggregateOutputType | null
    _avg: SessionHistoryAvgAggregateOutputType | null
    _sum: SessionHistorySumAggregateOutputType | null
    _min: SessionHistoryMinAggregateOutputType | null
    _max: SessionHistoryMaxAggregateOutputType | null
  }

  export type SessionHistoryAvgAggregateOutputType = {
    sessionDuration: number | null
    rating: number | null
  }

  export type SessionHistorySumAggregateOutputType = {
    sessionDuration: number | null
    rating: number | null
  }

  export type SessionHistoryMinAggregateOutputType = {
    id: string | null
    studentId: string | null
    sessionDate: Date | null
    sessionDuration: number | null
    consultantId: string | null
    sessionType: string | null
    status: string | null
    rating: number | null
    createdAt: Date | null
  }

  export type SessionHistoryMaxAggregateOutputType = {
    id: string | null
    studentId: string | null
    sessionDate: Date | null
    sessionDuration: number | null
    consultantId: string | null
    sessionType: string | null
    status: string | null
    rating: number | null
    createdAt: Date | null
  }

  export type SessionHistoryCountAggregateOutputType = {
    id: number
    studentId: number
    sessionDate: number
    sessionDuration: number
    consultantId: number
    sessionType: number
    status: number
    rating: number
    createdAt: number
    _all: number
  }


  export type SessionHistoryAvgAggregateInputType = {
    sessionDuration?: true
    rating?: true
  }

  export type SessionHistorySumAggregateInputType = {
    sessionDuration?: true
    rating?: true
  }

  export type SessionHistoryMinAggregateInputType = {
    id?: true
    studentId?: true
    sessionDate?: true
    sessionDuration?: true
    consultantId?: true
    sessionType?: true
    status?: true
    rating?: true
    createdAt?: true
  }

  export type SessionHistoryMaxAggregateInputType = {
    id?: true
    studentId?: true
    sessionDate?: true
    sessionDuration?: true
    consultantId?: true
    sessionType?: true
    status?: true
    rating?: true
    createdAt?: true
  }

  export type SessionHistoryCountAggregateInputType = {
    id?: true
    studentId?: true
    sessionDate?: true
    sessionDuration?: true
    consultantId?: true
    sessionType?: true
    status?: true
    rating?: true
    createdAt?: true
    _all?: true
  }

  export type SessionHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SessionHistory to aggregate.
     */
    where?: SessionHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SessionHistories to fetch.
     */
    orderBy?: SessionHistoryOrderByWithRelationInput | SessionHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SessionHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SessionHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SessionHistories
    **/
    _count?: true | SessionHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SessionHistoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SessionHistorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionHistoryMaxAggregateInputType
  }

  export type GetSessionHistoryAggregateType<T extends SessionHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateSessionHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSessionHistory[P]>
      : GetScalarType<T[P], AggregateSessionHistory[P]>
  }




  export type SessionHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionHistoryWhereInput
    orderBy?: SessionHistoryOrderByWithAggregationInput | SessionHistoryOrderByWithAggregationInput[]
    by: SessionHistoryScalarFieldEnum[] | SessionHistoryScalarFieldEnum
    having?: SessionHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionHistoryCountAggregateInputType | true
    _avg?: SessionHistoryAvgAggregateInputType
    _sum?: SessionHistorySumAggregateInputType
    _min?: SessionHistoryMinAggregateInputType
    _max?: SessionHistoryMaxAggregateInputType
  }

  export type SessionHistoryGroupByOutputType = {
    id: string
    studentId: string
    sessionDate: Date
    sessionDuration: number
    consultantId: string
    sessionType: string
    status: string
    rating: number | null
    createdAt: Date
    _count: SessionHistoryCountAggregateOutputType | null
    _avg: SessionHistoryAvgAggregateOutputType | null
    _sum: SessionHistorySumAggregateOutputType | null
    _min: SessionHistoryMinAggregateOutputType | null
    _max: SessionHistoryMaxAggregateOutputType | null
  }

  type GetSessionHistoryGroupByPayload<T extends SessionHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], SessionHistoryGroupByOutputType[P]>
        }
      >
    >


  export type SessionHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    sessionDate?: boolean
    sessionDuration?: boolean
    consultantId?: boolean
    sessionType?: boolean
    status?: boolean
    rating?: boolean
    createdAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sessionHistory"]>

  export type SessionHistorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    sessionDate?: boolean
    sessionDuration?: boolean
    consultantId?: boolean
    sessionType?: boolean
    status?: boolean
    rating?: boolean
    createdAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sessionHistory"]>

  export type SessionHistorySelectScalar = {
    id?: boolean
    studentId?: boolean
    sessionDate?: boolean
    sessionDuration?: boolean
    consultantId?: boolean
    sessionType?: boolean
    status?: boolean
    rating?: boolean
    createdAt?: boolean
  }

  export type SessionHistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }
  export type SessionHistoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }

  export type $SessionHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SessionHistory"
    objects: {
      student: Prisma.$StudentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      studentId: string
      sessionDate: Date
      sessionDuration: number
      consultantId: string
      sessionType: string
      status: string
      rating: number | null
      createdAt: Date
    }, ExtArgs["result"]["sessionHistory"]>
    composites: {}
  }

  type SessionHistoryGetPayload<S extends boolean | null | undefined | SessionHistoryDefaultArgs> = $Result.GetResult<Prisma.$SessionHistoryPayload, S>

  type SessionHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SessionHistoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SessionHistoryCountAggregateInputType | true
    }

  export interface SessionHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SessionHistory'], meta: { name: 'SessionHistory' } }
    /**
     * Find zero or one SessionHistory that matches the filter.
     * @param {SessionHistoryFindUniqueArgs} args - Arguments to find a SessionHistory
     * @example
     * // Get one SessionHistory
     * const sessionHistory = await prisma.sessionHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionHistoryFindUniqueArgs>(args: SelectSubset<T, SessionHistoryFindUniqueArgs<ExtArgs>>): Prisma__SessionHistoryClient<$Result.GetResult<Prisma.$SessionHistoryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SessionHistory that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SessionHistoryFindUniqueOrThrowArgs} args - Arguments to find a SessionHistory
     * @example
     * // Get one SessionHistory
     * const sessionHistory = await prisma.sessionHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionHistoryClient<$Result.GetResult<Prisma.$SessionHistoryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SessionHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionHistoryFindFirstArgs} args - Arguments to find a SessionHistory
     * @example
     * // Get one SessionHistory
     * const sessionHistory = await prisma.sessionHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionHistoryFindFirstArgs>(args?: SelectSubset<T, SessionHistoryFindFirstArgs<ExtArgs>>): Prisma__SessionHistoryClient<$Result.GetResult<Prisma.$SessionHistoryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SessionHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionHistoryFindFirstOrThrowArgs} args - Arguments to find a SessionHistory
     * @example
     * // Get one SessionHistory
     * const sessionHistory = await prisma.sessionHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionHistoryClient<$Result.GetResult<Prisma.$SessionHistoryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SessionHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SessionHistories
     * const sessionHistories = await prisma.sessionHistory.findMany()
     * 
     * // Get first 10 SessionHistories
     * const sessionHistories = await prisma.sessionHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionHistoryWithIdOnly = await prisma.sessionHistory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionHistoryFindManyArgs>(args?: SelectSubset<T, SessionHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionHistoryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SessionHistory.
     * @param {SessionHistoryCreateArgs} args - Arguments to create a SessionHistory.
     * @example
     * // Create one SessionHistory
     * const SessionHistory = await prisma.sessionHistory.create({
     *   data: {
     *     // ... data to create a SessionHistory
     *   }
     * })
     * 
     */
    create<T extends SessionHistoryCreateArgs>(args: SelectSubset<T, SessionHistoryCreateArgs<ExtArgs>>): Prisma__SessionHistoryClient<$Result.GetResult<Prisma.$SessionHistoryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SessionHistories.
     * @param {SessionHistoryCreateManyArgs} args - Arguments to create many SessionHistories.
     * @example
     * // Create many SessionHistories
     * const sessionHistory = await prisma.sessionHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionHistoryCreateManyArgs>(args?: SelectSubset<T, SessionHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SessionHistories and returns the data saved in the database.
     * @param {SessionHistoryCreateManyAndReturnArgs} args - Arguments to create many SessionHistories.
     * @example
     * // Create many SessionHistories
     * const sessionHistory = await prisma.sessionHistory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SessionHistories and only return the `id`
     * const sessionHistoryWithIdOnly = await prisma.sessionHistory.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionHistoryCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionHistoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionHistoryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SessionHistory.
     * @param {SessionHistoryDeleteArgs} args - Arguments to delete one SessionHistory.
     * @example
     * // Delete one SessionHistory
     * const SessionHistory = await prisma.sessionHistory.delete({
     *   where: {
     *     // ... filter to delete one SessionHistory
     *   }
     * })
     * 
     */
    delete<T extends SessionHistoryDeleteArgs>(args: SelectSubset<T, SessionHistoryDeleteArgs<ExtArgs>>): Prisma__SessionHistoryClient<$Result.GetResult<Prisma.$SessionHistoryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SessionHistory.
     * @param {SessionHistoryUpdateArgs} args - Arguments to update one SessionHistory.
     * @example
     * // Update one SessionHistory
     * const sessionHistory = await prisma.sessionHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionHistoryUpdateArgs>(args: SelectSubset<T, SessionHistoryUpdateArgs<ExtArgs>>): Prisma__SessionHistoryClient<$Result.GetResult<Prisma.$SessionHistoryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SessionHistories.
     * @param {SessionHistoryDeleteManyArgs} args - Arguments to filter SessionHistories to delete.
     * @example
     * // Delete a few SessionHistories
     * const { count } = await prisma.sessionHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionHistoryDeleteManyArgs>(args?: SelectSubset<T, SessionHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SessionHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SessionHistories
     * const sessionHistory = await prisma.sessionHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionHistoryUpdateManyArgs>(args: SelectSubset<T, SessionHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SessionHistory.
     * @param {SessionHistoryUpsertArgs} args - Arguments to update or create a SessionHistory.
     * @example
     * // Update or create a SessionHistory
     * const sessionHistory = await prisma.sessionHistory.upsert({
     *   create: {
     *     // ... data to create a SessionHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SessionHistory we want to update
     *   }
     * })
     */
    upsert<T extends SessionHistoryUpsertArgs>(args: SelectSubset<T, SessionHistoryUpsertArgs<ExtArgs>>): Prisma__SessionHistoryClient<$Result.GetResult<Prisma.$SessionHistoryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SessionHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionHistoryCountArgs} args - Arguments to filter SessionHistories to count.
     * @example
     * // Count the number of SessionHistories
     * const count = await prisma.sessionHistory.count({
     *   where: {
     *     // ... the filter for the SessionHistories we want to count
     *   }
     * })
    **/
    count<T extends SessionHistoryCountArgs>(
      args?: Subset<T, SessionHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SessionHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionHistoryAggregateArgs>(args: Subset<T, SessionHistoryAggregateArgs>): Prisma.PrismaPromise<GetSessionHistoryAggregateType<T>>

    /**
     * Group by SessionHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionHistoryGroupByArgs['orderBy'] }
        : { orderBy?: SessionHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SessionHistory model
   */
  readonly fields: SessionHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SessionHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SessionHistory model
   */ 
  interface SessionHistoryFieldRefs {
    readonly id: FieldRef<"SessionHistory", 'String'>
    readonly studentId: FieldRef<"SessionHistory", 'String'>
    readonly sessionDate: FieldRef<"SessionHistory", 'DateTime'>
    readonly sessionDuration: FieldRef<"SessionHistory", 'Int'>
    readonly consultantId: FieldRef<"SessionHistory", 'String'>
    readonly sessionType: FieldRef<"SessionHistory", 'String'>
    readonly status: FieldRef<"SessionHistory", 'String'>
    readonly rating: FieldRef<"SessionHistory", 'Int'>
    readonly createdAt: FieldRef<"SessionHistory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SessionHistory findUnique
   */
  export type SessionHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionHistory
     */
    select?: SessionHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionHistoryInclude<ExtArgs> | null
    /**
     * Filter, which SessionHistory to fetch.
     */
    where: SessionHistoryWhereUniqueInput
  }

  /**
   * SessionHistory findUniqueOrThrow
   */
  export type SessionHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionHistory
     */
    select?: SessionHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionHistoryInclude<ExtArgs> | null
    /**
     * Filter, which SessionHistory to fetch.
     */
    where: SessionHistoryWhereUniqueInput
  }

  /**
   * SessionHistory findFirst
   */
  export type SessionHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionHistory
     */
    select?: SessionHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionHistoryInclude<ExtArgs> | null
    /**
     * Filter, which SessionHistory to fetch.
     */
    where?: SessionHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SessionHistories to fetch.
     */
    orderBy?: SessionHistoryOrderByWithRelationInput | SessionHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SessionHistories.
     */
    cursor?: SessionHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SessionHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SessionHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SessionHistories.
     */
    distinct?: SessionHistoryScalarFieldEnum | SessionHistoryScalarFieldEnum[]
  }

  /**
   * SessionHistory findFirstOrThrow
   */
  export type SessionHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionHistory
     */
    select?: SessionHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionHistoryInclude<ExtArgs> | null
    /**
     * Filter, which SessionHistory to fetch.
     */
    where?: SessionHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SessionHistories to fetch.
     */
    orderBy?: SessionHistoryOrderByWithRelationInput | SessionHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SessionHistories.
     */
    cursor?: SessionHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SessionHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SessionHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SessionHistories.
     */
    distinct?: SessionHistoryScalarFieldEnum | SessionHistoryScalarFieldEnum[]
  }

  /**
   * SessionHistory findMany
   */
  export type SessionHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionHistory
     */
    select?: SessionHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionHistoryInclude<ExtArgs> | null
    /**
     * Filter, which SessionHistories to fetch.
     */
    where?: SessionHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SessionHistories to fetch.
     */
    orderBy?: SessionHistoryOrderByWithRelationInput | SessionHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SessionHistories.
     */
    cursor?: SessionHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SessionHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SessionHistories.
     */
    skip?: number
    distinct?: SessionHistoryScalarFieldEnum | SessionHistoryScalarFieldEnum[]
  }

  /**
   * SessionHistory create
   */
  export type SessionHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionHistory
     */
    select?: SessionHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a SessionHistory.
     */
    data: XOR<SessionHistoryCreateInput, SessionHistoryUncheckedCreateInput>
  }

  /**
   * SessionHistory createMany
   */
  export type SessionHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SessionHistories.
     */
    data: SessionHistoryCreateManyInput | SessionHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SessionHistory createManyAndReturn
   */
  export type SessionHistoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionHistory
     */
    select?: SessionHistorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SessionHistories.
     */
    data: SessionHistoryCreateManyInput | SessionHistoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionHistoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SessionHistory update
   */
  export type SessionHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionHistory
     */
    select?: SessionHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a SessionHistory.
     */
    data: XOR<SessionHistoryUpdateInput, SessionHistoryUncheckedUpdateInput>
    /**
     * Choose, which SessionHistory to update.
     */
    where: SessionHistoryWhereUniqueInput
  }

  /**
   * SessionHistory updateMany
   */
  export type SessionHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SessionHistories.
     */
    data: XOR<SessionHistoryUpdateManyMutationInput, SessionHistoryUncheckedUpdateManyInput>
    /**
     * Filter which SessionHistories to update
     */
    where?: SessionHistoryWhereInput
  }

  /**
   * SessionHistory upsert
   */
  export type SessionHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionHistory
     */
    select?: SessionHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the SessionHistory to update in case it exists.
     */
    where: SessionHistoryWhereUniqueInput
    /**
     * In case the SessionHistory found by the `where` argument doesn't exist, create a new SessionHistory with this data.
     */
    create: XOR<SessionHistoryCreateInput, SessionHistoryUncheckedCreateInput>
    /**
     * In case the SessionHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionHistoryUpdateInput, SessionHistoryUncheckedUpdateInput>
  }

  /**
   * SessionHistory delete
   */
  export type SessionHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionHistory
     */
    select?: SessionHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionHistoryInclude<ExtArgs> | null
    /**
     * Filter which SessionHistory to delete.
     */
    where: SessionHistoryWhereUniqueInput
  }

  /**
   * SessionHistory deleteMany
   */
  export type SessionHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SessionHistories to delete
     */
    where?: SessionHistoryWhereInput
  }

  /**
   * SessionHistory without action
   */
  export type SessionHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionHistory
     */
    select?: SessionHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionHistoryInclude<ExtArgs> | null
  }


  /**
   * Model ConsultantPayment
   */

  export type AggregateConsultantPayment = {
    _count: ConsultantPaymentCountAggregateOutputType | null
    _avg: ConsultantPaymentAvgAggregateOutputType | null
    _sum: ConsultantPaymentSumAggregateOutputType | null
    _min: ConsultantPaymentMinAggregateOutputType | null
    _max: ConsultantPaymentMaxAggregateOutputType | null
  }

  export type ConsultantPaymentAvgAggregateOutputType = {
    totalHours: number | null
    hourlyRate: number | null
    totalAmount: number | null
  }

  export type ConsultantPaymentSumAggregateOutputType = {
    totalHours: number | null
    hourlyRate: number | null
    totalAmount: number | null
  }

  export type ConsultantPaymentMinAggregateOutputType = {
    id: string | null
    consultantId: string | null
    paymentPeriod: string | null
    totalHours: number | null
    hourlyRate: number | null
    totalAmount: number | null
    paymentStatus: $Enums.PaymentStatus | null
    paymentDate: Date | null
    createdAt: Date | null
  }

  export type ConsultantPaymentMaxAggregateOutputType = {
    id: string | null
    consultantId: string | null
    paymentPeriod: string | null
    totalHours: number | null
    hourlyRate: number | null
    totalAmount: number | null
    paymentStatus: $Enums.PaymentStatus | null
    paymentDate: Date | null
    createdAt: Date | null
  }

  export type ConsultantPaymentCountAggregateOutputType = {
    id: number
    consultantId: number
    paymentPeriod: number
    totalHours: number
    hourlyRate: number
    totalAmount: number
    paymentStatus: number
    paymentDate: number
    sessionBreakdown: number
    createdAt: number
    _all: number
  }


  export type ConsultantPaymentAvgAggregateInputType = {
    totalHours?: true
    hourlyRate?: true
    totalAmount?: true
  }

  export type ConsultantPaymentSumAggregateInputType = {
    totalHours?: true
    hourlyRate?: true
    totalAmount?: true
  }

  export type ConsultantPaymentMinAggregateInputType = {
    id?: true
    consultantId?: true
    paymentPeriod?: true
    totalHours?: true
    hourlyRate?: true
    totalAmount?: true
    paymentStatus?: true
    paymentDate?: true
    createdAt?: true
  }

  export type ConsultantPaymentMaxAggregateInputType = {
    id?: true
    consultantId?: true
    paymentPeriod?: true
    totalHours?: true
    hourlyRate?: true
    totalAmount?: true
    paymentStatus?: true
    paymentDate?: true
    createdAt?: true
  }

  export type ConsultantPaymentCountAggregateInputType = {
    id?: true
    consultantId?: true
    paymentPeriod?: true
    totalHours?: true
    hourlyRate?: true
    totalAmount?: true
    paymentStatus?: true
    paymentDate?: true
    sessionBreakdown?: true
    createdAt?: true
    _all?: true
  }

  export type ConsultantPaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConsultantPayment to aggregate.
     */
    where?: ConsultantPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConsultantPayments to fetch.
     */
    orderBy?: ConsultantPaymentOrderByWithRelationInput | ConsultantPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConsultantPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConsultantPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConsultantPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ConsultantPayments
    **/
    _count?: true | ConsultantPaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ConsultantPaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ConsultantPaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConsultantPaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConsultantPaymentMaxAggregateInputType
  }

  export type GetConsultantPaymentAggregateType<T extends ConsultantPaymentAggregateArgs> = {
        [P in keyof T & keyof AggregateConsultantPayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConsultantPayment[P]>
      : GetScalarType<T[P], AggregateConsultantPayment[P]>
  }




  export type ConsultantPaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConsultantPaymentWhereInput
    orderBy?: ConsultantPaymentOrderByWithAggregationInput | ConsultantPaymentOrderByWithAggregationInput[]
    by: ConsultantPaymentScalarFieldEnum[] | ConsultantPaymentScalarFieldEnum
    having?: ConsultantPaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConsultantPaymentCountAggregateInputType | true
    _avg?: ConsultantPaymentAvgAggregateInputType
    _sum?: ConsultantPaymentSumAggregateInputType
    _min?: ConsultantPaymentMinAggregateInputType
    _max?: ConsultantPaymentMaxAggregateInputType
  }

  export type ConsultantPaymentGroupByOutputType = {
    id: string
    consultantId: string
    paymentPeriod: string
    totalHours: number
    hourlyRate: number
    totalAmount: number
    paymentStatus: $Enums.PaymentStatus
    paymentDate: Date | null
    sessionBreakdown: JsonValue | null
    createdAt: Date
    _count: ConsultantPaymentCountAggregateOutputType | null
    _avg: ConsultantPaymentAvgAggregateOutputType | null
    _sum: ConsultantPaymentSumAggregateOutputType | null
    _min: ConsultantPaymentMinAggregateOutputType | null
    _max: ConsultantPaymentMaxAggregateOutputType | null
  }

  type GetConsultantPaymentGroupByPayload<T extends ConsultantPaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConsultantPaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConsultantPaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConsultantPaymentGroupByOutputType[P]>
            : GetScalarType<T[P], ConsultantPaymentGroupByOutputType[P]>
        }
      >
    >


  export type ConsultantPaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    consultantId?: boolean
    paymentPeriod?: boolean
    totalHours?: boolean
    hourlyRate?: boolean
    totalAmount?: boolean
    paymentStatus?: boolean
    paymentDate?: boolean
    sessionBreakdown?: boolean
    createdAt?: boolean
    consultant?: boolean | ConsultantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["consultantPayment"]>

  export type ConsultantPaymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    consultantId?: boolean
    paymentPeriod?: boolean
    totalHours?: boolean
    hourlyRate?: boolean
    totalAmount?: boolean
    paymentStatus?: boolean
    paymentDate?: boolean
    sessionBreakdown?: boolean
    createdAt?: boolean
    consultant?: boolean | ConsultantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["consultantPayment"]>

  export type ConsultantPaymentSelectScalar = {
    id?: boolean
    consultantId?: boolean
    paymentPeriod?: boolean
    totalHours?: boolean
    hourlyRate?: boolean
    totalAmount?: boolean
    paymentStatus?: boolean
    paymentDate?: boolean
    sessionBreakdown?: boolean
    createdAt?: boolean
  }

  export type ConsultantPaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    consultant?: boolean | ConsultantDefaultArgs<ExtArgs>
  }
  export type ConsultantPaymentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    consultant?: boolean | ConsultantDefaultArgs<ExtArgs>
  }

  export type $ConsultantPaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ConsultantPayment"
    objects: {
      consultant: Prisma.$ConsultantPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      consultantId: string
      paymentPeriod: string
      totalHours: number
      hourlyRate: number
      totalAmount: number
      paymentStatus: $Enums.PaymentStatus
      paymentDate: Date | null
      sessionBreakdown: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["consultantPayment"]>
    composites: {}
  }

  type ConsultantPaymentGetPayload<S extends boolean | null | undefined | ConsultantPaymentDefaultArgs> = $Result.GetResult<Prisma.$ConsultantPaymentPayload, S>

  type ConsultantPaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ConsultantPaymentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ConsultantPaymentCountAggregateInputType | true
    }

  export interface ConsultantPaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ConsultantPayment'], meta: { name: 'ConsultantPayment' } }
    /**
     * Find zero or one ConsultantPayment that matches the filter.
     * @param {ConsultantPaymentFindUniqueArgs} args - Arguments to find a ConsultantPayment
     * @example
     * // Get one ConsultantPayment
     * const consultantPayment = await prisma.consultantPayment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConsultantPaymentFindUniqueArgs>(args: SelectSubset<T, ConsultantPaymentFindUniqueArgs<ExtArgs>>): Prisma__ConsultantPaymentClient<$Result.GetResult<Prisma.$ConsultantPaymentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ConsultantPayment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ConsultantPaymentFindUniqueOrThrowArgs} args - Arguments to find a ConsultantPayment
     * @example
     * // Get one ConsultantPayment
     * const consultantPayment = await prisma.consultantPayment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConsultantPaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, ConsultantPaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConsultantPaymentClient<$Result.GetResult<Prisma.$ConsultantPaymentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ConsultantPayment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsultantPaymentFindFirstArgs} args - Arguments to find a ConsultantPayment
     * @example
     * // Get one ConsultantPayment
     * const consultantPayment = await prisma.consultantPayment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConsultantPaymentFindFirstArgs>(args?: SelectSubset<T, ConsultantPaymentFindFirstArgs<ExtArgs>>): Prisma__ConsultantPaymentClient<$Result.GetResult<Prisma.$ConsultantPaymentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ConsultantPayment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsultantPaymentFindFirstOrThrowArgs} args - Arguments to find a ConsultantPayment
     * @example
     * // Get one ConsultantPayment
     * const consultantPayment = await prisma.consultantPayment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConsultantPaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, ConsultantPaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConsultantPaymentClient<$Result.GetResult<Prisma.$ConsultantPaymentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ConsultantPayments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsultantPaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ConsultantPayments
     * const consultantPayments = await prisma.consultantPayment.findMany()
     * 
     * // Get first 10 ConsultantPayments
     * const consultantPayments = await prisma.consultantPayment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const consultantPaymentWithIdOnly = await prisma.consultantPayment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ConsultantPaymentFindManyArgs>(args?: SelectSubset<T, ConsultantPaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConsultantPaymentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ConsultantPayment.
     * @param {ConsultantPaymentCreateArgs} args - Arguments to create a ConsultantPayment.
     * @example
     * // Create one ConsultantPayment
     * const ConsultantPayment = await prisma.consultantPayment.create({
     *   data: {
     *     // ... data to create a ConsultantPayment
     *   }
     * })
     * 
     */
    create<T extends ConsultantPaymentCreateArgs>(args: SelectSubset<T, ConsultantPaymentCreateArgs<ExtArgs>>): Prisma__ConsultantPaymentClient<$Result.GetResult<Prisma.$ConsultantPaymentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ConsultantPayments.
     * @param {ConsultantPaymentCreateManyArgs} args - Arguments to create many ConsultantPayments.
     * @example
     * // Create many ConsultantPayments
     * const consultantPayment = await prisma.consultantPayment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConsultantPaymentCreateManyArgs>(args?: SelectSubset<T, ConsultantPaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ConsultantPayments and returns the data saved in the database.
     * @param {ConsultantPaymentCreateManyAndReturnArgs} args - Arguments to create many ConsultantPayments.
     * @example
     * // Create many ConsultantPayments
     * const consultantPayment = await prisma.consultantPayment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ConsultantPayments and only return the `id`
     * const consultantPaymentWithIdOnly = await prisma.consultantPayment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ConsultantPaymentCreateManyAndReturnArgs>(args?: SelectSubset<T, ConsultantPaymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConsultantPaymentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ConsultantPayment.
     * @param {ConsultantPaymentDeleteArgs} args - Arguments to delete one ConsultantPayment.
     * @example
     * // Delete one ConsultantPayment
     * const ConsultantPayment = await prisma.consultantPayment.delete({
     *   where: {
     *     // ... filter to delete one ConsultantPayment
     *   }
     * })
     * 
     */
    delete<T extends ConsultantPaymentDeleteArgs>(args: SelectSubset<T, ConsultantPaymentDeleteArgs<ExtArgs>>): Prisma__ConsultantPaymentClient<$Result.GetResult<Prisma.$ConsultantPaymentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ConsultantPayment.
     * @param {ConsultantPaymentUpdateArgs} args - Arguments to update one ConsultantPayment.
     * @example
     * // Update one ConsultantPayment
     * const consultantPayment = await prisma.consultantPayment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConsultantPaymentUpdateArgs>(args: SelectSubset<T, ConsultantPaymentUpdateArgs<ExtArgs>>): Prisma__ConsultantPaymentClient<$Result.GetResult<Prisma.$ConsultantPaymentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ConsultantPayments.
     * @param {ConsultantPaymentDeleteManyArgs} args - Arguments to filter ConsultantPayments to delete.
     * @example
     * // Delete a few ConsultantPayments
     * const { count } = await prisma.consultantPayment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConsultantPaymentDeleteManyArgs>(args?: SelectSubset<T, ConsultantPaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConsultantPayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsultantPaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ConsultantPayments
     * const consultantPayment = await prisma.consultantPayment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConsultantPaymentUpdateManyArgs>(args: SelectSubset<T, ConsultantPaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ConsultantPayment.
     * @param {ConsultantPaymentUpsertArgs} args - Arguments to update or create a ConsultantPayment.
     * @example
     * // Update or create a ConsultantPayment
     * const consultantPayment = await prisma.consultantPayment.upsert({
     *   create: {
     *     // ... data to create a ConsultantPayment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ConsultantPayment we want to update
     *   }
     * })
     */
    upsert<T extends ConsultantPaymentUpsertArgs>(args: SelectSubset<T, ConsultantPaymentUpsertArgs<ExtArgs>>): Prisma__ConsultantPaymentClient<$Result.GetResult<Prisma.$ConsultantPaymentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ConsultantPayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsultantPaymentCountArgs} args - Arguments to filter ConsultantPayments to count.
     * @example
     * // Count the number of ConsultantPayments
     * const count = await prisma.consultantPayment.count({
     *   where: {
     *     // ... the filter for the ConsultantPayments we want to count
     *   }
     * })
    **/
    count<T extends ConsultantPaymentCountArgs>(
      args?: Subset<T, ConsultantPaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConsultantPaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ConsultantPayment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsultantPaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConsultantPaymentAggregateArgs>(args: Subset<T, ConsultantPaymentAggregateArgs>): Prisma.PrismaPromise<GetConsultantPaymentAggregateType<T>>

    /**
     * Group by ConsultantPayment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsultantPaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConsultantPaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConsultantPaymentGroupByArgs['orderBy'] }
        : { orderBy?: ConsultantPaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConsultantPaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConsultantPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ConsultantPayment model
   */
  readonly fields: ConsultantPaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ConsultantPayment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConsultantPaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    consultant<T extends ConsultantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ConsultantDefaultArgs<ExtArgs>>): Prisma__ConsultantClient<$Result.GetResult<Prisma.$ConsultantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ConsultantPayment model
   */ 
  interface ConsultantPaymentFieldRefs {
    readonly id: FieldRef<"ConsultantPayment", 'String'>
    readonly consultantId: FieldRef<"ConsultantPayment", 'String'>
    readonly paymentPeriod: FieldRef<"ConsultantPayment", 'String'>
    readonly totalHours: FieldRef<"ConsultantPayment", 'Float'>
    readonly hourlyRate: FieldRef<"ConsultantPayment", 'Float'>
    readonly totalAmount: FieldRef<"ConsultantPayment", 'Float'>
    readonly paymentStatus: FieldRef<"ConsultantPayment", 'PaymentStatus'>
    readonly paymentDate: FieldRef<"ConsultantPayment", 'DateTime'>
    readonly sessionBreakdown: FieldRef<"ConsultantPayment", 'Json'>
    readonly createdAt: FieldRef<"ConsultantPayment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ConsultantPayment findUnique
   */
  export type ConsultantPaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsultantPayment
     */
    select?: ConsultantPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsultantPaymentInclude<ExtArgs> | null
    /**
     * Filter, which ConsultantPayment to fetch.
     */
    where: ConsultantPaymentWhereUniqueInput
  }

  /**
   * ConsultantPayment findUniqueOrThrow
   */
  export type ConsultantPaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsultantPayment
     */
    select?: ConsultantPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsultantPaymentInclude<ExtArgs> | null
    /**
     * Filter, which ConsultantPayment to fetch.
     */
    where: ConsultantPaymentWhereUniqueInput
  }

  /**
   * ConsultantPayment findFirst
   */
  export type ConsultantPaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsultantPayment
     */
    select?: ConsultantPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsultantPaymentInclude<ExtArgs> | null
    /**
     * Filter, which ConsultantPayment to fetch.
     */
    where?: ConsultantPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConsultantPayments to fetch.
     */
    orderBy?: ConsultantPaymentOrderByWithRelationInput | ConsultantPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConsultantPayments.
     */
    cursor?: ConsultantPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConsultantPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConsultantPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConsultantPayments.
     */
    distinct?: ConsultantPaymentScalarFieldEnum | ConsultantPaymentScalarFieldEnum[]
  }

  /**
   * ConsultantPayment findFirstOrThrow
   */
  export type ConsultantPaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsultantPayment
     */
    select?: ConsultantPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsultantPaymentInclude<ExtArgs> | null
    /**
     * Filter, which ConsultantPayment to fetch.
     */
    where?: ConsultantPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConsultantPayments to fetch.
     */
    orderBy?: ConsultantPaymentOrderByWithRelationInput | ConsultantPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConsultantPayments.
     */
    cursor?: ConsultantPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConsultantPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConsultantPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConsultantPayments.
     */
    distinct?: ConsultantPaymentScalarFieldEnum | ConsultantPaymentScalarFieldEnum[]
  }

  /**
   * ConsultantPayment findMany
   */
  export type ConsultantPaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsultantPayment
     */
    select?: ConsultantPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsultantPaymentInclude<ExtArgs> | null
    /**
     * Filter, which ConsultantPayments to fetch.
     */
    where?: ConsultantPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConsultantPayments to fetch.
     */
    orderBy?: ConsultantPaymentOrderByWithRelationInput | ConsultantPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ConsultantPayments.
     */
    cursor?: ConsultantPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConsultantPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConsultantPayments.
     */
    skip?: number
    distinct?: ConsultantPaymentScalarFieldEnum | ConsultantPaymentScalarFieldEnum[]
  }

  /**
   * ConsultantPayment create
   */
  export type ConsultantPaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsultantPayment
     */
    select?: ConsultantPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsultantPaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a ConsultantPayment.
     */
    data: XOR<ConsultantPaymentCreateInput, ConsultantPaymentUncheckedCreateInput>
  }

  /**
   * ConsultantPayment createMany
   */
  export type ConsultantPaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ConsultantPayments.
     */
    data: ConsultantPaymentCreateManyInput | ConsultantPaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ConsultantPayment createManyAndReturn
   */
  export type ConsultantPaymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsultantPayment
     */
    select?: ConsultantPaymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ConsultantPayments.
     */
    data: ConsultantPaymentCreateManyInput | ConsultantPaymentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsultantPaymentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ConsultantPayment update
   */
  export type ConsultantPaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsultantPayment
     */
    select?: ConsultantPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsultantPaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a ConsultantPayment.
     */
    data: XOR<ConsultantPaymentUpdateInput, ConsultantPaymentUncheckedUpdateInput>
    /**
     * Choose, which ConsultantPayment to update.
     */
    where: ConsultantPaymentWhereUniqueInput
  }

  /**
   * ConsultantPayment updateMany
   */
  export type ConsultantPaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ConsultantPayments.
     */
    data: XOR<ConsultantPaymentUpdateManyMutationInput, ConsultantPaymentUncheckedUpdateManyInput>
    /**
     * Filter which ConsultantPayments to update
     */
    where?: ConsultantPaymentWhereInput
  }

  /**
   * ConsultantPayment upsert
   */
  export type ConsultantPaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsultantPayment
     */
    select?: ConsultantPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsultantPaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the ConsultantPayment to update in case it exists.
     */
    where: ConsultantPaymentWhereUniqueInput
    /**
     * In case the ConsultantPayment found by the `where` argument doesn't exist, create a new ConsultantPayment with this data.
     */
    create: XOR<ConsultantPaymentCreateInput, ConsultantPaymentUncheckedCreateInput>
    /**
     * In case the ConsultantPayment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConsultantPaymentUpdateInput, ConsultantPaymentUncheckedUpdateInput>
  }

  /**
   * ConsultantPayment delete
   */
  export type ConsultantPaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsultantPayment
     */
    select?: ConsultantPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsultantPaymentInclude<ExtArgs> | null
    /**
     * Filter which ConsultantPayment to delete.
     */
    where: ConsultantPaymentWhereUniqueInput
  }

  /**
   * ConsultantPayment deleteMany
   */
  export type ConsultantPaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConsultantPayments to delete
     */
    where?: ConsultantPaymentWhereInput
  }

  /**
   * ConsultantPayment without action
   */
  export type ConsultantPaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsultantPayment
     */
    select?: ConsultantPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsultantPaymentInclude<ExtArgs> | null
  }


  /**
   * Model SystemHealthMetric
   */

  export type AggregateSystemHealthMetric = {
    _count: SystemHealthMetricCountAggregateOutputType | null
    _avg: SystemHealthMetricAvgAggregateOutputType | null
    _sum: SystemHealthMetricSumAggregateOutputType | null
    _min: SystemHealthMetricMinAggregateOutputType | null
    _max: SystemHealthMetricMaxAggregateOutputType | null
  }

  export type SystemHealthMetricAvgAggregateOutputType = {
    metricValue: number | null
  }

  export type SystemHealthMetricSumAggregateOutputType = {
    metricValue: number | null
  }

  export type SystemHealthMetricMinAggregateOutputType = {
    id: string | null
    metricType: string | null
    metricValue: number | null
    metricUnit: string | null
    timestamp: Date | null
    createdAt: Date | null
  }

  export type SystemHealthMetricMaxAggregateOutputType = {
    id: string | null
    metricType: string | null
    metricValue: number | null
    metricUnit: string | null
    timestamp: Date | null
    createdAt: Date | null
  }

  export type SystemHealthMetricCountAggregateOutputType = {
    id: number
    metricType: number
    metricValue: number
    metricUnit: number
    timestamp: number
    additionalData: number
    createdAt: number
    _all: number
  }


  export type SystemHealthMetricAvgAggregateInputType = {
    metricValue?: true
  }

  export type SystemHealthMetricSumAggregateInputType = {
    metricValue?: true
  }

  export type SystemHealthMetricMinAggregateInputType = {
    id?: true
    metricType?: true
    metricValue?: true
    metricUnit?: true
    timestamp?: true
    createdAt?: true
  }

  export type SystemHealthMetricMaxAggregateInputType = {
    id?: true
    metricType?: true
    metricValue?: true
    metricUnit?: true
    timestamp?: true
    createdAt?: true
  }

  export type SystemHealthMetricCountAggregateInputType = {
    id?: true
    metricType?: true
    metricValue?: true
    metricUnit?: true
    timestamp?: true
    additionalData?: true
    createdAt?: true
    _all?: true
  }

  export type SystemHealthMetricAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemHealthMetric to aggregate.
     */
    where?: SystemHealthMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemHealthMetrics to fetch.
     */
    orderBy?: SystemHealthMetricOrderByWithRelationInput | SystemHealthMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SystemHealthMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemHealthMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemHealthMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SystemHealthMetrics
    **/
    _count?: true | SystemHealthMetricCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SystemHealthMetricAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SystemHealthMetricSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SystemHealthMetricMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SystemHealthMetricMaxAggregateInputType
  }

  export type GetSystemHealthMetricAggregateType<T extends SystemHealthMetricAggregateArgs> = {
        [P in keyof T & keyof AggregateSystemHealthMetric]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSystemHealthMetric[P]>
      : GetScalarType<T[P], AggregateSystemHealthMetric[P]>
  }




  export type SystemHealthMetricGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SystemHealthMetricWhereInput
    orderBy?: SystemHealthMetricOrderByWithAggregationInput | SystemHealthMetricOrderByWithAggregationInput[]
    by: SystemHealthMetricScalarFieldEnum[] | SystemHealthMetricScalarFieldEnum
    having?: SystemHealthMetricScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SystemHealthMetricCountAggregateInputType | true
    _avg?: SystemHealthMetricAvgAggregateInputType
    _sum?: SystemHealthMetricSumAggregateInputType
    _min?: SystemHealthMetricMinAggregateInputType
    _max?: SystemHealthMetricMaxAggregateInputType
  }

  export type SystemHealthMetricGroupByOutputType = {
    id: string
    metricType: string
    metricValue: number
    metricUnit: string | null
    timestamp: Date
    additionalData: JsonValue | null
    createdAt: Date
    _count: SystemHealthMetricCountAggregateOutputType | null
    _avg: SystemHealthMetricAvgAggregateOutputType | null
    _sum: SystemHealthMetricSumAggregateOutputType | null
    _min: SystemHealthMetricMinAggregateOutputType | null
    _max: SystemHealthMetricMaxAggregateOutputType | null
  }

  type GetSystemHealthMetricGroupByPayload<T extends SystemHealthMetricGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SystemHealthMetricGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SystemHealthMetricGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SystemHealthMetricGroupByOutputType[P]>
            : GetScalarType<T[P], SystemHealthMetricGroupByOutputType[P]>
        }
      >
    >


  export type SystemHealthMetricSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    metricType?: boolean
    metricValue?: boolean
    metricUnit?: boolean
    timestamp?: boolean
    additionalData?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["systemHealthMetric"]>

  export type SystemHealthMetricSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    metricType?: boolean
    metricValue?: boolean
    metricUnit?: boolean
    timestamp?: boolean
    additionalData?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["systemHealthMetric"]>

  export type SystemHealthMetricSelectScalar = {
    id?: boolean
    metricType?: boolean
    metricValue?: boolean
    metricUnit?: boolean
    timestamp?: boolean
    additionalData?: boolean
    createdAt?: boolean
  }


  export type $SystemHealthMetricPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SystemHealthMetric"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      metricType: string
      metricValue: number
      metricUnit: string | null
      timestamp: Date
      additionalData: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["systemHealthMetric"]>
    composites: {}
  }

  type SystemHealthMetricGetPayload<S extends boolean | null | undefined | SystemHealthMetricDefaultArgs> = $Result.GetResult<Prisma.$SystemHealthMetricPayload, S>

  type SystemHealthMetricCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SystemHealthMetricFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SystemHealthMetricCountAggregateInputType | true
    }

  export interface SystemHealthMetricDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SystemHealthMetric'], meta: { name: 'SystemHealthMetric' } }
    /**
     * Find zero or one SystemHealthMetric that matches the filter.
     * @param {SystemHealthMetricFindUniqueArgs} args - Arguments to find a SystemHealthMetric
     * @example
     * // Get one SystemHealthMetric
     * const systemHealthMetric = await prisma.systemHealthMetric.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SystemHealthMetricFindUniqueArgs>(args: SelectSubset<T, SystemHealthMetricFindUniqueArgs<ExtArgs>>): Prisma__SystemHealthMetricClient<$Result.GetResult<Prisma.$SystemHealthMetricPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SystemHealthMetric that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SystemHealthMetricFindUniqueOrThrowArgs} args - Arguments to find a SystemHealthMetric
     * @example
     * // Get one SystemHealthMetric
     * const systemHealthMetric = await prisma.systemHealthMetric.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SystemHealthMetricFindUniqueOrThrowArgs>(args: SelectSubset<T, SystemHealthMetricFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SystemHealthMetricClient<$Result.GetResult<Prisma.$SystemHealthMetricPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SystemHealthMetric that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemHealthMetricFindFirstArgs} args - Arguments to find a SystemHealthMetric
     * @example
     * // Get one SystemHealthMetric
     * const systemHealthMetric = await prisma.systemHealthMetric.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SystemHealthMetricFindFirstArgs>(args?: SelectSubset<T, SystemHealthMetricFindFirstArgs<ExtArgs>>): Prisma__SystemHealthMetricClient<$Result.GetResult<Prisma.$SystemHealthMetricPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SystemHealthMetric that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemHealthMetricFindFirstOrThrowArgs} args - Arguments to find a SystemHealthMetric
     * @example
     * // Get one SystemHealthMetric
     * const systemHealthMetric = await prisma.systemHealthMetric.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SystemHealthMetricFindFirstOrThrowArgs>(args?: SelectSubset<T, SystemHealthMetricFindFirstOrThrowArgs<ExtArgs>>): Prisma__SystemHealthMetricClient<$Result.GetResult<Prisma.$SystemHealthMetricPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SystemHealthMetrics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemHealthMetricFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SystemHealthMetrics
     * const systemHealthMetrics = await prisma.systemHealthMetric.findMany()
     * 
     * // Get first 10 SystemHealthMetrics
     * const systemHealthMetrics = await prisma.systemHealthMetric.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const systemHealthMetricWithIdOnly = await prisma.systemHealthMetric.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SystemHealthMetricFindManyArgs>(args?: SelectSubset<T, SystemHealthMetricFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemHealthMetricPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SystemHealthMetric.
     * @param {SystemHealthMetricCreateArgs} args - Arguments to create a SystemHealthMetric.
     * @example
     * // Create one SystemHealthMetric
     * const SystemHealthMetric = await prisma.systemHealthMetric.create({
     *   data: {
     *     // ... data to create a SystemHealthMetric
     *   }
     * })
     * 
     */
    create<T extends SystemHealthMetricCreateArgs>(args: SelectSubset<T, SystemHealthMetricCreateArgs<ExtArgs>>): Prisma__SystemHealthMetricClient<$Result.GetResult<Prisma.$SystemHealthMetricPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SystemHealthMetrics.
     * @param {SystemHealthMetricCreateManyArgs} args - Arguments to create many SystemHealthMetrics.
     * @example
     * // Create many SystemHealthMetrics
     * const systemHealthMetric = await prisma.systemHealthMetric.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SystemHealthMetricCreateManyArgs>(args?: SelectSubset<T, SystemHealthMetricCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SystemHealthMetrics and returns the data saved in the database.
     * @param {SystemHealthMetricCreateManyAndReturnArgs} args - Arguments to create many SystemHealthMetrics.
     * @example
     * // Create many SystemHealthMetrics
     * const systemHealthMetric = await prisma.systemHealthMetric.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SystemHealthMetrics and only return the `id`
     * const systemHealthMetricWithIdOnly = await prisma.systemHealthMetric.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SystemHealthMetricCreateManyAndReturnArgs>(args?: SelectSubset<T, SystemHealthMetricCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemHealthMetricPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SystemHealthMetric.
     * @param {SystemHealthMetricDeleteArgs} args - Arguments to delete one SystemHealthMetric.
     * @example
     * // Delete one SystemHealthMetric
     * const SystemHealthMetric = await prisma.systemHealthMetric.delete({
     *   where: {
     *     // ... filter to delete one SystemHealthMetric
     *   }
     * })
     * 
     */
    delete<T extends SystemHealthMetricDeleteArgs>(args: SelectSubset<T, SystemHealthMetricDeleteArgs<ExtArgs>>): Prisma__SystemHealthMetricClient<$Result.GetResult<Prisma.$SystemHealthMetricPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SystemHealthMetric.
     * @param {SystemHealthMetricUpdateArgs} args - Arguments to update one SystemHealthMetric.
     * @example
     * // Update one SystemHealthMetric
     * const systemHealthMetric = await prisma.systemHealthMetric.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SystemHealthMetricUpdateArgs>(args: SelectSubset<T, SystemHealthMetricUpdateArgs<ExtArgs>>): Prisma__SystemHealthMetricClient<$Result.GetResult<Prisma.$SystemHealthMetricPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SystemHealthMetrics.
     * @param {SystemHealthMetricDeleteManyArgs} args - Arguments to filter SystemHealthMetrics to delete.
     * @example
     * // Delete a few SystemHealthMetrics
     * const { count } = await prisma.systemHealthMetric.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SystemHealthMetricDeleteManyArgs>(args?: SelectSubset<T, SystemHealthMetricDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SystemHealthMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemHealthMetricUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SystemHealthMetrics
     * const systemHealthMetric = await prisma.systemHealthMetric.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SystemHealthMetricUpdateManyArgs>(args: SelectSubset<T, SystemHealthMetricUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SystemHealthMetric.
     * @param {SystemHealthMetricUpsertArgs} args - Arguments to update or create a SystemHealthMetric.
     * @example
     * // Update or create a SystemHealthMetric
     * const systemHealthMetric = await prisma.systemHealthMetric.upsert({
     *   create: {
     *     // ... data to create a SystemHealthMetric
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SystemHealthMetric we want to update
     *   }
     * })
     */
    upsert<T extends SystemHealthMetricUpsertArgs>(args: SelectSubset<T, SystemHealthMetricUpsertArgs<ExtArgs>>): Prisma__SystemHealthMetricClient<$Result.GetResult<Prisma.$SystemHealthMetricPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SystemHealthMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemHealthMetricCountArgs} args - Arguments to filter SystemHealthMetrics to count.
     * @example
     * // Count the number of SystemHealthMetrics
     * const count = await prisma.systemHealthMetric.count({
     *   where: {
     *     // ... the filter for the SystemHealthMetrics we want to count
     *   }
     * })
    **/
    count<T extends SystemHealthMetricCountArgs>(
      args?: Subset<T, SystemHealthMetricCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SystemHealthMetricCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SystemHealthMetric.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemHealthMetricAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SystemHealthMetricAggregateArgs>(args: Subset<T, SystemHealthMetricAggregateArgs>): Prisma.PrismaPromise<GetSystemHealthMetricAggregateType<T>>

    /**
     * Group by SystemHealthMetric.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemHealthMetricGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SystemHealthMetricGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SystemHealthMetricGroupByArgs['orderBy'] }
        : { orderBy?: SystemHealthMetricGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SystemHealthMetricGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSystemHealthMetricGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SystemHealthMetric model
   */
  readonly fields: SystemHealthMetricFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SystemHealthMetric.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SystemHealthMetricClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SystemHealthMetric model
   */ 
  interface SystemHealthMetricFieldRefs {
    readonly id: FieldRef<"SystemHealthMetric", 'String'>
    readonly metricType: FieldRef<"SystemHealthMetric", 'String'>
    readonly metricValue: FieldRef<"SystemHealthMetric", 'Float'>
    readonly metricUnit: FieldRef<"SystemHealthMetric", 'String'>
    readonly timestamp: FieldRef<"SystemHealthMetric", 'DateTime'>
    readonly additionalData: FieldRef<"SystemHealthMetric", 'Json'>
    readonly createdAt: FieldRef<"SystemHealthMetric", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SystemHealthMetric findUnique
   */
  export type SystemHealthMetricFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemHealthMetric
     */
    select?: SystemHealthMetricSelect<ExtArgs> | null
    /**
     * Filter, which SystemHealthMetric to fetch.
     */
    where: SystemHealthMetricWhereUniqueInput
  }

  /**
   * SystemHealthMetric findUniqueOrThrow
   */
  export type SystemHealthMetricFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemHealthMetric
     */
    select?: SystemHealthMetricSelect<ExtArgs> | null
    /**
     * Filter, which SystemHealthMetric to fetch.
     */
    where: SystemHealthMetricWhereUniqueInput
  }

  /**
   * SystemHealthMetric findFirst
   */
  export type SystemHealthMetricFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemHealthMetric
     */
    select?: SystemHealthMetricSelect<ExtArgs> | null
    /**
     * Filter, which SystemHealthMetric to fetch.
     */
    where?: SystemHealthMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemHealthMetrics to fetch.
     */
    orderBy?: SystemHealthMetricOrderByWithRelationInput | SystemHealthMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemHealthMetrics.
     */
    cursor?: SystemHealthMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemHealthMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemHealthMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemHealthMetrics.
     */
    distinct?: SystemHealthMetricScalarFieldEnum | SystemHealthMetricScalarFieldEnum[]
  }

  /**
   * SystemHealthMetric findFirstOrThrow
   */
  export type SystemHealthMetricFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemHealthMetric
     */
    select?: SystemHealthMetricSelect<ExtArgs> | null
    /**
     * Filter, which SystemHealthMetric to fetch.
     */
    where?: SystemHealthMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemHealthMetrics to fetch.
     */
    orderBy?: SystemHealthMetricOrderByWithRelationInput | SystemHealthMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemHealthMetrics.
     */
    cursor?: SystemHealthMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemHealthMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemHealthMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemHealthMetrics.
     */
    distinct?: SystemHealthMetricScalarFieldEnum | SystemHealthMetricScalarFieldEnum[]
  }

  /**
   * SystemHealthMetric findMany
   */
  export type SystemHealthMetricFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemHealthMetric
     */
    select?: SystemHealthMetricSelect<ExtArgs> | null
    /**
     * Filter, which SystemHealthMetrics to fetch.
     */
    where?: SystemHealthMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemHealthMetrics to fetch.
     */
    orderBy?: SystemHealthMetricOrderByWithRelationInput | SystemHealthMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SystemHealthMetrics.
     */
    cursor?: SystemHealthMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemHealthMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemHealthMetrics.
     */
    skip?: number
    distinct?: SystemHealthMetricScalarFieldEnum | SystemHealthMetricScalarFieldEnum[]
  }

  /**
   * SystemHealthMetric create
   */
  export type SystemHealthMetricCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemHealthMetric
     */
    select?: SystemHealthMetricSelect<ExtArgs> | null
    /**
     * The data needed to create a SystemHealthMetric.
     */
    data: XOR<SystemHealthMetricCreateInput, SystemHealthMetricUncheckedCreateInput>
  }

  /**
   * SystemHealthMetric createMany
   */
  export type SystemHealthMetricCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SystemHealthMetrics.
     */
    data: SystemHealthMetricCreateManyInput | SystemHealthMetricCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SystemHealthMetric createManyAndReturn
   */
  export type SystemHealthMetricCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemHealthMetric
     */
    select?: SystemHealthMetricSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SystemHealthMetrics.
     */
    data: SystemHealthMetricCreateManyInput | SystemHealthMetricCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SystemHealthMetric update
   */
  export type SystemHealthMetricUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemHealthMetric
     */
    select?: SystemHealthMetricSelect<ExtArgs> | null
    /**
     * The data needed to update a SystemHealthMetric.
     */
    data: XOR<SystemHealthMetricUpdateInput, SystemHealthMetricUncheckedUpdateInput>
    /**
     * Choose, which SystemHealthMetric to update.
     */
    where: SystemHealthMetricWhereUniqueInput
  }

  /**
   * SystemHealthMetric updateMany
   */
  export type SystemHealthMetricUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SystemHealthMetrics.
     */
    data: XOR<SystemHealthMetricUpdateManyMutationInput, SystemHealthMetricUncheckedUpdateManyInput>
    /**
     * Filter which SystemHealthMetrics to update
     */
    where?: SystemHealthMetricWhereInput
  }

  /**
   * SystemHealthMetric upsert
   */
  export type SystemHealthMetricUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemHealthMetric
     */
    select?: SystemHealthMetricSelect<ExtArgs> | null
    /**
     * The filter to search for the SystemHealthMetric to update in case it exists.
     */
    where: SystemHealthMetricWhereUniqueInput
    /**
     * In case the SystemHealthMetric found by the `where` argument doesn't exist, create a new SystemHealthMetric with this data.
     */
    create: XOR<SystemHealthMetricCreateInput, SystemHealthMetricUncheckedCreateInput>
    /**
     * In case the SystemHealthMetric was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SystemHealthMetricUpdateInput, SystemHealthMetricUncheckedUpdateInput>
  }

  /**
   * SystemHealthMetric delete
   */
  export type SystemHealthMetricDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemHealthMetric
     */
    select?: SystemHealthMetricSelect<ExtArgs> | null
    /**
     * Filter which SystemHealthMetric to delete.
     */
    where: SystemHealthMetricWhereUniqueInput
  }

  /**
   * SystemHealthMetric deleteMany
   */
  export type SystemHealthMetricDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemHealthMetrics to delete
     */
    where?: SystemHealthMetricWhereInput
  }

  /**
   * SystemHealthMetric without action
   */
  export type SystemHealthMetricDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemHealthMetric
     */
    select?: SystemHealthMetricSelect<ExtArgs> | null
  }


  /**
   * Model InAppNotification
   */

  export type AggregateInAppNotification = {
    _count: InAppNotificationCountAggregateOutputType | null
    _min: InAppNotificationMinAggregateOutputType | null
    _max: InAppNotificationMaxAggregateOutputType | null
  }

  export type InAppNotificationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    message: string | null
    type: string | null
    read: boolean | null
    createdAt: Date | null
  }

  export type InAppNotificationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    message: string | null
    type: string | null
    read: boolean | null
    createdAt: Date | null
  }

  export type InAppNotificationCountAggregateOutputType = {
    id: number
    userId: number
    title: number
    message: number
    type: number
    data: number
    read: number
    createdAt: number
    _all: number
  }


  export type InAppNotificationMinAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    message?: true
    type?: true
    read?: true
    createdAt?: true
  }

  export type InAppNotificationMaxAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    message?: true
    type?: true
    read?: true
    createdAt?: true
  }

  export type InAppNotificationCountAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    message?: true
    type?: true
    data?: true
    read?: true
    createdAt?: true
    _all?: true
  }

  export type InAppNotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InAppNotification to aggregate.
     */
    where?: InAppNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InAppNotifications to fetch.
     */
    orderBy?: InAppNotificationOrderByWithRelationInput | InAppNotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InAppNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InAppNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InAppNotifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InAppNotifications
    **/
    _count?: true | InAppNotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InAppNotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InAppNotificationMaxAggregateInputType
  }

  export type GetInAppNotificationAggregateType<T extends InAppNotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateInAppNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInAppNotification[P]>
      : GetScalarType<T[P], AggregateInAppNotification[P]>
  }




  export type InAppNotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InAppNotificationWhereInput
    orderBy?: InAppNotificationOrderByWithAggregationInput | InAppNotificationOrderByWithAggregationInput[]
    by: InAppNotificationScalarFieldEnum[] | InAppNotificationScalarFieldEnum
    having?: InAppNotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InAppNotificationCountAggregateInputType | true
    _min?: InAppNotificationMinAggregateInputType
    _max?: InAppNotificationMaxAggregateInputType
  }

  export type InAppNotificationGroupByOutputType = {
    id: string
    userId: string
    title: string
    message: string
    type: string
    data: JsonValue | null
    read: boolean
    createdAt: Date
    _count: InAppNotificationCountAggregateOutputType | null
    _min: InAppNotificationMinAggregateOutputType | null
    _max: InAppNotificationMaxAggregateOutputType | null
  }

  type GetInAppNotificationGroupByPayload<T extends InAppNotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InAppNotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InAppNotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InAppNotificationGroupByOutputType[P]>
            : GetScalarType<T[P], InAppNotificationGroupByOutputType[P]>
        }
      >
    >


  export type InAppNotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    message?: boolean
    type?: boolean
    data?: boolean
    read?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["inAppNotification"]>

  export type InAppNotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    message?: boolean
    type?: boolean
    data?: boolean
    read?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["inAppNotification"]>

  export type InAppNotificationSelectScalar = {
    id?: boolean
    userId?: boolean
    title?: boolean
    message?: boolean
    type?: boolean
    data?: boolean
    read?: boolean
    createdAt?: boolean
  }


  export type $InAppNotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InAppNotification"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      title: string
      message: string
      type: string
      data: Prisma.JsonValue | null
      read: boolean
      createdAt: Date
    }, ExtArgs["result"]["inAppNotification"]>
    composites: {}
  }

  type InAppNotificationGetPayload<S extends boolean | null | undefined | InAppNotificationDefaultArgs> = $Result.GetResult<Prisma.$InAppNotificationPayload, S>

  type InAppNotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InAppNotificationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InAppNotificationCountAggregateInputType | true
    }

  export interface InAppNotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InAppNotification'], meta: { name: 'InAppNotification' } }
    /**
     * Find zero or one InAppNotification that matches the filter.
     * @param {InAppNotificationFindUniqueArgs} args - Arguments to find a InAppNotification
     * @example
     * // Get one InAppNotification
     * const inAppNotification = await prisma.inAppNotification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InAppNotificationFindUniqueArgs>(args: SelectSubset<T, InAppNotificationFindUniqueArgs<ExtArgs>>): Prisma__InAppNotificationClient<$Result.GetResult<Prisma.$InAppNotificationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one InAppNotification that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {InAppNotificationFindUniqueOrThrowArgs} args - Arguments to find a InAppNotification
     * @example
     * // Get one InAppNotification
     * const inAppNotification = await prisma.inAppNotification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InAppNotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, InAppNotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InAppNotificationClient<$Result.GetResult<Prisma.$InAppNotificationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first InAppNotification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InAppNotificationFindFirstArgs} args - Arguments to find a InAppNotification
     * @example
     * // Get one InAppNotification
     * const inAppNotification = await prisma.inAppNotification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InAppNotificationFindFirstArgs>(args?: SelectSubset<T, InAppNotificationFindFirstArgs<ExtArgs>>): Prisma__InAppNotificationClient<$Result.GetResult<Prisma.$InAppNotificationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first InAppNotification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InAppNotificationFindFirstOrThrowArgs} args - Arguments to find a InAppNotification
     * @example
     * // Get one InAppNotification
     * const inAppNotification = await prisma.inAppNotification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InAppNotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, InAppNotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__InAppNotificationClient<$Result.GetResult<Prisma.$InAppNotificationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more InAppNotifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InAppNotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InAppNotifications
     * const inAppNotifications = await prisma.inAppNotification.findMany()
     * 
     * // Get first 10 InAppNotifications
     * const inAppNotifications = await prisma.inAppNotification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const inAppNotificationWithIdOnly = await prisma.inAppNotification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InAppNotificationFindManyArgs>(args?: SelectSubset<T, InAppNotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InAppNotificationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a InAppNotification.
     * @param {InAppNotificationCreateArgs} args - Arguments to create a InAppNotification.
     * @example
     * // Create one InAppNotification
     * const InAppNotification = await prisma.inAppNotification.create({
     *   data: {
     *     // ... data to create a InAppNotification
     *   }
     * })
     * 
     */
    create<T extends InAppNotificationCreateArgs>(args: SelectSubset<T, InAppNotificationCreateArgs<ExtArgs>>): Prisma__InAppNotificationClient<$Result.GetResult<Prisma.$InAppNotificationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many InAppNotifications.
     * @param {InAppNotificationCreateManyArgs} args - Arguments to create many InAppNotifications.
     * @example
     * // Create many InAppNotifications
     * const inAppNotification = await prisma.inAppNotification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InAppNotificationCreateManyArgs>(args?: SelectSubset<T, InAppNotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InAppNotifications and returns the data saved in the database.
     * @param {InAppNotificationCreateManyAndReturnArgs} args - Arguments to create many InAppNotifications.
     * @example
     * // Create many InAppNotifications
     * const inAppNotification = await prisma.inAppNotification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InAppNotifications and only return the `id`
     * const inAppNotificationWithIdOnly = await prisma.inAppNotification.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InAppNotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, InAppNotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InAppNotificationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a InAppNotification.
     * @param {InAppNotificationDeleteArgs} args - Arguments to delete one InAppNotification.
     * @example
     * // Delete one InAppNotification
     * const InAppNotification = await prisma.inAppNotification.delete({
     *   where: {
     *     // ... filter to delete one InAppNotification
     *   }
     * })
     * 
     */
    delete<T extends InAppNotificationDeleteArgs>(args: SelectSubset<T, InAppNotificationDeleteArgs<ExtArgs>>): Prisma__InAppNotificationClient<$Result.GetResult<Prisma.$InAppNotificationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one InAppNotification.
     * @param {InAppNotificationUpdateArgs} args - Arguments to update one InAppNotification.
     * @example
     * // Update one InAppNotification
     * const inAppNotification = await prisma.inAppNotification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InAppNotificationUpdateArgs>(args: SelectSubset<T, InAppNotificationUpdateArgs<ExtArgs>>): Prisma__InAppNotificationClient<$Result.GetResult<Prisma.$InAppNotificationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more InAppNotifications.
     * @param {InAppNotificationDeleteManyArgs} args - Arguments to filter InAppNotifications to delete.
     * @example
     * // Delete a few InAppNotifications
     * const { count } = await prisma.inAppNotification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InAppNotificationDeleteManyArgs>(args?: SelectSubset<T, InAppNotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InAppNotifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InAppNotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InAppNotifications
     * const inAppNotification = await prisma.inAppNotification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InAppNotificationUpdateManyArgs>(args: SelectSubset<T, InAppNotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one InAppNotification.
     * @param {InAppNotificationUpsertArgs} args - Arguments to update or create a InAppNotification.
     * @example
     * // Update or create a InAppNotification
     * const inAppNotification = await prisma.inAppNotification.upsert({
     *   create: {
     *     // ... data to create a InAppNotification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InAppNotification we want to update
     *   }
     * })
     */
    upsert<T extends InAppNotificationUpsertArgs>(args: SelectSubset<T, InAppNotificationUpsertArgs<ExtArgs>>): Prisma__InAppNotificationClient<$Result.GetResult<Prisma.$InAppNotificationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of InAppNotifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InAppNotificationCountArgs} args - Arguments to filter InAppNotifications to count.
     * @example
     * // Count the number of InAppNotifications
     * const count = await prisma.inAppNotification.count({
     *   where: {
     *     // ... the filter for the InAppNotifications we want to count
     *   }
     * })
    **/
    count<T extends InAppNotificationCountArgs>(
      args?: Subset<T, InAppNotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InAppNotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InAppNotification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InAppNotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InAppNotificationAggregateArgs>(args: Subset<T, InAppNotificationAggregateArgs>): Prisma.PrismaPromise<GetInAppNotificationAggregateType<T>>

    /**
     * Group by InAppNotification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InAppNotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InAppNotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InAppNotificationGroupByArgs['orderBy'] }
        : { orderBy?: InAppNotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InAppNotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInAppNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InAppNotification model
   */
  readonly fields: InAppNotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InAppNotification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InAppNotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InAppNotification model
   */ 
  interface InAppNotificationFieldRefs {
    readonly id: FieldRef<"InAppNotification", 'String'>
    readonly userId: FieldRef<"InAppNotification", 'String'>
    readonly title: FieldRef<"InAppNotification", 'String'>
    readonly message: FieldRef<"InAppNotification", 'String'>
    readonly type: FieldRef<"InAppNotification", 'String'>
    readonly data: FieldRef<"InAppNotification", 'Json'>
    readonly read: FieldRef<"InAppNotification", 'Boolean'>
    readonly createdAt: FieldRef<"InAppNotification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * InAppNotification findUnique
   */
  export type InAppNotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InAppNotification
     */
    select?: InAppNotificationSelect<ExtArgs> | null
    /**
     * Filter, which InAppNotification to fetch.
     */
    where: InAppNotificationWhereUniqueInput
  }

  /**
   * InAppNotification findUniqueOrThrow
   */
  export type InAppNotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InAppNotification
     */
    select?: InAppNotificationSelect<ExtArgs> | null
    /**
     * Filter, which InAppNotification to fetch.
     */
    where: InAppNotificationWhereUniqueInput
  }

  /**
   * InAppNotification findFirst
   */
  export type InAppNotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InAppNotification
     */
    select?: InAppNotificationSelect<ExtArgs> | null
    /**
     * Filter, which InAppNotification to fetch.
     */
    where?: InAppNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InAppNotifications to fetch.
     */
    orderBy?: InAppNotificationOrderByWithRelationInput | InAppNotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InAppNotifications.
     */
    cursor?: InAppNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InAppNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InAppNotifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InAppNotifications.
     */
    distinct?: InAppNotificationScalarFieldEnum | InAppNotificationScalarFieldEnum[]
  }

  /**
   * InAppNotification findFirstOrThrow
   */
  export type InAppNotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InAppNotification
     */
    select?: InAppNotificationSelect<ExtArgs> | null
    /**
     * Filter, which InAppNotification to fetch.
     */
    where?: InAppNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InAppNotifications to fetch.
     */
    orderBy?: InAppNotificationOrderByWithRelationInput | InAppNotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InAppNotifications.
     */
    cursor?: InAppNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InAppNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InAppNotifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InAppNotifications.
     */
    distinct?: InAppNotificationScalarFieldEnum | InAppNotificationScalarFieldEnum[]
  }

  /**
   * InAppNotification findMany
   */
  export type InAppNotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InAppNotification
     */
    select?: InAppNotificationSelect<ExtArgs> | null
    /**
     * Filter, which InAppNotifications to fetch.
     */
    where?: InAppNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InAppNotifications to fetch.
     */
    orderBy?: InAppNotificationOrderByWithRelationInput | InAppNotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InAppNotifications.
     */
    cursor?: InAppNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InAppNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InAppNotifications.
     */
    skip?: number
    distinct?: InAppNotificationScalarFieldEnum | InAppNotificationScalarFieldEnum[]
  }

  /**
   * InAppNotification create
   */
  export type InAppNotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InAppNotification
     */
    select?: InAppNotificationSelect<ExtArgs> | null
    /**
     * The data needed to create a InAppNotification.
     */
    data: XOR<InAppNotificationCreateInput, InAppNotificationUncheckedCreateInput>
  }

  /**
   * InAppNotification createMany
   */
  export type InAppNotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InAppNotifications.
     */
    data: InAppNotificationCreateManyInput | InAppNotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InAppNotification createManyAndReturn
   */
  export type InAppNotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InAppNotification
     */
    select?: InAppNotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many InAppNotifications.
     */
    data: InAppNotificationCreateManyInput | InAppNotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InAppNotification update
   */
  export type InAppNotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InAppNotification
     */
    select?: InAppNotificationSelect<ExtArgs> | null
    /**
     * The data needed to update a InAppNotification.
     */
    data: XOR<InAppNotificationUpdateInput, InAppNotificationUncheckedUpdateInput>
    /**
     * Choose, which InAppNotification to update.
     */
    where: InAppNotificationWhereUniqueInput
  }

  /**
   * InAppNotification updateMany
   */
  export type InAppNotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InAppNotifications.
     */
    data: XOR<InAppNotificationUpdateManyMutationInput, InAppNotificationUncheckedUpdateManyInput>
    /**
     * Filter which InAppNotifications to update
     */
    where?: InAppNotificationWhereInput
  }

  /**
   * InAppNotification upsert
   */
  export type InAppNotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InAppNotification
     */
    select?: InAppNotificationSelect<ExtArgs> | null
    /**
     * The filter to search for the InAppNotification to update in case it exists.
     */
    where: InAppNotificationWhereUniqueInput
    /**
     * In case the InAppNotification found by the `where` argument doesn't exist, create a new InAppNotification with this data.
     */
    create: XOR<InAppNotificationCreateInput, InAppNotificationUncheckedCreateInput>
    /**
     * In case the InAppNotification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InAppNotificationUpdateInput, InAppNotificationUncheckedUpdateInput>
  }

  /**
   * InAppNotification delete
   */
  export type InAppNotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InAppNotification
     */
    select?: InAppNotificationSelect<ExtArgs> | null
    /**
     * Filter which InAppNotification to delete.
     */
    where: InAppNotificationWhereUniqueInput
  }

  /**
   * InAppNotification deleteMany
   */
  export type InAppNotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InAppNotifications to delete
     */
    where?: InAppNotificationWhereInput
  }

  /**
   * InAppNotification without action
   */
  export type InAppNotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InAppNotification
     */
    select?: InAppNotificationSelect<ExtArgs> | null
  }


  /**
   * Model ScheduledNotification
   */

  export type AggregateScheduledNotification = {
    _count: ScheduledNotificationCountAggregateOutputType | null
    _min: ScheduledNotificationMinAggregateOutputType | null
    _max: ScheduledNotificationMaxAggregateOutputType | null
  }

  export type ScheduledNotificationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    title: string | null
    message: string | null
    priority: string | null
    scheduledFor: Date | null
    status: $Enums.ScheduledNotificationStatus | null
    sentAt: Date | null
    createdAt: Date | null
  }

  export type ScheduledNotificationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    title: string | null
    message: string | null
    priority: string | null
    scheduledFor: Date | null
    status: $Enums.ScheduledNotificationStatus | null
    sentAt: Date | null
    createdAt: Date | null
  }

  export type ScheduledNotificationCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    title: number
    message: number
    data: number
    priority: number
    scheduledFor: number
    status: number
    sentAt: number
    createdAt: number
    _all: number
  }


  export type ScheduledNotificationMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    title?: true
    message?: true
    priority?: true
    scheduledFor?: true
    status?: true
    sentAt?: true
    createdAt?: true
  }

  export type ScheduledNotificationMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    title?: true
    message?: true
    priority?: true
    scheduledFor?: true
    status?: true
    sentAt?: true
    createdAt?: true
  }

  export type ScheduledNotificationCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    title?: true
    message?: true
    data?: true
    priority?: true
    scheduledFor?: true
    status?: true
    sentAt?: true
    createdAt?: true
    _all?: true
  }

  export type ScheduledNotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ScheduledNotification to aggregate.
     */
    where?: ScheduledNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScheduledNotifications to fetch.
     */
    orderBy?: ScheduledNotificationOrderByWithRelationInput | ScheduledNotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ScheduledNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScheduledNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScheduledNotifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ScheduledNotifications
    **/
    _count?: true | ScheduledNotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ScheduledNotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ScheduledNotificationMaxAggregateInputType
  }

  export type GetScheduledNotificationAggregateType<T extends ScheduledNotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateScheduledNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateScheduledNotification[P]>
      : GetScalarType<T[P], AggregateScheduledNotification[P]>
  }




  export type ScheduledNotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScheduledNotificationWhereInput
    orderBy?: ScheduledNotificationOrderByWithAggregationInput | ScheduledNotificationOrderByWithAggregationInput[]
    by: ScheduledNotificationScalarFieldEnum[] | ScheduledNotificationScalarFieldEnum
    having?: ScheduledNotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ScheduledNotificationCountAggregateInputType | true
    _min?: ScheduledNotificationMinAggregateInputType
    _max?: ScheduledNotificationMaxAggregateInputType
  }

  export type ScheduledNotificationGroupByOutputType = {
    id: string
    userId: string
    type: string
    title: string
    message: string
    data: JsonValue | null
    priority: string
    scheduledFor: Date
    status: $Enums.ScheduledNotificationStatus
    sentAt: Date | null
    createdAt: Date
    _count: ScheduledNotificationCountAggregateOutputType | null
    _min: ScheduledNotificationMinAggregateOutputType | null
    _max: ScheduledNotificationMaxAggregateOutputType | null
  }

  type GetScheduledNotificationGroupByPayload<T extends ScheduledNotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ScheduledNotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ScheduledNotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ScheduledNotificationGroupByOutputType[P]>
            : GetScalarType<T[P], ScheduledNotificationGroupByOutputType[P]>
        }
      >
    >


  export type ScheduledNotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    data?: boolean
    priority?: boolean
    scheduledFor?: boolean
    status?: boolean
    sentAt?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["scheduledNotification"]>

  export type ScheduledNotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    data?: boolean
    priority?: boolean
    scheduledFor?: boolean
    status?: boolean
    sentAt?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["scheduledNotification"]>

  export type ScheduledNotificationSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    data?: boolean
    priority?: boolean
    scheduledFor?: boolean
    status?: boolean
    sentAt?: boolean
    createdAt?: boolean
  }


  export type $ScheduledNotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ScheduledNotification"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: string
      title: string
      message: string
      data: Prisma.JsonValue | null
      priority: string
      scheduledFor: Date
      status: $Enums.ScheduledNotificationStatus
      sentAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["scheduledNotification"]>
    composites: {}
  }

  type ScheduledNotificationGetPayload<S extends boolean | null | undefined | ScheduledNotificationDefaultArgs> = $Result.GetResult<Prisma.$ScheduledNotificationPayload, S>

  type ScheduledNotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ScheduledNotificationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ScheduledNotificationCountAggregateInputType | true
    }

  export interface ScheduledNotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ScheduledNotification'], meta: { name: 'ScheduledNotification' } }
    /**
     * Find zero or one ScheduledNotification that matches the filter.
     * @param {ScheduledNotificationFindUniqueArgs} args - Arguments to find a ScheduledNotification
     * @example
     * // Get one ScheduledNotification
     * const scheduledNotification = await prisma.scheduledNotification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ScheduledNotificationFindUniqueArgs>(args: SelectSubset<T, ScheduledNotificationFindUniqueArgs<ExtArgs>>): Prisma__ScheduledNotificationClient<$Result.GetResult<Prisma.$ScheduledNotificationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ScheduledNotification that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ScheduledNotificationFindUniqueOrThrowArgs} args - Arguments to find a ScheduledNotification
     * @example
     * // Get one ScheduledNotification
     * const scheduledNotification = await prisma.scheduledNotification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ScheduledNotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, ScheduledNotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ScheduledNotificationClient<$Result.GetResult<Prisma.$ScheduledNotificationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ScheduledNotification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduledNotificationFindFirstArgs} args - Arguments to find a ScheduledNotification
     * @example
     * // Get one ScheduledNotification
     * const scheduledNotification = await prisma.scheduledNotification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ScheduledNotificationFindFirstArgs>(args?: SelectSubset<T, ScheduledNotificationFindFirstArgs<ExtArgs>>): Prisma__ScheduledNotificationClient<$Result.GetResult<Prisma.$ScheduledNotificationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ScheduledNotification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduledNotificationFindFirstOrThrowArgs} args - Arguments to find a ScheduledNotification
     * @example
     * // Get one ScheduledNotification
     * const scheduledNotification = await prisma.scheduledNotification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ScheduledNotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, ScheduledNotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__ScheduledNotificationClient<$Result.GetResult<Prisma.$ScheduledNotificationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ScheduledNotifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduledNotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ScheduledNotifications
     * const scheduledNotifications = await prisma.scheduledNotification.findMany()
     * 
     * // Get first 10 ScheduledNotifications
     * const scheduledNotifications = await prisma.scheduledNotification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const scheduledNotificationWithIdOnly = await prisma.scheduledNotification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ScheduledNotificationFindManyArgs>(args?: SelectSubset<T, ScheduledNotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScheduledNotificationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ScheduledNotification.
     * @param {ScheduledNotificationCreateArgs} args - Arguments to create a ScheduledNotification.
     * @example
     * // Create one ScheduledNotification
     * const ScheduledNotification = await prisma.scheduledNotification.create({
     *   data: {
     *     // ... data to create a ScheduledNotification
     *   }
     * })
     * 
     */
    create<T extends ScheduledNotificationCreateArgs>(args: SelectSubset<T, ScheduledNotificationCreateArgs<ExtArgs>>): Prisma__ScheduledNotificationClient<$Result.GetResult<Prisma.$ScheduledNotificationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ScheduledNotifications.
     * @param {ScheduledNotificationCreateManyArgs} args - Arguments to create many ScheduledNotifications.
     * @example
     * // Create many ScheduledNotifications
     * const scheduledNotification = await prisma.scheduledNotification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ScheduledNotificationCreateManyArgs>(args?: SelectSubset<T, ScheduledNotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ScheduledNotifications and returns the data saved in the database.
     * @param {ScheduledNotificationCreateManyAndReturnArgs} args - Arguments to create many ScheduledNotifications.
     * @example
     * // Create many ScheduledNotifications
     * const scheduledNotification = await prisma.scheduledNotification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ScheduledNotifications and only return the `id`
     * const scheduledNotificationWithIdOnly = await prisma.scheduledNotification.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ScheduledNotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, ScheduledNotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScheduledNotificationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ScheduledNotification.
     * @param {ScheduledNotificationDeleteArgs} args - Arguments to delete one ScheduledNotification.
     * @example
     * // Delete one ScheduledNotification
     * const ScheduledNotification = await prisma.scheduledNotification.delete({
     *   where: {
     *     // ... filter to delete one ScheduledNotification
     *   }
     * })
     * 
     */
    delete<T extends ScheduledNotificationDeleteArgs>(args: SelectSubset<T, ScheduledNotificationDeleteArgs<ExtArgs>>): Prisma__ScheduledNotificationClient<$Result.GetResult<Prisma.$ScheduledNotificationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ScheduledNotification.
     * @param {ScheduledNotificationUpdateArgs} args - Arguments to update one ScheduledNotification.
     * @example
     * // Update one ScheduledNotification
     * const scheduledNotification = await prisma.scheduledNotification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ScheduledNotificationUpdateArgs>(args: SelectSubset<T, ScheduledNotificationUpdateArgs<ExtArgs>>): Prisma__ScheduledNotificationClient<$Result.GetResult<Prisma.$ScheduledNotificationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ScheduledNotifications.
     * @param {ScheduledNotificationDeleteManyArgs} args - Arguments to filter ScheduledNotifications to delete.
     * @example
     * // Delete a few ScheduledNotifications
     * const { count } = await prisma.scheduledNotification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ScheduledNotificationDeleteManyArgs>(args?: SelectSubset<T, ScheduledNotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ScheduledNotifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduledNotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ScheduledNotifications
     * const scheduledNotification = await prisma.scheduledNotification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ScheduledNotificationUpdateManyArgs>(args: SelectSubset<T, ScheduledNotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ScheduledNotification.
     * @param {ScheduledNotificationUpsertArgs} args - Arguments to update or create a ScheduledNotification.
     * @example
     * // Update or create a ScheduledNotification
     * const scheduledNotification = await prisma.scheduledNotification.upsert({
     *   create: {
     *     // ... data to create a ScheduledNotification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ScheduledNotification we want to update
     *   }
     * })
     */
    upsert<T extends ScheduledNotificationUpsertArgs>(args: SelectSubset<T, ScheduledNotificationUpsertArgs<ExtArgs>>): Prisma__ScheduledNotificationClient<$Result.GetResult<Prisma.$ScheduledNotificationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ScheduledNotifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduledNotificationCountArgs} args - Arguments to filter ScheduledNotifications to count.
     * @example
     * // Count the number of ScheduledNotifications
     * const count = await prisma.scheduledNotification.count({
     *   where: {
     *     // ... the filter for the ScheduledNotifications we want to count
     *   }
     * })
    **/
    count<T extends ScheduledNotificationCountArgs>(
      args?: Subset<T, ScheduledNotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ScheduledNotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ScheduledNotification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduledNotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ScheduledNotificationAggregateArgs>(args: Subset<T, ScheduledNotificationAggregateArgs>): Prisma.PrismaPromise<GetScheduledNotificationAggregateType<T>>

    /**
     * Group by ScheduledNotification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduledNotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ScheduledNotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ScheduledNotificationGroupByArgs['orderBy'] }
        : { orderBy?: ScheduledNotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ScheduledNotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetScheduledNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ScheduledNotification model
   */
  readonly fields: ScheduledNotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ScheduledNotification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ScheduledNotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ScheduledNotification model
   */ 
  interface ScheduledNotificationFieldRefs {
    readonly id: FieldRef<"ScheduledNotification", 'String'>
    readonly userId: FieldRef<"ScheduledNotification", 'String'>
    readonly type: FieldRef<"ScheduledNotification", 'String'>
    readonly title: FieldRef<"ScheduledNotification", 'String'>
    readonly message: FieldRef<"ScheduledNotification", 'String'>
    readonly data: FieldRef<"ScheduledNotification", 'Json'>
    readonly priority: FieldRef<"ScheduledNotification", 'String'>
    readonly scheduledFor: FieldRef<"ScheduledNotification", 'DateTime'>
    readonly status: FieldRef<"ScheduledNotification", 'ScheduledNotificationStatus'>
    readonly sentAt: FieldRef<"ScheduledNotification", 'DateTime'>
    readonly createdAt: FieldRef<"ScheduledNotification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ScheduledNotification findUnique
   */
  export type ScheduledNotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledNotification
     */
    select?: ScheduledNotificationSelect<ExtArgs> | null
    /**
     * Filter, which ScheduledNotification to fetch.
     */
    where: ScheduledNotificationWhereUniqueInput
  }

  /**
   * ScheduledNotification findUniqueOrThrow
   */
  export type ScheduledNotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledNotification
     */
    select?: ScheduledNotificationSelect<ExtArgs> | null
    /**
     * Filter, which ScheduledNotification to fetch.
     */
    where: ScheduledNotificationWhereUniqueInput
  }

  /**
   * ScheduledNotification findFirst
   */
  export type ScheduledNotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledNotification
     */
    select?: ScheduledNotificationSelect<ExtArgs> | null
    /**
     * Filter, which ScheduledNotification to fetch.
     */
    where?: ScheduledNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScheduledNotifications to fetch.
     */
    orderBy?: ScheduledNotificationOrderByWithRelationInput | ScheduledNotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ScheduledNotifications.
     */
    cursor?: ScheduledNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScheduledNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScheduledNotifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ScheduledNotifications.
     */
    distinct?: ScheduledNotificationScalarFieldEnum | ScheduledNotificationScalarFieldEnum[]
  }

  /**
   * ScheduledNotification findFirstOrThrow
   */
  export type ScheduledNotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledNotification
     */
    select?: ScheduledNotificationSelect<ExtArgs> | null
    /**
     * Filter, which ScheduledNotification to fetch.
     */
    where?: ScheduledNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScheduledNotifications to fetch.
     */
    orderBy?: ScheduledNotificationOrderByWithRelationInput | ScheduledNotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ScheduledNotifications.
     */
    cursor?: ScheduledNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScheduledNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScheduledNotifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ScheduledNotifications.
     */
    distinct?: ScheduledNotificationScalarFieldEnum | ScheduledNotificationScalarFieldEnum[]
  }

  /**
   * ScheduledNotification findMany
   */
  export type ScheduledNotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledNotification
     */
    select?: ScheduledNotificationSelect<ExtArgs> | null
    /**
     * Filter, which ScheduledNotifications to fetch.
     */
    where?: ScheduledNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScheduledNotifications to fetch.
     */
    orderBy?: ScheduledNotificationOrderByWithRelationInput | ScheduledNotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ScheduledNotifications.
     */
    cursor?: ScheduledNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScheduledNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScheduledNotifications.
     */
    skip?: number
    distinct?: ScheduledNotificationScalarFieldEnum | ScheduledNotificationScalarFieldEnum[]
  }

  /**
   * ScheduledNotification create
   */
  export type ScheduledNotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledNotification
     */
    select?: ScheduledNotificationSelect<ExtArgs> | null
    /**
     * The data needed to create a ScheduledNotification.
     */
    data: XOR<ScheduledNotificationCreateInput, ScheduledNotificationUncheckedCreateInput>
  }

  /**
   * ScheduledNotification createMany
   */
  export type ScheduledNotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ScheduledNotifications.
     */
    data: ScheduledNotificationCreateManyInput | ScheduledNotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ScheduledNotification createManyAndReturn
   */
  export type ScheduledNotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledNotification
     */
    select?: ScheduledNotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ScheduledNotifications.
     */
    data: ScheduledNotificationCreateManyInput | ScheduledNotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ScheduledNotification update
   */
  export type ScheduledNotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledNotification
     */
    select?: ScheduledNotificationSelect<ExtArgs> | null
    /**
     * The data needed to update a ScheduledNotification.
     */
    data: XOR<ScheduledNotificationUpdateInput, ScheduledNotificationUncheckedUpdateInput>
    /**
     * Choose, which ScheduledNotification to update.
     */
    where: ScheduledNotificationWhereUniqueInput
  }

  /**
   * ScheduledNotification updateMany
   */
  export type ScheduledNotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ScheduledNotifications.
     */
    data: XOR<ScheduledNotificationUpdateManyMutationInput, ScheduledNotificationUncheckedUpdateManyInput>
    /**
     * Filter which ScheduledNotifications to update
     */
    where?: ScheduledNotificationWhereInput
  }

  /**
   * ScheduledNotification upsert
   */
  export type ScheduledNotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledNotification
     */
    select?: ScheduledNotificationSelect<ExtArgs> | null
    /**
     * The filter to search for the ScheduledNotification to update in case it exists.
     */
    where: ScheduledNotificationWhereUniqueInput
    /**
     * In case the ScheduledNotification found by the `where` argument doesn't exist, create a new ScheduledNotification with this data.
     */
    create: XOR<ScheduledNotificationCreateInput, ScheduledNotificationUncheckedCreateInput>
    /**
     * In case the ScheduledNotification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ScheduledNotificationUpdateInput, ScheduledNotificationUncheckedUpdateInput>
  }

  /**
   * ScheduledNotification delete
   */
  export type ScheduledNotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledNotification
     */
    select?: ScheduledNotificationSelect<ExtArgs> | null
    /**
     * Filter which ScheduledNotification to delete.
     */
    where: ScheduledNotificationWhereUniqueInput
  }

  /**
   * ScheduledNotification deleteMany
   */
  export type ScheduledNotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ScheduledNotifications to delete
     */
    where?: ScheduledNotificationWhereInput
  }

  /**
   * ScheduledNotification without action
   */
  export type ScheduledNotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledNotification
     */
    select?: ScheduledNotificationSelect<ExtArgs> | null
  }


  /**
   * Model NotificationLog
   */

  export type AggregateNotificationLog = {
    _count: NotificationLogCountAggregateOutputType | null
    _min: NotificationLogMinAggregateOutputType | null
    _max: NotificationLogMaxAggregateOutputType | null
  }

  export type NotificationLogMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    title: string | null
    message: string | null
    priority: string | null
    sentAt: Date | null
  }

  export type NotificationLogMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    title: string | null
    message: string | null
    priority: string | null
    sentAt: Date | null
  }

  export type NotificationLogCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    title: number
    message: number
    data: number
    priority: number
    sentAt: number
    _all: number
  }


  export type NotificationLogMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    title?: true
    message?: true
    priority?: true
    sentAt?: true
  }

  export type NotificationLogMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    title?: true
    message?: true
    priority?: true
    sentAt?: true
  }

  export type NotificationLogCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    title?: true
    message?: true
    data?: true
    priority?: true
    sentAt?: true
    _all?: true
  }

  export type NotificationLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationLog to aggregate.
     */
    where?: NotificationLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationLogs to fetch.
     */
    orderBy?: NotificationLogOrderByWithRelationInput | NotificationLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NotificationLogs
    **/
    _count?: true | NotificationLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationLogMaxAggregateInputType
  }

  export type GetNotificationLogAggregateType<T extends NotificationLogAggregateArgs> = {
        [P in keyof T & keyof AggregateNotificationLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotificationLog[P]>
      : GetScalarType<T[P], AggregateNotificationLog[P]>
  }




  export type NotificationLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationLogWhereInput
    orderBy?: NotificationLogOrderByWithAggregationInput | NotificationLogOrderByWithAggregationInput[]
    by: NotificationLogScalarFieldEnum[] | NotificationLogScalarFieldEnum
    having?: NotificationLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationLogCountAggregateInputType | true
    _min?: NotificationLogMinAggregateInputType
    _max?: NotificationLogMaxAggregateInputType
  }

  export type NotificationLogGroupByOutputType = {
    id: string
    userId: string
    type: string
    title: string
    message: string
    data: JsonValue | null
    priority: string
    sentAt: Date
    _count: NotificationLogCountAggregateOutputType | null
    _min: NotificationLogMinAggregateOutputType | null
    _max: NotificationLogMaxAggregateOutputType | null
  }

  type GetNotificationLogGroupByPayload<T extends NotificationLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationLogGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationLogGroupByOutputType[P]>
        }
      >
    >


  export type NotificationLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    data?: boolean
    priority?: boolean
    sentAt?: boolean
  }, ExtArgs["result"]["notificationLog"]>

  export type NotificationLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    data?: boolean
    priority?: boolean
    sentAt?: boolean
  }, ExtArgs["result"]["notificationLog"]>

  export type NotificationLogSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    data?: boolean
    priority?: boolean
    sentAt?: boolean
  }


  export type $NotificationLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NotificationLog"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: string
      title: string
      message: string
      data: Prisma.JsonValue | null
      priority: string
      sentAt: Date
    }, ExtArgs["result"]["notificationLog"]>
    composites: {}
  }

  type NotificationLogGetPayload<S extends boolean | null | undefined | NotificationLogDefaultArgs> = $Result.GetResult<Prisma.$NotificationLogPayload, S>

  type NotificationLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NotificationLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NotificationLogCountAggregateInputType | true
    }

  export interface NotificationLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NotificationLog'], meta: { name: 'NotificationLog' } }
    /**
     * Find zero or one NotificationLog that matches the filter.
     * @param {NotificationLogFindUniqueArgs} args - Arguments to find a NotificationLog
     * @example
     * // Get one NotificationLog
     * const notificationLog = await prisma.notificationLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationLogFindUniqueArgs>(args: SelectSubset<T, NotificationLogFindUniqueArgs<ExtArgs>>): Prisma__NotificationLogClient<$Result.GetResult<Prisma.$NotificationLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one NotificationLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NotificationLogFindUniqueOrThrowArgs} args - Arguments to find a NotificationLog
     * @example
     * // Get one NotificationLog
     * const notificationLog = await prisma.notificationLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationLogFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationLogClient<$Result.GetResult<Prisma.$NotificationLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first NotificationLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationLogFindFirstArgs} args - Arguments to find a NotificationLog
     * @example
     * // Get one NotificationLog
     * const notificationLog = await prisma.notificationLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationLogFindFirstArgs>(args?: SelectSubset<T, NotificationLogFindFirstArgs<ExtArgs>>): Prisma__NotificationLogClient<$Result.GetResult<Prisma.$NotificationLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first NotificationLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationLogFindFirstOrThrowArgs} args - Arguments to find a NotificationLog
     * @example
     * // Get one NotificationLog
     * const notificationLog = await prisma.notificationLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationLogFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationLogClient<$Result.GetResult<Prisma.$NotificationLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more NotificationLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NotificationLogs
     * const notificationLogs = await prisma.notificationLog.findMany()
     * 
     * // Get first 10 NotificationLogs
     * const notificationLogs = await prisma.notificationLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationLogWithIdOnly = await prisma.notificationLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationLogFindManyArgs>(args?: SelectSubset<T, NotificationLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a NotificationLog.
     * @param {NotificationLogCreateArgs} args - Arguments to create a NotificationLog.
     * @example
     * // Create one NotificationLog
     * const NotificationLog = await prisma.notificationLog.create({
     *   data: {
     *     // ... data to create a NotificationLog
     *   }
     * })
     * 
     */
    create<T extends NotificationLogCreateArgs>(args: SelectSubset<T, NotificationLogCreateArgs<ExtArgs>>): Prisma__NotificationLogClient<$Result.GetResult<Prisma.$NotificationLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many NotificationLogs.
     * @param {NotificationLogCreateManyArgs} args - Arguments to create many NotificationLogs.
     * @example
     * // Create many NotificationLogs
     * const notificationLog = await prisma.notificationLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationLogCreateManyArgs>(args?: SelectSubset<T, NotificationLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NotificationLogs and returns the data saved in the database.
     * @param {NotificationLogCreateManyAndReturnArgs} args - Arguments to create many NotificationLogs.
     * @example
     * // Create many NotificationLogs
     * const notificationLog = await prisma.notificationLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NotificationLogs and only return the `id`
     * const notificationLogWithIdOnly = await prisma.notificationLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationLogCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationLogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a NotificationLog.
     * @param {NotificationLogDeleteArgs} args - Arguments to delete one NotificationLog.
     * @example
     * // Delete one NotificationLog
     * const NotificationLog = await prisma.notificationLog.delete({
     *   where: {
     *     // ... filter to delete one NotificationLog
     *   }
     * })
     * 
     */
    delete<T extends NotificationLogDeleteArgs>(args: SelectSubset<T, NotificationLogDeleteArgs<ExtArgs>>): Prisma__NotificationLogClient<$Result.GetResult<Prisma.$NotificationLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one NotificationLog.
     * @param {NotificationLogUpdateArgs} args - Arguments to update one NotificationLog.
     * @example
     * // Update one NotificationLog
     * const notificationLog = await prisma.notificationLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationLogUpdateArgs>(args: SelectSubset<T, NotificationLogUpdateArgs<ExtArgs>>): Prisma__NotificationLogClient<$Result.GetResult<Prisma.$NotificationLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more NotificationLogs.
     * @param {NotificationLogDeleteManyArgs} args - Arguments to filter NotificationLogs to delete.
     * @example
     * // Delete a few NotificationLogs
     * const { count } = await prisma.notificationLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationLogDeleteManyArgs>(args?: SelectSubset<T, NotificationLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NotificationLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NotificationLogs
     * const notificationLog = await prisma.notificationLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationLogUpdateManyArgs>(args: SelectSubset<T, NotificationLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one NotificationLog.
     * @param {NotificationLogUpsertArgs} args - Arguments to update or create a NotificationLog.
     * @example
     * // Update or create a NotificationLog
     * const notificationLog = await prisma.notificationLog.upsert({
     *   create: {
     *     // ... data to create a NotificationLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NotificationLog we want to update
     *   }
     * })
     */
    upsert<T extends NotificationLogUpsertArgs>(args: SelectSubset<T, NotificationLogUpsertArgs<ExtArgs>>): Prisma__NotificationLogClient<$Result.GetResult<Prisma.$NotificationLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of NotificationLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationLogCountArgs} args - Arguments to filter NotificationLogs to count.
     * @example
     * // Count the number of NotificationLogs
     * const count = await prisma.notificationLog.count({
     *   where: {
     *     // ... the filter for the NotificationLogs we want to count
     *   }
     * })
    **/
    count<T extends NotificationLogCountArgs>(
      args?: Subset<T, NotificationLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NotificationLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationLogAggregateArgs>(args: Subset<T, NotificationLogAggregateArgs>): Prisma.PrismaPromise<GetNotificationLogAggregateType<T>>

    /**
     * Group by NotificationLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationLogGroupByArgs['orderBy'] }
        : { orderBy?: NotificationLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NotificationLog model
   */
  readonly fields: NotificationLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NotificationLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NotificationLog model
   */ 
  interface NotificationLogFieldRefs {
    readonly id: FieldRef<"NotificationLog", 'String'>
    readonly userId: FieldRef<"NotificationLog", 'String'>
    readonly type: FieldRef<"NotificationLog", 'String'>
    readonly title: FieldRef<"NotificationLog", 'String'>
    readonly message: FieldRef<"NotificationLog", 'String'>
    readonly data: FieldRef<"NotificationLog", 'Json'>
    readonly priority: FieldRef<"NotificationLog", 'String'>
    readonly sentAt: FieldRef<"NotificationLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * NotificationLog findUnique
   */
  export type NotificationLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationLog
     */
    select?: NotificationLogSelect<ExtArgs> | null
    /**
     * Filter, which NotificationLog to fetch.
     */
    where: NotificationLogWhereUniqueInput
  }

  /**
   * NotificationLog findUniqueOrThrow
   */
  export type NotificationLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationLog
     */
    select?: NotificationLogSelect<ExtArgs> | null
    /**
     * Filter, which NotificationLog to fetch.
     */
    where: NotificationLogWhereUniqueInput
  }

  /**
   * NotificationLog findFirst
   */
  export type NotificationLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationLog
     */
    select?: NotificationLogSelect<ExtArgs> | null
    /**
     * Filter, which NotificationLog to fetch.
     */
    where?: NotificationLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationLogs to fetch.
     */
    orderBy?: NotificationLogOrderByWithRelationInput | NotificationLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationLogs.
     */
    cursor?: NotificationLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationLogs.
     */
    distinct?: NotificationLogScalarFieldEnum | NotificationLogScalarFieldEnum[]
  }

  /**
   * NotificationLog findFirstOrThrow
   */
  export type NotificationLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationLog
     */
    select?: NotificationLogSelect<ExtArgs> | null
    /**
     * Filter, which NotificationLog to fetch.
     */
    where?: NotificationLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationLogs to fetch.
     */
    orderBy?: NotificationLogOrderByWithRelationInput | NotificationLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationLogs.
     */
    cursor?: NotificationLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationLogs.
     */
    distinct?: NotificationLogScalarFieldEnum | NotificationLogScalarFieldEnum[]
  }

  /**
   * NotificationLog findMany
   */
  export type NotificationLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationLog
     */
    select?: NotificationLogSelect<ExtArgs> | null
    /**
     * Filter, which NotificationLogs to fetch.
     */
    where?: NotificationLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationLogs to fetch.
     */
    orderBy?: NotificationLogOrderByWithRelationInput | NotificationLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NotificationLogs.
     */
    cursor?: NotificationLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationLogs.
     */
    skip?: number
    distinct?: NotificationLogScalarFieldEnum | NotificationLogScalarFieldEnum[]
  }

  /**
   * NotificationLog create
   */
  export type NotificationLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationLog
     */
    select?: NotificationLogSelect<ExtArgs> | null
    /**
     * The data needed to create a NotificationLog.
     */
    data: XOR<NotificationLogCreateInput, NotificationLogUncheckedCreateInput>
  }

  /**
   * NotificationLog createMany
   */
  export type NotificationLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NotificationLogs.
     */
    data: NotificationLogCreateManyInput | NotificationLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NotificationLog createManyAndReturn
   */
  export type NotificationLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationLog
     */
    select?: NotificationLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many NotificationLogs.
     */
    data: NotificationLogCreateManyInput | NotificationLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NotificationLog update
   */
  export type NotificationLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationLog
     */
    select?: NotificationLogSelect<ExtArgs> | null
    /**
     * The data needed to update a NotificationLog.
     */
    data: XOR<NotificationLogUpdateInput, NotificationLogUncheckedUpdateInput>
    /**
     * Choose, which NotificationLog to update.
     */
    where: NotificationLogWhereUniqueInput
  }

  /**
   * NotificationLog updateMany
   */
  export type NotificationLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NotificationLogs.
     */
    data: XOR<NotificationLogUpdateManyMutationInput, NotificationLogUncheckedUpdateManyInput>
    /**
     * Filter which NotificationLogs to update
     */
    where?: NotificationLogWhereInput
  }

  /**
   * NotificationLog upsert
   */
  export type NotificationLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationLog
     */
    select?: NotificationLogSelect<ExtArgs> | null
    /**
     * The filter to search for the NotificationLog to update in case it exists.
     */
    where: NotificationLogWhereUniqueInput
    /**
     * In case the NotificationLog found by the `where` argument doesn't exist, create a new NotificationLog with this data.
     */
    create: XOR<NotificationLogCreateInput, NotificationLogUncheckedCreateInput>
    /**
     * In case the NotificationLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationLogUpdateInput, NotificationLogUncheckedUpdateInput>
  }

  /**
   * NotificationLog delete
   */
  export type NotificationLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationLog
     */
    select?: NotificationLogSelect<ExtArgs> | null
    /**
     * Filter which NotificationLog to delete.
     */
    where: NotificationLogWhereUniqueInput
  }

  /**
   * NotificationLog deleteMany
   */
  export type NotificationLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationLogs to delete
     */
    where?: NotificationLogWhereInput
  }

  /**
   * NotificationLog without action
   */
  export type NotificationLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationLog
     */
    select?: NotificationLogSelect<ExtArgs> | null
  }


  /**
   * Model UserNotificationPreferences
   */

  export type AggregateUserNotificationPreferences = {
    _count: UserNotificationPreferencesCountAggregateOutputType | null
    _min: UserNotificationPreferencesMinAggregateOutputType | null
    _max: UserNotificationPreferencesMaxAggregateOutputType | null
  }

  export type UserNotificationPreferencesMinAggregateOutputType = {
    id: string | null
    userId: string | null
    emailEnabled: boolean | null
    smsEnabled: boolean | null
    inAppEnabled: boolean | null
    pushEnabled: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserNotificationPreferencesMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    emailEnabled: boolean | null
    smsEnabled: boolean | null
    inAppEnabled: boolean | null
    pushEnabled: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserNotificationPreferencesCountAggregateOutputType = {
    id: number
    userId: number
    emailEnabled: number
    smsEnabled: number
    inAppEnabled: number
    pushEnabled: number
    quietHours: number
    notificationTypes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserNotificationPreferencesMinAggregateInputType = {
    id?: true
    userId?: true
    emailEnabled?: true
    smsEnabled?: true
    inAppEnabled?: true
    pushEnabled?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserNotificationPreferencesMaxAggregateInputType = {
    id?: true
    userId?: true
    emailEnabled?: true
    smsEnabled?: true
    inAppEnabled?: true
    pushEnabled?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserNotificationPreferencesCountAggregateInputType = {
    id?: true
    userId?: true
    emailEnabled?: true
    smsEnabled?: true
    inAppEnabled?: true
    pushEnabled?: true
    quietHours?: true
    notificationTypes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserNotificationPreferencesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserNotificationPreferences to aggregate.
     */
    where?: UserNotificationPreferencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserNotificationPreferences to fetch.
     */
    orderBy?: UserNotificationPreferencesOrderByWithRelationInput | UserNotificationPreferencesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserNotificationPreferencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserNotificationPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserNotificationPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserNotificationPreferences
    **/
    _count?: true | UserNotificationPreferencesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserNotificationPreferencesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserNotificationPreferencesMaxAggregateInputType
  }

  export type GetUserNotificationPreferencesAggregateType<T extends UserNotificationPreferencesAggregateArgs> = {
        [P in keyof T & keyof AggregateUserNotificationPreferences]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserNotificationPreferences[P]>
      : GetScalarType<T[P], AggregateUserNotificationPreferences[P]>
  }




  export type UserNotificationPreferencesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserNotificationPreferencesWhereInput
    orderBy?: UserNotificationPreferencesOrderByWithAggregationInput | UserNotificationPreferencesOrderByWithAggregationInput[]
    by: UserNotificationPreferencesScalarFieldEnum[] | UserNotificationPreferencesScalarFieldEnum
    having?: UserNotificationPreferencesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserNotificationPreferencesCountAggregateInputType | true
    _min?: UserNotificationPreferencesMinAggregateInputType
    _max?: UserNotificationPreferencesMaxAggregateInputType
  }

  export type UserNotificationPreferencesGroupByOutputType = {
    id: string
    userId: string
    emailEnabled: boolean
    smsEnabled: boolean
    inAppEnabled: boolean
    pushEnabled: boolean
    quietHours: JsonValue | null
    notificationTypes: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: UserNotificationPreferencesCountAggregateOutputType | null
    _min: UserNotificationPreferencesMinAggregateOutputType | null
    _max: UserNotificationPreferencesMaxAggregateOutputType | null
  }

  type GetUserNotificationPreferencesGroupByPayload<T extends UserNotificationPreferencesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserNotificationPreferencesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserNotificationPreferencesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserNotificationPreferencesGroupByOutputType[P]>
            : GetScalarType<T[P], UserNotificationPreferencesGroupByOutputType[P]>
        }
      >
    >


  export type UserNotificationPreferencesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    emailEnabled?: boolean
    smsEnabled?: boolean
    inAppEnabled?: boolean
    pushEnabled?: boolean
    quietHours?: boolean
    notificationTypes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["userNotificationPreferences"]>

  export type UserNotificationPreferencesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    emailEnabled?: boolean
    smsEnabled?: boolean
    inAppEnabled?: boolean
    pushEnabled?: boolean
    quietHours?: boolean
    notificationTypes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["userNotificationPreferences"]>

  export type UserNotificationPreferencesSelectScalar = {
    id?: boolean
    userId?: boolean
    emailEnabled?: boolean
    smsEnabled?: boolean
    inAppEnabled?: boolean
    pushEnabled?: boolean
    quietHours?: boolean
    notificationTypes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $UserNotificationPreferencesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserNotificationPreferences"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      emailEnabled: boolean
      smsEnabled: boolean
      inAppEnabled: boolean
      pushEnabled: boolean
      quietHours: Prisma.JsonValue | null
      notificationTypes: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["userNotificationPreferences"]>
    composites: {}
  }

  type UserNotificationPreferencesGetPayload<S extends boolean | null | undefined | UserNotificationPreferencesDefaultArgs> = $Result.GetResult<Prisma.$UserNotificationPreferencesPayload, S>

  type UserNotificationPreferencesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserNotificationPreferencesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserNotificationPreferencesCountAggregateInputType | true
    }

  export interface UserNotificationPreferencesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserNotificationPreferences'], meta: { name: 'UserNotificationPreferences' } }
    /**
     * Find zero or one UserNotificationPreferences that matches the filter.
     * @param {UserNotificationPreferencesFindUniqueArgs} args - Arguments to find a UserNotificationPreferences
     * @example
     * // Get one UserNotificationPreferences
     * const userNotificationPreferences = await prisma.userNotificationPreferences.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserNotificationPreferencesFindUniqueArgs>(args: SelectSubset<T, UserNotificationPreferencesFindUniqueArgs<ExtArgs>>): Prisma__UserNotificationPreferencesClient<$Result.GetResult<Prisma.$UserNotificationPreferencesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UserNotificationPreferences that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserNotificationPreferencesFindUniqueOrThrowArgs} args - Arguments to find a UserNotificationPreferences
     * @example
     * // Get one UserNotificationPreferences
     * const userNotificationPreferences = await prisma.userNotificationPreferences.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserNotificationPreferencesFindUniqueOrThrowArgs>(args: SelectSubset<T, UserNotificationPreferencesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserNotificationPreferencesClient<$Result.GetResult<Prisma.$UserNotificationPreferencesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UserNotificationPreferences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserNotificationPreferencesFindFirstArgs} args - Arguments to find a UserNotificationPreferences
     * @example
     * // Get one UserNotificationPreferences
     * const userNotificationPreferences = await prisma.userNotificationPreferences.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserNotificationPreferencesFindFirstArgs>(args?: SelectSubset<T, UserNotificationPreferencesFindFirstArgs<ExtArgs>>): Prisma__UserNotificationPreferencesClient<$Result.GetResult<Prisma.$UserNotificationPreferencesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UserNotificationPreferences that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserNotificationPreferencesFindFirstOrThrowArgs} args - Arguments to find a UserNotificationPreferences
     * @example
     * // Get one UserNotificationPreferences
     * const userNotificationPreferences = await prisma.userNotificationPreferences.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserNotificationPreferencesFindFirstOrThrowArgs>(args?: SelectSubset<T, UserNotificationPreferencesFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserNotificationPreferencesClient<$Result.GetResult<Prisma.$UserNotificationPreferencesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UserNotificationPreferences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserNotificationPreferencesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserNotificationPreferences
     * const userNotificationPreferences = await prisma.userNotificationPreferences.findMany()
     * 
     * // Get first 10 UserNotificationPreferences
     * const userNotificationPreferences = await prisma.userNotificationPreferences.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userNotificationPreferencesWithIdOnly = await prisma.userNotificationPreferences.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserNotificationPreferencesFindManyArgs>(args?: SelectSubset<T, UserNotificationPreferencesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserNotificationPreferencesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UserNotificationPreferences.
     * @param {UserNotificationPreferencesCreateArgs} args - Arguments to create a UserNotificationPreferences.
     * @example
     * // Create one UserNotificationPreferences
     * const UserNotificationPreferences = await prisma.userNotificationPreferences.create({
     *   data: {
     *     // ... data to create a UserNotificationPreferences
     *   }
     * })
     * 
     */
    create<T extends UserNotificationPreferencesCreateArgs>(args: SelectSubset<T, UserNotificationPreferencesCreateArgs<ExtArgs>>): Prisma__UserNotificationPreferencesClient<$Result.GetResult<Prisma.$UserNotificationPreferencesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UserNotificationPreferences.
     * @param {UserNotificationPreferencesCreateManyArgs} args - Arguments to create many UserNotificationPreferences.
     * @example
     * // Create many UserNotificationPreferences
     * const userNotificationPreferences = await prisma.userNotificationPreferences.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserNotificationPreferencesCreateManyArgs>(args?: SelectSubset<T, UserNotificationPreferencesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserNotificationPreferences and returns the data saved in the database.
     * @param {UserNotificationPreferencesCreateManyAndReturnArgs} args - Arguments to create many UserNotificationPreferences.
     * @example
     * // Create many UserNotificationPreferences
     * const userNotificationPreferences = await prisma.userNotificationPreferences.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserNotificationPreferences and only return the `id`
     * const userNotificationPreferencesWithIdOnly = await prisma.userNotificationPreferences.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserNotificationPreferencesCreateManyAndReturnArgs>(args?: SelectSubset<T, UserNotificationPreferencesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserNotificationPreferencesPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a UserNotificationPreferences.
     * @param {UserNotificationPreferencesDeleteArgs} args - Arguments to delete one UserNotificationPreferences.
     * @example
     * // Delete one UserNotificationPreferences
     * const UserNotificationPreferences = await prisma.userNotificationPreferences.delete({
     *   where: {
     *     // ... filter to delete one UserNotificationPreferences
     *   }
     * })
     * 
     */
    delete<T extends UserNotificationPreferencesDeleteArgs>(args: SelectSubset<T, UserNotificationPreferencesDeleteArgs<ExtArgs>>): Prisma__UserNotificationPreferencesClient<$Result.GetResult<Prisma.$UserNotificationPreferencesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UserNotificationPreferences.
     * @param {UserNotificationPreferencesUpdateArgs} args - Arguments to update one UserNotificationPreferences.
     * @example
     * // Update one UserNotificationPreferences
     * const userNotificationPreferences = await prisma.userNotificationPreferences.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserNotificationPreferencesUpdateArgs>(args: SelectSubset<T, UserNotificationPreferencesUpdateArgs<ExtArgs>>): Prisma__UserNotificationPreferencesClient<$Result.GetResult<Prisma.$UserNotificationPreferencesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UserNotificationPreferences.
     * @param {UserNotificationPreferencesDeleteManyArgs} args - Arguments to filter UserNotificationPreferences to delete.
     * @example
     * // Delete a few UserNotificationPreferences
     * const { count } = await prisma.userNotificationPreferences.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserNotificationPreferencesDeleteManyArgs>(args?: SelectSubset<T, UserNotificationPreferencesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserNotificationPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserNotificationPreferencesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserNotificationPreferences
     * const userNotificationPreferences = await prisma.userNotificationPreferences.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserNotificationPreferencesUpdateManyArgs>(args: SelectSubset<T, UserNotificationPreferencesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserNotificationPreferences.
     * @param {UserNotificationPreferencesUpsertArgs} args - Arguments to update or create a UserNotificationPreferences.
     * @example
     * // Update or create a UserNotificationPreferences
     * const userNotificationPreferences = await prisma.userNotificationPreferences.upsert({
     *   create: {
     *     // ... data to create a UserNotificationPreferences
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserNotificationPreferences we want to update
     *   }
     * })
     */
    upsert<T extends UserNotificationPreferencesUpsertArgs>(args: SelectSubset<T, UserNotificationPreferencesUpsertArgs<ExtArgs>>): Prisma__UserNotificationPreferencesClient<$Result.GetResult<Prisma.$UserNotificationPreferencesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UserNotificationPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserNotificationPreferencesCountArgs} args - Arguments to filter UserNotificationPreferences to count.
     * @example
     * // Count the number of UserNotificationPreferences
     * const count = await prisma.userNotificationPreferences.count({
     *   where: {
     *     // ... the filter for the UserNotificationPreferences we want to count
     *   }
     * })
    **/
    count<T extends UserNotificationPreferencesCountArgs>(
      args?: Subset<T, UserNotificationPreferencesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserNotificationPreferencesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserNotificationPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserNotificationPreferencesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserNotificationPreferencesAggregateArgs>(args: Subset<T, UserNotificationPreferencesAggregateArgs>): Prisma.PrismaPromise<GetUserNotificationPreferencesAggregateType<T>>

    /**
     * Group by UserNotificationPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserNotificationPreferencesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserNotificationPreferencesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserNotificationPreferencesGroupByArgs['orderBy'] }
        : { orderBy?: UserNotificationPreferencesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserNotificationPreferencesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserNotificationPreferencesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserNotificationPreferences model
   */
  readonly fields: UserNotificationPreferencesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserNotificationPreferences.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserNotificationPreferencesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserNotificationPreferences model
   */ 
  interface UserNotificationPreferencesFieldRefs {
    readonly id: FieldRef<"UserNotificationPreferences", 'String'>
    readonly userId: FieldRef<"UserNotificationPreferences", 'String'>
    readonly emailEnabled: FieldRef<"UserNotificationPreferences", 'Boolean'>
    readonly smsEnabled: FieldRef<"UserNotificationPreferences", 'Boolean'>
    readonly inAppEnabled: FieldRef<"UserNotificationPreferences", 'Boolean'>
    readonly pushEnabled: FieldRef<"UserNotificationPreferences", 'Boolean'>
    readonly quietHours: FieldRef<"UserNotificationPreferences", 'Json'>
    readonly notificationTypes: FieldRef<"UserNotificationPreferences", 'Json'>
    readonly createdAt: FieldRef<"UserNotificationPreferences", 'DateTime'>
    readonly updatedAt: FieldRef<"UserNotificationPreferences", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserNotificationPreferences findUnique
   */
  export type UserNotificationPreferencesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserNotificationPreferences
     */
    select?: UserNotificationPreferencesSelect<ExtArgs> | null
    /**
     * Filter, which UserNotificationPreferences to fetch.
     */
    where: UserNotificationPreferencesWhereUniqueInput
  }

  /**
   * UserNotificationPreferences findUniqueOrThrow
   */
  export type UserNotificationPreferencesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserNotificationPreferences
     */
    select?: UserNotificationPreferencesSelect<ExtArgs> | null
    /**
     * Filter, which UserNotificationPreferences to fetch.
     */
    where: UserNotificationPreferencesWhereUniqueInput
  }

  /**
   * UserNotificationPreferences findFirst
   */
  export type UserNotificationPreferencesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserNotificationPreferences
     */
    select?: UserNotificationPreferencesSelect<ExtArgs> | null
    /**
     * Filter, which UserNotificationPreferences to fetch.
     */
    where?: UserNotificationPreferencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserNotificationPreferences to fetch.
     */
    orderBy?: UserNotificationPreferencesOrderByWithRelationInput | UserNotificationPreferencesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserNotificationPreferences.
     */
    cursor?: UserNotificationPreferencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserNotificationPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserNotificationPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserNotificationPreferences.
     */
    distinct?: UserNotificationPreferencesScalarFieldEnum | UserNotificationPreferencesScalarFieldEnum[]
  }

  /**
   * UserNotificationPreferences findFirstOrThrow
   */
  export type UserNotificationPreferencesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserNotificationPreferences
     */
    select?: UserNotificationPreferencesSelect<ExtArgs> | null
    /**
     * Filter, which UserNotificationPreferences to fetch.
     */
    where?: UserNotificationPreferencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserNotificationPreferences to fetch.
     */
    orderBy?: UserNotificationPreferencesOrderByWithRelationInput | UserNotificationPreferencesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserNotificationPreferences.
     */
    cursor?: UserNotificationPreferencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserNotificationPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserNotificationPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserNotificationPreferences.
     */
    distinct?: UserNotificationPreferencesScalarFieldEnum | UserNotificationPreferencesScalarFieldEnum[]
  }

  /**
   * UserNotificationPreferences findMany
   */
  export type UserNotificationPreferencesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserNotificationPreferences
     */
    select?: UserNotificationPreferencesSelect<ExtArgs> | null
    /**
     * Filter, which UserNotificationPreferences to fetch.
     */
    where?: UserNotificationPreferencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserNotificationPreferences to fetch.
     */
    orderBy?: UserNotificationPreferencesOrderByWithRelationInput | UserNotificationPreferencesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserNotificationPreferences.
     */
    cursor?: UserNotificationPreferencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserNotificationPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserNotificationPreferences.
     */
    skip?: number
    distinct?: UserNotificationPreferencesScalarFieldEnum | UserNotificationPreferencesScalarFieldEnum[]
  }

  /**
   * UserNotificationPreferences create
   */
  export type UserNotificationPreferencesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserNotificationPreferences
     */
    select?: UserNotificationPreferencesSelect<ExtArgs> | null
    /**
     * The data needed to create a UserNotificationPreferences.
     */
    data: XOR<UserNotificationPreferencesCreateInput, UserNotificationPreferencesUncheckedCreateInput>
  }

  /**
   * UserNotificationPreferences createMany
   */
  export type UserNotificationPreferencesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserNotificationPreferences.
     */
    data: UserNotificationPreferencesCreateManyInput | UserNotificationPreferencesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserNotificationPreferences createManyAndReturn
   */
  export type UserNotificationPreferencesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserNotificationPreferences
     */
    select?: UserNotificationPreferencesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many UserNotificationPreferences.
     */
    data: UserNotificationPreferencesCreateManyInput | UserNotificationPreferencesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserNotificationPreferences update
   */
  export type UserNotificationPreferencesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserNotificationPreferences
     */
    select?: UserNotificationPreferencesSelect<ExtArgs> | null
    /**
     * The data needed to update a UserNotificationPreferences.
     */
    data: XOR<UserNotificationPreferencesUpdateInput, UserNotificationPreferencesUncheckedUpdateInput>
    /**
     * Choose, which UserNotificationPreferences to update.
     */
    where: UserNotificationPreferencesWhereUniqueInput
  }

  /**
   * UserNotificationPreferences updateMany
   */
  export type UserNotificationPreferencesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserNotificationPreferences.
     */
    data: XOR<UserNotificationPreferencesUpdateManyMutationInput, UserNotificationPreferencesUncheckedUpdateManyInput>
    /**
     * Filter which UserNotificationPreferences to update
     */
    where?: UserNotificationPreferencesWhereInput
  }

  /**
   * UserNotificationPreferences upsert
   */
  export type UserNotificationPreferencesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserNotificationPreferences
     */
    select?: UserNotificationPreferencesSelect<ExtArgs> | null
    /**
     * The filter to search for the UserNotificationPreferences to update in case it exists.
     */
    where: UserNotificationPreferencesWhereUniqueInput
    /**
     * In case the UserNotificationPreferences found by the `where` argument doesn't exist, create a new UserNotificationPreferences with this data.
     */
    create: XOR<UserNotificationPreferencesCreateInput, UserNotificationPreferencesUncheckedCreateInput>
    /**
     * In case the UserNotificationPreferences was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserNotificationPreferencesUpdateInput, UserNotificationPreferencesUncheckedUpdateInput>
  }

  /**
   * UserNotificationPreferences delete
   */
  export type UserNotificationPreferencesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserNotificationPreferences
     */
    select?: UserNotificationPreferencesSelect<ExtArgs> | null
    /**
     * Filter which UserNotificationPreferences to delete.
     */
    where: UserNotificationPreferencesWhereUniqueInput
  }

  /**
   * UserNotificationPreferences deleteMany
   */
  export type UserNotificationPreferencesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserNotificationPreferences to delete
     */
    where?: UserNotificationPreferencesWhereInput
  }

  /**
   * UserNotificationPreferences without action
   */
  export type UserNotificationPreferencesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserNotificationPreferences
     */
    select?: UserNotificationPreferencesSelect<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    password: 'password',
    firstName: 'firstName',
    lastName: 'lastName',
    userType: 'userType',
    phone: 'phone',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const StudentScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    kajabiUserId: 'kajabiUserId',
    courseCompletionDate: 'courseCompletionDate',
    totalVerifiedHours: 'totalVerifiedHours',
    totalVideoHours: 'totalVideoHours',
    certificationStatus: 'certificationStatus',
    preferredSessionLength: 'preferredSessionLength',
    consultationPreferences: 'consultationPreferences',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StudentScalarFieldEnum = (typeof StudentScalarFieldEnum)[keyof typeof StudentScalarFieldEnum]


  export const ConsultantScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    bio: 'bio',
    specialties: 'specialties',
    hourlyRate: 'hourlyRate',
    isActive: 'isActive',
    timezone: 'timezone',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ConsultantScalarFieldEnum = (typeof ConsultantScalarFieldEnum)[keyof typeof ConsultantScalarFieldEnum]


  export const AdminScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    role: 'role',
    permissions: 'permissions',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AdminScalarFieldEnum = (typeof AdminScalarFieldEnum)[keyof typeof AdminScalarFieldEnum]


  export const ConsultationSessionScalarFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    consultantId: 'consultantId',
    scheduledStart: 'scheduledStart',
    scheduledEnd: 'scheduledEnd',
    actualStart: 'actualStart',
    actualEnd: 'actualEnd',
    status: 'status',
    sessionType: 'sessionType',
    studentVerifiedAt: 'studentVerifiedAt',
    consultantVerifiedAt: 'consultantVerifiedAt',
    studentNotes: 'studentNotes',
    consultantNotes: 'consultantNotes',
    sessionRating: 'sessionRating',
    technicalIssuesReported: 'technicalIssuesReported',
    makeupSessionFor: 'makeupSessionFor',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ConsultationSessionScalarFieldEnum = (typeof ConsultationSessionScalarFieldEnum)[keyof typeof ConsultationSessionScalarFieldEnum]


  export const VideoSessionScalarFieldEnum: {
    id: 'id',
    consultationSessionId: 'consultationSessionId',
    roomId: 'roomId',
    recordingEnabled: 'recordingEnabled',
    recordingUrl: 'recordingUrl',
    recordingDurationSeconds: 'recordingDurationSeconds',
    videoQuality: 'videoQuality',
    connectionQualityAvg: 'connectionQualityAvg',
    bandwidthUsageMb: 'bandwidthUsageMb',
    technicalIssues: 'technicalIssues',
    sessionMetadata: 'sessionMetadata',
    createdAt: 'createdAt'
  };

  export type VideoSessionScalarFieldEnum = (typeof VideoSessionScalarFieldEnum)[keyof typeof VideoSessionScalarFieldEnum]


  export const VideoParticipantScalarFieldEnum: {
    id: 'id',
    videoSessionId: 'videoSessionId',
    userId: 'userId',
    userType: 'userType',
    joinTime: 'joinTime',
    leaveTime: 'leaveTime',
    totalDurationSeconds: 'totalDurationSeconds',
    audioQualityAvg: 'audioQualityAvg',
    videoQualityAvg: 'videoQualityAvg',
    screenShareDurationSeconds: 'screenShareDurationSeconds',
    chatMessagesCount: 'chatMessagesCount',
    connectionInterruptions: 'connectionInterruptions',
    createdAt: 'createdAt'
  };

  export type VideoParticipantScalarFieldEnum = (typeof VideoParticipantScalarFieldEnum)[keyof typeof VideoParticipantScalarFieldEnum]


  export const ConsultantAvailabilityScalarFieldEnum: {
    id: 'id',
    consultantId: 'consultantId',
    availabilityType: 'availabilityType',
    dayOfWeek: 'dayOfWeek',
    specificDate: 'specificDate',
    startTime: 'startTime',
    endTime: 'endTime',
    maxSessions: 'maxSessions',
    bufferMinutes: 'bufferMinutes',
    isAvailable: 'isAvailable',
    bookingWindowDays: 'bookingWindowDays',
    minimumNoticeHours: 'minimumNoticeHours',
    autoApprove: 'autoApprove',
    timezone: 'timezone',
    recurringPattern: 'recurringPattern',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ConsultantAvailabilityScalarFieldEnum = (typeof ConsultantAvailabilityScalarFieldEnum)[keyof typeof ConsultantAvailabilityScalarFieldEnum]


  export const StudentDocumentScalarFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    documentType: 'documentType',
    fileName: 'fileName',
    fileSizeBytes: 'fileSizeBytes',
    filePath: 'filePath',
    mimeType: 'mimeType',
    extractedText: 'extractedText',
    uploadTimestamp: 'uploadTimestamp',
    reviewStatus: 'reviewStatus',
    reviewedBy: 'reviewedBy',
    reviewedAt: 'reviewedAt',
    reviewNotes: 'reviewNotes',
    versionNumber: 'versionNumber',
    replacesDocumentId: 'replacesDocumentId',
    autoValidationScore: 'autoValidationScore',
    requiresManualReview: 'requiresManualReview',
    createdAt: 'createdAt'
  };

  export type StudentDocumentScalarFieldEnum = (typeof StudentDocumentScalarFieldEnum)[keyof typeof StudentDocumentScalarFieldEnum]


  export const SessionHistoryScalarFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    sessionDate: 'sessionDate',
    sessionDuration: 'sessionDuration',
    consultantId: 'consultantId',
    sessionType: 'sessionType',
    status: 'status',
    rating: 'rating',
    createdAt: 'createdAt'
  };

  export type SessionHistoryScalarFieldEnum = (typeof SessionHistoryScalarFieldEnum)[keyof typeof SessionHistoryScalarFieldEnum]


  export const ConsultantPaymentScalarFieldEnum: {
    id: 'id',
    consultantId: 'consultantId',
    paymentPeriod: 'paymentPeriod',
    totalHours: 'totalHours',
    hourlyRate: 'hourlyRate',
    totalAmount: 'totalAmount',
    paymentStatus: 'paymentStatus',
    paymentDate: 'paymentDate',
    sessionBreakdown: 'sessionBreakdown',
    createdAt: 'createdAt'
  };

  export type ConsultantPaymentScalarFieldEnum = (typeof ConsultantPaymentScalarFieldEnum)[keyof typeof ConsultantPaymentScalarFieldEnum]


  export const SystemHealthMetricScalarFieldEnum: {
    id: 'id',
    metricType: 'metricType',
    metricValue: 'metricValue',
    metricUnit: 'metricUnit',
    timestamp: 'timestamp',
    additionalData: 'additionalData',
    createdAt: 'createdAt'
  };

  export type SystemHealthMetricScalarFieldEnum = (typeof SystemHealthMetricScalarFieldEnum)[keyof typeof SystemHealthMetricScalarFieldEnum]


  export const InAppNotificationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    title: 'title',
    message: 'message',
    type: 'type',
    data: 'data',
    read: 'read',
    createdAt: 'createdAt'
  };

  export type InAppNotificationScalarFieldEnum = (typeof InAppNotificationScalarFieldEnum)[keyof typeof InAppNotificationScalarFieldEnum]


  export const ScheduledNotificationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    title: 'title',
    message: 'message',
    data: 'data',
    priority: 'priority',
    scheduledFor: 'scheduledFor',
    status: 'status',
    sentAt: 'sentAt',
    createdAt: 'createdAt'
  };

  export type ScheduledNotificationScalarFieldEnum = (typeof ScheduledNotificationScalarFieldEnum)[keyof typeof ScheduledNotificationScalarFieldEnum]


  export const NotificationLogScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    title: 'title',
    message: 'message',
    data: 'data',
    priority: 'priority',
    sentAt: 'sentAt'
  };

  export type NotificationLogScalarFieldEnum = (typeof NotificationLogScalarFieldEnum)[keyof typeof NotificationLogScalarFieldEnum]


  export const UserNotificationPreferencesScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    emailEnabled: 'emailEnabled',
    smsEnabled: 'smsEnabled',
    inAppEnabled: 'inAppEnabled',
    pushEnabled: 'pushEnabled',
    quietHours: 'quietHours',
    notificationTypes: 'notificationTypes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserNotificationPreferencesScalarFieldEnum = (typeof UserNotificationPreferencesScalarFieldEnum)[keyof typeof UserNotificationPreferencesScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'UserType'
   */
  export type EnumUserTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserType'>
    


  /**
   * Reference to a field of type 'UserType[]'
   */
  export type ListEnumUserTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserType[]'>
    


  /**
   * Reference to a field of type 'UserStatus'
   */
  export type EnumUserStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserStatus'>
    


  /**
   * Reference to a field of type 'UserStatus[]'
   */
  export type ListEnumUserStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserStatus[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'StudentStatus'
   */
  export type EnumStudentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StudentStatus'>
    


  /**
   * Reference to a field of type 'StudentStatus[]'
   */
  export type ListEnumStudentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StudentStatus[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'SessionStatus'
   */
  export type EnumSessionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SessionStatus'>
    


  /**
   * Reference to a field of type 'SessionStatus[]'
   */
  export type ListEnumSessionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SessionStatus[]'>
    


  /**
   * Reference to a field of type 'AvailabilityType'
   */
  export type EnumAvailabilityTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AvailabilityType'>
    


  /**
   * Reference to a field of type 'AvailabilityType[]'
   */
  export type ListEnumAvailabilityTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AvailabilityType[]'>
    


  /**
   * Reference to a field of type 'DocumentType'
   */
  export type EnumDocumentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DocumentType'>
    


  /**
   * Reference to a field of type 'DocumentType[]'
   */
  export type ListEnumDocumentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DocumentType[]'>
    


  /**
   * Reference to a field of type 'ReviewStatus'
   */
  export type EnumReviewStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReviewStatus'>
    


  /**
   * Reference to a field of type 'ReviewStatus[]'
   */
  export type ListEnumReviewStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReviewStatus[]'>
    


  /**
   * Reference to a field of type 'PaymentStatus'
   */
  export type EnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus'>
    


  /**
   * Reference to a field of type 'PaymentStatus[]'
   */
  export type ListEnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus[]'>
    


  /**
   * Reference to a field of type 'ScheduledNotificationStatus'
   */
  export type EnumScheduledNotificationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ScheduledNotificationStatus'>
    


  /**
   * Reference to a field of type 'ScheduledNotificationStatus[]'
   */
  export type ListEnumScheduledNotificationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ScheduledNotificationStatus[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    userType?: EnumUserTypeFilter<"User"> | $Enums.UserType
    phone?: StringNullableFilter<"User"> | string | null
    status?: EnumUserStatusFilter<"User"> | $Enums.UserStatus
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    student?: XOR<StudentNullableRelationFilter, StudentWhereInput> | null
    consultant?: XOR<ConsultantNullableRelationFilter, ConsultantWhereInput> | null
    admin?: XOR<AdminNullableRelationFilter, AdminWhereInput> | null
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    userType?: SortOrder
    phone?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    student?: StudentOrderByWithRelationInput
    consultant?: ConsultantOrderByWithRelationInput
    admin?: AdminOrderByWithRelationInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringFilter<"User"> | string
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    userType?: EnumUserTypeFilter<"User"> | $Enums.UserType
    phone?: StringNullableFilter<"User"> | string | null
    status?: EnumUserStatusFilter<"User"> | $Enums.UserStatus
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    student?: XOR<StudentNullableRelationFilter, StudentWhereInput> | null
    consultant?: XOR<ConsultantNullableRelationFilter, ConsultantWhereInput> | null
    admin?: XOR<AdminNullableRelationFilter, AdminWhereInput> | null
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    userType?: SortOrder
    phone?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    firstName?: StringWithAggregatesFilter<"User"> | string
    lastName?: StringWithAggregatesFilter<"User"> | string
    userType?: EnumUserTypeWithAggregatesFilter<"User"> | $Enums.UserType
    phone?: StringNullableWithAggregatesFilter<"User"> | string | null
    status?: EnumUserStatusWithAggregatesFilter<"User"> | $Enums.UserStatus
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type StudentWhereInput = {
    AND?: StudentWhereInput | StudentWhereInput[]
    OR?: StudentWhereInput[]
    NOT?: StudentWhereInput | StudentWhereInput[]
    id?: StringFilter<"Student"> | string
    userId?: StringFilter<"Student"> | string
    kajabiUserId?: StringNullableFilter<"Student"> | string | null
    courseCompletionDate?: DateTimeFilter<"Student"> | Date | string
    totalVerifiedHours?: FloatFilter<"Student"> | number
    totalVideoHours?: FloatFilter<"Student"> | number
    certificationStatus?: EnumStudentStatusFilter<"Student"> | $Enums.StudentStatus
    preferredSessionLength?: IntFilter<"Student"> | number
    consultationPreferences?: JsonNullableFilter<"Student">
    createdAt?: DateTimeFilter<"Student"> | Date | string
    updatedAt?: DateTimeFilter<"Student"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    consultationSessions?: ConsultationSessionListRelationFilter
    studentDocuments?: StudentDocumentListRelationFilter
    sessionHistory?: SessionHistoryListRelationFilter
  }

  export type StudentOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    kajabiUserId?: SortOrderInput | SortOrder
    courseCompletionDate?: SortOrder
    totalVerifiedHours?: SortOrder
    totalVideoHours?: SortOrder
    certificationStatus?: SortOrder
    preferredSessionLength?: SortOrder
    consultationPreferences?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    consultationSessions?: ConsultationSessionOrderByRelationAggregateInput
    studentDocuments?: StudentDocumentOrderByRelationAggregateInput
    sessionHistory?: SessionHistoryOrderByRelationAggregateInput
  }

  export type StudentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    kajabiUserId?: string
    AND?: StudentWhereInput | StudentWhereInput[]
    OR?: StudentWhereInput[]
    NOT?: StudentWhereInput | StudentWhereInput[]
    courseCompletionDate?: DateTimeFilter<"Student"> | Date | string
    totalVerifiedHours?: FloatFilter<"Student"> | number
    totalVideoHours?: FloatFilter<"Student"> | number
    certificationStatus?: EnumStudentStatusFilter<"Student"> | $Enums.StudentStatus
    preferredSessionLength?: IntFilter<"Student"> | number
    consultationPreferences?: JsonNullableFilter<"Student">
    createdAt?: DateTimeFilter<"Student"> | Date | string
    updatedAt?: DateTimeFilter<"Student"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    consultationSessions?: ConsultationSessionListRelationFilter
    studentDocuments?: StudentDocumentListRelationFilter
    sessionHistory?: SessionHistoryListRelationFilter
  }, "id" | "userId" | "kajabiUserId">

  export type StudentOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    kajabiUserId?: SortOrderInput | SortOrder
    courseCompletionDate?: SortOrder
    totalVerifiedHours?: SortOrder
    totalVideoHours?: SortOrder
    certificationStatus?: SortOrder
    preferredSessionLength?: SortOrder
    consultationPreferences?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StudentCountOrderByAggregateInput
    _avg?: StudentAvgOrderByAggregateInput
    _max?: StudentMaxOrderByAggregateInput
    _min?: StudentMinOrderByAggregateInput
    _sum?: StudentSumOrderByAggregateInput
  }

  export type StudentScalarWhereWithAggregatesInput = {
    AND?: StudentScalarWhereWithAggregatesInput | StudentScalarWhereWithAggregatesInput[]
    OR?: StudentScalarWhereWithAggregatesInput[]
    NOT?: StudentScalarWhereWithAggregatesInput | StudentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Student"> | string
    userId?: StringWithAggregatesFilter<"Student"> | string
    kajabiUserId?: StringNullableWithAggregatesFilter<"Student"> | string | null
    courseCompletionDate?: DateTimeWithAggregatesFilter<"Student"> | Date | string
    totalVerifiedHours?: FloatWithAggregatesFilter<"Student"> | number
    totalVideoHours?: FloatWithAggregatesFilter<"Student"> | number
    certificationStatus?: EnumStudentStatusWithAggregatesFilter<"Student"> | $Enums.StudentStatus
    preferredSessionLength?: IntWithAggregatesFilter<"Student"> | number
    consultationPreferences?: JsonNullableWithAggregatesFilter<"Student">
    createdAt?: DateTimeWithAggregatesFilter<"Student"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Student"> | Date | string
  }

  export type ConsultantWhereInput = {
    AND?: ConsultantWhereInput | ConsultantWhereInput[]
    OR?: ConsultantWhereInput[]
    NOT?: ConsultantWhereInput | ConsultantWhereInput[]
    id?: StringFilter<"Consultant"> | string
    userId?: StringFilter<"Consultant"> | string
    bio?: StringNullableFilter<"Consultant"> | string | null
    specialties?: StringNullableListFilter<"Consultant">
    hourlyRate?: FloatFilter<"Consultant"> | number
    isActive?: BoolFilter<"Consultant"> | boolean
    timezone?: StringFilter<"Consultant"> | string
    createdAt?: DateTimeFilter<"Consultant"> | Date | string
    updatedAt?: DateTimeFilter<"Consultant"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    consultationSessions?: ConsultationSessionListRelationFilter
    consultantAvailability?: ConsultantAvailabilityListRelationFilter
    consultantPayments?: ConsultantPaymentListRelationFilter
  }

  export type ConsultantOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    bio?: SortOrderInput | SortOrder
    specialties?: SortOrder
    hourlyRate?: SortOrder
    isActive?: SortOrder
    timezone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    consultationSessions?: ConsultationSessionOrderByRelationAggregateInput
    consultantAvailability?: ConsultantAvailabilityOrderByRelationAggregateInput
    consultantPayments?: ConsultantPaymentOrderByRelationAggregateInput
  }

  export type ConsultantWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: ConsultantWhereInput | ConsultantWhereInput[]
    OR?: ConsultantWhereInput[]
    NOT?: ConsultantWhereInput | ConsultantWhereInput[]
    bio?: StringNullableFilter<"Consultant"> | string | null
    specialties?: StringNullableListFilter<"Consultant">
    hourlyRate?: FloatFilter<"Consultant"> | number
    isActive?: BoolFilter<"Consultant"> | boolean
    timezone?: StringFilter<"Consultant"> | string
    createdAt?: DateTimeFilter<"Consultant"> | Date | string
    updatedAt?: DateTimeFilter<"Consultant"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    consultationSessions?: ConsultationSessionListRelationFilter
    consultantAvailability?: ConsultantAvailabilityListRelationFilter
    consultantPayments?: ConsultantPaymentListRelationFilter
  }, "id" | "userId">

  export type ConsultantOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    bio?: SortOrderInput | SortOrder
    specialties?: SortOrder
    hourlyRate?: SortOrder
    isActive?: SortOrder
    timezone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ConsultantCountOrderByAggregateInput
    _avg?: ConsultantAvgOrderByAggregateInput
    _max?: ConsultantMaxOrderByAggregateInput
    _min?: ConsultantMinOrderByAggregateInput
    _sum?: ConsultantSumOrderByAggregateInput
  }

  export type ConsultantScalarWhereWithAggregatesInput = {
    AND?: ConsultantScalarWhereWithAggregatesInput | ConsultantScalarWhereWithAggregatesInput[]
    OR?: ConsultantScalarWhereWithAggregatesInput[]
    NOT?: ConsultantScalarWhereWithAggregatesInput | ConsultantScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Consultant"> | string
    userId?: StringWithAggregatesFilter<"Consultant"> | string
    bio?: StringNullableWithAggregatesFilter<"Consultant"> | string | null
    specialties?: StringNullableListFilter<"Consultant">
    hourlyRate?: FloatWithAggregatesFilter<"Consultant"> | number
    isActive?: BoolWithAggregatesFilter<"Consultant"> | boolean
    timezone?: StringWithAggregatesFilter<"Consultant"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Consultant"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Consultant"> | Date | string
  }

  export type AdminWhereInput = {
    AND?: AdminWhereInput | AdminWhereInput[]
    OR?: AdminWhereInput[]
    NOT?: AdminWhereInput | AdminWhereInput[]
    id?: StringFilter<"Admin"> | string
    userId?: StringFilter<"Admin"> | string
    role?: StringFilter<"Admin"> | string
    permissions?: StringNullableListFilter<"Admin">
    createdAt?: DateTimeFilter<"Admin"> | Date | string
    updatedAt?: DateTimeFilter<"Admin"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type AdminOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    permissions?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AdminWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: AdminWhereInput | AdminWhereInput[]
    OR?: AdminWhereInput[]
    NOT?: AdminWhereInput | AdminWhereInput[]
    role?: StringFilter<"Admin"> | string
    permissions?: StringNullableListFilter<"Admin">
    createdAt?: DateTimeFilter<"Admin"> | Date | string
    updatedAt?: DateTimeFilter<"Admin"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type AdminOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    permissions?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AdminCountOrderByAggregateInput
    _max?: AdminMaxOrderByAggregateInput
    _min?: AdminMinOrderByAggregateInput
  }

  export type AdminScalarWhereWithAggregatesInput = {
    AND?: AdminScalarWhereWithAggregatesInput | AdminScalarWhereWithAggregatesInput[]
    OR?: AdminScalarWhereWithAggregatesInput[]
    NOT?: AdminScalarWhereWithAggregatesInput | AdminScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Admin"> | string
    userId?: StringWithAggregatesFilter<"Admin"> | string
    role?: StringWithAggregatesFilter<"Admin"> | string
    permissions?: StringNullableListFilter<"Admin">
    createdAt?: DateTimeWithAggregatesFilter<"Admin"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Admin"> | Date | string
  }

  export type ConsultationSessionWhereInput = {
    AND?: ConsultationSessionWhereInput | ConsultationSessionWhereInput[]
    OR?: ConsultationSessionWhereInput[]
    NOT?: ConsultationSessionWhereInput | ConsultationSessionWhereInput[]
    id?: StringFilter<"ConsultationSession"> | string
    studentId?: StringFilter<"ConsultationSession"> | string
    consultantId?: StringFilter<"ConsultationSession"> | string
    scheduledStart?: DateTimeFilter<"ConsultationSession"> | Date | string
    scheduledEnd?: DateTimeFilter<"ConsultationSession"> | Date | string
    actualStart?: DateTimeNullableFilter<"ConsultationSession"> | Date | string | null
    actualEnd?: DateTimeNullableFilter<"ConsultationSession"> | Date | string | null
    status?: EnumSessionStatusFilter<"ConsultationSession"> | $Enums.SessionStatus
    sessionType?: StringFilter<"ConsultationSession"> | string
    studentVerifiedAt?: DateTimeNullableFilter<"ConsultationSession"> | Date | string | null
    consultantVerifiedAt?: DateTimeNullableFilter<"ConsultationSession"> | Date | string | null
    studentNotes?: StringNullableFilter<"ConsultationSession"> | string | null
    consultantNotes?: StringNullableFilter<"ConsultationSession"> | string | null
    sessionRating?: IntNullableFilter<"ConsultationSession"> | number | null
    technicalIssuesReported?: BoolFilter<"ConsultationSession"> | boolean
    makeupSessionFor?: StringNullableFilter<"ConsultationSession"> | string | null
    createdAt?: DateTimeFilter<"ConsultationSession"> | Date | string
    updatedAt?: DateTimeFilter<"ConsultationSession"> | Date | string
    student?: XOR<StudentRelationFilter, StudentWhereInput>
    consultant?: XOR<ConsultantRelationFilter, ConsultantWhereInput>
    videoSession?: XOR<VideoSessionNullableRelationFilter, VideoSessionWhereInput> | null
  }

  export type ConsultationSessionOrderByWithRelationInput = {
    id?: SortOrder
    studentId?: SortOrder
    consultantId?: SortOrder
    scheduledStart?: SortOrder
    scheduledEnd?: SortOrder
    actualStart?: SortOrderInput | SortOrder
    actualEnd?: SortOrderInput | SortOrder
    status?: SortOrder
    sessionType?: SortOrder
    studentVerifiedAt?: SortOrderInput | SortOrder
    consultantVerifiedAt?: SortOrderInput | SortOrder
    studentNotes?: SortOrderInput | SortOrder
    consultantNotes?: SortOrderInput | SortOrder
    sessionRating?: SortOrderInput | SortOrder
    technicalIssuesReported?: SortOrder
    makeupSessionFor?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    student?: StudentOrderByWithRelationInput
    consultant?: ConsultantOrderByWithRelationInput
    videoSession?: VideoSessionOrderByWithRelationInput
  }

  export type ConsultationSessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ConsultationSessionWhereInput | ConsultationSessionWhereInput[]
    OR?: ConsultationSessionWhereInput[]
    NOT?: ConsultationSessionWhereInput | ConsultationSessionWhereInput[]
    studentId?: StringFilter<"ConsultationSession"> | string
    consultantId?: StringFilter<"ConsultationSession"> | string
    scheduledStart?: DateTimeFilter<"ConsultationSession"> | Date | string
    scheduledEnd?: DateTimeFilter<"ConsultationSession"> | Date | string
    actualStart?: DateTimeNullableFilter<"ConsultationSession"> | Date | string | null
    actualEnd?: DateTimeNullableFilter<"ConsultationSession"> | Date | string | null
    status?: EnumSessionStatusFilter<"ConsultationSession"> | $Enums.SessionStatus
    sessionType?: StringFilter<"ConsultationSession"> | string
    studentVerifiedAt?: DateTimeNullableFilter<"ConsultationSession"> | Date | string | null
    consultantVerifiedAt?: DateTimeNullableFilter<"ConsultationSession"> | Date | string | null
    studentNotes?: StringNullableFilter<"ConsultationSession"> | string | null
    consultantNotes?: StringNullableFilter<"ConsultationSession"> | string | null
    sessionRating?: IntNullableFilter<"ConsultationSession"> | number | null
    technicalIssuesReported?: BoolFilter<"ConsultationSession"> | boolean
    makeupSessionFor?: StringNullableFilter<"ConsultationSession"> | string | null
    createdAt?: DateTimeFilter<"ConsultationSession"> | Date | string
    updatedAt?: DateTimeFilter<"ConsultationSession"> | Date | string
    student?: XOR<StudentRelationFilter, StudentWhereInput>
    consultant?: XOR<ConsultantRelationFilter, ConsultantWhereInput>
    videoSession?: XOR<VideoSessionNullableRelationFilter, VideoSessionWhereInput> | null
  }, "id">

  export type ConsultationSessionOrderByWithAggregationInput = {
    id?: SortOrder
    studentId?: SortOrder
    consultantId?: SortOrder
    scheduledStart?: SortOrder
    scheduledEnd?: SortOrder
    actualStart?: SortOrderInput | SortOrder
    actualEnd?: SortOrderInput | SortOrder
    status?: SortOrder
    sessionType?: SortOrder
    studentVerifiedAt?: SortOrderInput | SortOrder
    consultantVerifiedAt?: SortOrderInput | SortOrder
    studentNotes?: SortOrderInput | SortOrder
    consultantNotes?: SortOrderInput | SortOrder
    sessionRating?: SortOrderInput | SortOrder
    technicalIssuesReported?: SortOrder
    makeupSessionFor?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ConsultationSessionCountOrderByAggregateInput
    _avg?: ConsultationSessionAvgOrderByAggregateInput
    _max?: ConsultationSessionMaxOrderByAggregateInput
    _min?: ConsultationSessionMinOrderByAggregateInput
    _sum?: ConsultationSessionSumOrderByAggregateInput
  }

  export type ConsultationSessionScalarWhereWithAggregatesInput = {
    AND?: ConsultationSessionScalarWhereWithAggregatesInput | ConsultationSessionScalarWhereWithAggregatesInput[]
    OR?: ConsultationSessionScalarWhereWithAggregatesInput[]
    NOT?: ConsultationSessionScalarWhereWithAggregatesInput | ConsultationSessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ConsultationSession"> | string
    studentId?: StringWithAggregatesFilter<"ConsultationSession"> | string
    consultantId?: StringWithAggregatesFilter<"ConsultationSession"> | string
    scheduledStart?: DateTimeWithAggregatesFilter<"ConsultationSession"> | Date | string
    scheduledEnd?: DateTimeWithAggregatesFilter<"ConsultationSession"> | Date | string
    actualStart?: DateTimeNullableWithAggregatesFilter<"ConsultationSession"> | Date | string | null
    actualEnd?: DateTimeNullableWithAggregatesFilter<"ConsultationSession"> | Date | string | null
    status?: EnumSessionStatusWithAggregatesFilter<"ConsultationSession"> | $Enums.SessionStatus
    sessionType?: StringWithAggregatesFilter<"ConsultationSession"> | string
    studentVerifiedAt?: DateTimeNullableWithAggregatesFilter<"ConsultationSession"> | Date | string | null
    consultantVerifiedAt?: DateTimeNullableWithAggregatesFilter<"ConsultationSession"> | Date | string | null
    studentNotes?: StringNullableWithAggregatesFilter<"ConsultationSession"> | string | null
    consultantNotes?: StringNullableWithAggregatesFilter<"ConsultationSession"> | string | null
    sessionRating?: IntNullableWithAggregatesFilter<"ConsultationSession"> | number | null
    technicalIssuesReported?: BoolWithAggregatesFilter<"ConsultationSession"> | boolean
    makeupSessionFor?: StringNullableWithAggregatesFilter<"ConsultationSession"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ConsultationSession"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ConsultationSession"> | Date | string
  }

  export type VideoSessionWhereInput = {
    AND?: VideoSessionWhereInput | VideoSessionWhereInput[]
    OR?: VideoSessionWhereInput[]
    NOT?: VideoSessionWhereInput | VideoSessionWhereInput[]
    id?: StringFilter<"VideoSession"> | string
    consultationSessionId?: StringFilter<"VideoSession"> | string
    roomId?: StringFilter<"VideoSession"> | string
    recordingEnabled?: BoolFilter<"VideoSession"> | boolean
    recordingUrl?: StringNullableFilter<"VideoSession"> | string | null
    recordingDurationSeconds?: IntNullableFilter<"VideoSession"> | number | null
    videoQuality?: StringFilter<"VideoSession"> | string
    connectionQualityAvg?: FloatNullableFilter<"VideoSession"> | number | null
    bandwidthUsageMb?: FloatNullableFilter<"VideoSession"> | number | null
    technicalIssues?: JsonNullableFilter<"VideoSession">
    sessionMetadata?: JsonNullableFilter<"VideoSession">
    createdAt?: DateTimeFilter<"VideoSession"> | Date | string
    consultationSession?: XOR<ConsultationSessionRelationFilter, ConsultationSessionWhereInput>
    videoParticipants?: VideoParticipantListRelationFilter
  }

  export type VideoSessionOrderByWithRelationInput = {
    id?: SortOrder
    consultationSessionId?: SortOrder
    roomId?: SortOrder
    recordingEnabled?: SortOrder
    recordingUrl?: SortOrderInput | SortOrder
    recordingDurationSeconds?: SortOrderInput | SortOrder
    videoQuality?: SortOrder
    connectionQualityAvg?: SortOrderInput | SortOrder
    bandwidthUsageMb?: SortOrderInput | SortOrder
    technicalIssues?: SortOrderInput | SortOrder
    sessionMetadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    consultationSession?: ConsultationSessionOrderByWithRelationInput
    videoParticipants?: VideoParticipantOrderByRelationAggregateInput
  }

  export type VideoSessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    consultationSessionId?: string
    roomId?: string
    AND?: VideoSessionWhereInput | VideoSessionWhereInput[]
    OR?: VideoSessionWhereInput[]
    NOT?: VideoSessionWhereInput | VideoSessionWhereInput[]
    recordingEnabled?: BoolFilter<"VideoSession"> | boolean
    recordingUrl?: StringNullableFilter<"VideoSession"> | string | null
    recordingDurationSeconds?: IntNullableFilter<"VideoSession"> | number | null
    videoQuality?: StringFilter<"VideoSession"> | string
    connectionQualityAvg?: FloatNullableFilter<"VideoSession"> | number | null
    bandwidthUsageMb?: FloatNullableFilter<"VideoSession"> | number | null
    technicalIssues?: JsonNullableFilter<"VideoSession">
    sessionMetadata?: JsonNullableFilter<"VideoSession">
    createdAt?: DateTimeFilter<"VideoSession"> | Date | string
    consultationSession?: XOR<ConsultationSessionRelationFilter, ConsultationSessionWhereInput>
    videoParticipants?: VideoParticipantListRelationFilter
  }, "id" | "consultationSessionId" | "roomId">

  export type VideoSessionOrderByWithAggregationInput = {
    id?: SortOrder
    consultationSessionId?: SortOrder
    roomId?: SortOrder
    recordingEnabled?: SortOrder
    recordingUrl?: SortOrderInput | SortOrder
    recordingDurationSeconds?: SortOrderInput | SortOrder
    videoQuality?: SortOrder
    connectionQualityAvg?: SortOrderInput | SortOrder
    bandwidthUsageMb?: SortOrderInput | SortOrder
    technicalIssues?: SortOrderInput | SortOrder
    sessionMetadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: VideoSessionCountOrderByAggregateInput
    _avg?: VideoSessionAvgOrderByAggregateInput
    _max?: VideoSessionMaxOrderByAggregateInput
    _min?: VideoSessionMinOrderByAggregateInput
    _sum?: VideoSessionSumOrderByAggregateInput
  }

  export type VideoSessionScalarWhereWithAggregatesInput = {
    AND?: VideoSessionScalarWhereWithAggregatesInput | VideoSessionScalarWhereWithAggregatesInput[]
    OR?: VideoSessionScalarWhereWithAggregatesInput[]
    NOT?: VideoSessionScalarWhereWithAggregatesInput | VideoSessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VideoSession"> | string
    consultationSessionId?: StringWithAggregatesFilter<"VideoSession"> | string
    roomId?: StringWithAggregatesFilter<"VideoSession"> | string
    recordingEnabled?: BoolWithAggregatesFilter<"VideoSession"> | boolean
    recordingUrl?: StringNullableWithAggregatesFilter<"VideoSession"> | string | null
    recordingDurationSeconds?: IntNullableWithAggregatesFilter<"VideoSession"> | number | null
    videoQuality?: StringWithAggregatesFilter<"VideoSession"> | string
    connectionQualityAvg?: FloatNullableWithAggregatesFilter<"VideoSession"> | number | null
    bandwidthUsageMb?: FloatNullableWithAggregatesFilter<"VideoSession"> | number | null
    technicalIssues?: JsonNullableWithAggregatesFilter<"VideoSession">
    sessionMetadata?: JsonNullableWithAggregatesFilter<"VideoSession">
    createdAt?: DateTimeWithAggregatesFilter<"VideoSession"> | Date | string
  }

  export type VideoParticipantWhereInput = {
    AND?: VideoParticipantWhereInput | VideoParticipantWhereInput[]
    OR?: VideoParticipantWhereInput[]
    NOT?: VideoParticipantWhereInput | VideoParticipantWhereInput[]
    id?: StringFilter<"VideoParticipant"> | string
    videoSessionId?: StringFilter<"VideoParticipant"> | string
    userId?: StringFilter<"VideoParticipant"> | string
    userType?: EnumUserTypeFilter<"VideoParticipant"> | $Enums.UserType
    joinTime?: DateTimeFilter<"VideoParticipant"> | Date | string
    leaveTime?: DateTimeNullableFilter<"VideoParticipant"> | Date | string | null
    totalDurationSeconds?: IntNullableFilter<"VideoParticipant"> | number | null
    audioQualityAvg?: FloatNullableFilter<"VideoParticipant"> | number | null
    videoQualityAvg?: FloatNullableFilter<"VideoParticipant"> | number | null
    screenShareDurationSeconds?: IntFilter<"VideoParticipant"> | number
    chatMessagesCount?: IntFilter<"VideoParticipant"> | number
    connectionInterruptions?: IntFilter<"VideoParticipant"> | number
    createdAt?: DateTimeFilter<"VideoParticipant"> | Date | string
    videoSession?: XOR<VideoSessionRelationFilter, VideoSessionWhereInput>
  }

  export type VideoParticipantOrderByWithRelationInput = {
    id?: SortOrder
    videoSessionId?: SortOrder
    userId?: SortOrder
    userType?: SortOrder
    joinTime?: SortOrder
    leaveTime?: SortOrderInput | SortOrder
    totalDurationSeconds?: SortOrderInput | SortOrder
    audioQualityAvg?: SortOrderInput | SortOrder
    videoQualityAvg?: SortOrderInput | SortOrder
    screenShareDurationSeconds?: SortOrder
    chatMessagesCount?: SortOrder
    connectionInterruptions?: SortOrder
    createdAt?: SortOrder
    videoSession?: VideoSessionOrderByWithRelationInput
  }

  export type VideoParticipantWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VideoParticipantWhereInput | VideoParticipantWhereInput[]
    OR?: VideoParticipantWhereInput[]
    NOT?: VideoParticipantWhereInput | VideoParticipantWhereInput[]
    videoSessionId?: StringFilter<"VideoParticipant"> | string
    userId?: StringFilter<"VideoParticipant"> | string
    userType?: EnumUserTypeFilter<"VideoParticipant"> | $Enums.UserType
    joinTime?: DateTimeFilter<"VideoParticipant"> | Date | string
    leaveTime?: DateTimeNullableFilter<"VideoParticipant"> | Date | string | null
    totalDurationSeconds?: IntNullableFilter<"VideoParticipant"> | number | null
    audioQualityAvg?: FloatNullableFilter<"VideoParticipant"> | number | null
    videoQualityAvg?: FloatNullableFilter<"VideoParticipant"> | number | null
    screenShareDurationSeconds?: IntFilter<"VideoParticipant"> | number
    chatMessagesCount?: IntFilter<"VideoParticipant"> | number
    connectionInterruptions?: IntFilter<"VideoParticipant"> | number
    createdAt?: DateTimeFilter<"VideoParticipant"> | Date | string
    videoSession?: XOR<VideoSessionRelationFilter, VideoSessionWhereInput>
  }, "id">

  export type VideoParticipantOrderByWithAggregationInput = {
    id?: SortOrder
    videoSessionId?: SortOrder
    userId?: SortOrder
    userType?: SortOrder
    joinTime?: SortOrder
    leaveTime?: SortOrderInput | SortOrder
    totalDurationSeconds?: SortOrderInput | SortOrder
    audioQualityAvg?: SortOrderInput | SortOrder
    videoQualityAvg?: SortOrderInput | SortOrder
    screenShareDurationSeconds?: SortOrder
    chatMessagesCount?: SortOrder
    connectionInterruptions?: SortOrder
    createdAt?: SortOrder
    _count?: VideoParticipantCountOrderByAggregateInput
    _avg?: VideoParticipantAvgOrderByAggregateInput
    _max?: VideoParticipantMaxOrderByAggregateInput
    _min?: VideoParticipantMinOrderByAggregateInput
    _sum?: VideoParticipantSumOrderByAggregateInput
  }

  export type VideoParticipantScalarWhereWithAggregatesInput = {
    AND?: VideoParticipantScalarWhereWithAggregatesInput | VideoParticipantScalarWhereWithAggregatesInput[]
    OR?: VideoParticipantScalarWhereWithAggregatesInput[]
    NOT?: VideoParticipantScalarWhereWithAggregatesInput | VideoParticipantScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VideoParticipant"> | string
    videoSessionId?: StringWithAggregatesFilter<"VideoParticipant"> | string
    userId?: StringWithAggregatesFilter<"VideoParticipant"> | string
    userType?: EnumUserTypeWithAggregatesFilter<"VideoParticipant"> | $Enums.UserType
    joinTime?: DateTimeWithAggregatesFilter<"VideoParticipant"> | Date | string
    leaveTime?: DateTimeNullableWithAggregatesFilter<"VideoParticipant"> | Date | string | null
    totalDurationSeconds?: IntNullableWithAggregatesFilter<"VideoParticipant"> | number | null
    audioQualityAvg?: FloatNullableWithAggregatesFilter<"VideoParticipant"> | number | null
    videoQualityAvg?: FloatNullableWithAggregatesFilter<"VideoParticipant"> | number | null
    screenShareDurationSeconds?: IntWithAggregatesFilter<"VideoParticipant"> | number
    chatMessagesCount?: IntWithAggregatesFilter<"VideoParticipant"> | number
    connectionInterruptions?: IntWithAggregatesFilter<"VideoParticipant"> | number
    createdAt?: DateTimeWithAggregatesFilter<"VideoParticipant"> | Date | string
  }

  export type ConsultantAvailabilityWhereInput = {
    AND?: ConsultantAvailabilityWhereInput | ConsultantAvailabilityWhereInput[]
    OR?: ConsultantAvailabilityWhereInput[]
    NOT?: ConsultantAvailabilityWhereInput | ConsultantAvailabilityWhereInput[]
    id?: StringFilter<"ConsultantAvailability"> | string
    consultantId?: StringFilter<"ConsultantAvailability"> | string
    availabilityType?: EnumAvailabilityTypeFilter<"ConsultantAvailability"> | $Enums.AvailabilityType
    dayOfWeek?: IntNullableFilter<"ConsultantAvailability"> | number | null
    specificDate?: DateTimeNullableFilter<"ConsultantAvailability"> | Date | string | null
    startTime?: StringFilter<"ConsultantAvailability"> | string
    endTime?: StringFilter<"ConsultantAvailability"> | string
    maxSessions?: IntFilter<"ConsultantAvailability"> | number
    bufferMinutes?: IntFilter<"ConsultantAvailability"> | number
    isAvailable?: BoolFilter<"ConsultantAvailability"> | boolean
    bookingWindowDays?: IntFilter<"ConsultantAvailability"> | number
    minimumNoticeHours?: IntFilter<"ConsultantAvailability"> | number
    autoApprove?: BoolFilter<"ConsultantAvailability"> | boolean
    timezone?: StringFilter<"ConsultantAvailability"> | string
    recurringPattern?: JsonNullableFilter<"ConsultantAvailability">
    createdAt?: DateTimeFilter<"ConsultantAvailability"> | Date | string
    updatedAt?: DateTimeFilter<"ConsultantAvailability"> | Date | string
    consultant?: XOR<ConsultantRelationFilter, ConsultantWhereInput>
  }

  export type ConsultantAvailabilityOrderByWithRelationInput = {
    id?: SortOrder
    consultantId?: SortOrder
    availabilityType?: SortOrder
    dayOfWeek?: SortOrderInput | SortOrder
    specificDate?: SortOrderInput | SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    maxSessions?: SortOrder
    bufferMinutes?: SortOrder
    isAvailable?: SortOrder
    bookingWindowDays?: SortOrder
    minimumNoticeHours?: SortOrder
    autoApprove?: SortOrder
    timezone?: SortOrder
    recurringPattern?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    consultant?: ConsultantOrderByWithRelationInput
  }

  export type ConsultantAvailabilityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ConsultantAvailabilityWhereInput | ConsultantAvailabilityWhereInput[]
    OR?: ConsultantAvailabilityWhereInput[]
    NOT?: ConsultantAvailabilityWhereInput | ConsultantAvailabilityWhereInput[]
    consultantId?: StringFilter<"ConsultantAvailability"> | string
    availabilityType?: EnumAvailabilityTypeFilter<"ConsultantAvailability"> | $Enums.AvailabilityType
    dayOfWeek?: IntNullableFilter<"ConsultantAvailability"> | number | null
    specificDate?: DateTimeNullableFilter<"ConsultantAvailability"> | Date | string | null
    startTime?: StringFilter<"ConsultantAvailability"> | string
    endTime?: StringFilter<"ConsultantAvailability"> | string
    maxSessions?: IntFilter<"ConsultantAvailability"> | number
    bufferMinutes?: IntFilter<"ConsultantAvailability"> | number
    isAvailable?: BoolFilter<"ConsultantAvailability"> | boolean
    bookingWindowDays?: IntFilter<"ConsultantAvailability"> | number
    minimumNoticeHours?: IntFilter<"ConsultantAvailability"> | number
    autoApprove?: BoolFilter<"ConsultantAvailability"> | boolean
    timezone?: StringFilter<"ConsultantAvailability"> | string
    recurringPattern?: JsonNullableFilter<"ConsultantAvailability">
    createdAt?: DateTimeFilter<"ConsultantAvailability"> | Date | string
    updatedAt?: DateTimeFilter<"ConsultantAvailability"> | Date | string
    consultant?: XOR<ConsultantRelationFilter, ConsultantWhereInput>
  }, "id">

  export type ConsultantAvailabilityOrderByWithAggregationInput = {
    id?: SortOrder
    consultantId?: SortOrder
    availabilityType?: SortOrder
    dayOfWeek?: SortOrderInput | SortOrder
    specificDate?: SortOrderInput | SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    maxSessions?: SortOrder
    bufferMinutes?: SortOrder
    isAvailable?: SortOrder
    bookingWindowDays?: SortOrder
    minimumNoticeHours?: SortOrder
    autoApprove?: SortOrder
    timezone?: SortOrder
    recurringPattern?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ConsultantAvailabilityCountOrderByAggregateInput
    _avg?: ConsultantAvailabilityAvgOrderByAggregateInput
    _max?: ConsultantAvailabilityMaxOrderByAggregateInput
    _min?: ConsultantAvailabilityMinOrderByAggregateInput
    _sum?: ConsultantAvailabilitySumOrderByAggregateInput
  }

  export type ConsultantAvailabilityScalarWhereWithAggregatesInput = {
    AND?: ConsultantAvailabilityScalarWhereWithAggregatesInput | ConsultantAvailabilityScalarWhereWithAggregatesInput[]
    OR?: ConsultantAvailabilityScalarWhereWithAggregatesInput[]
    NOT?: ConsultantAvailabilityScalarWhereWithAggregatesInput | ConsultantAvailabilityScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ConsultantAvailability"> | string
    consultantId?: StringWithAggregatesFilter<"ConsultantAvailability"> | string
    availabilityType?: EnumAvailabilityTypeWithAggregatesFilter<"ConsultantAvailability"> | $Enums.AvailabilityType
    dayOfWeek?: IntNullableWithAggregatesFilter<"ConsultantAvailability"> | number | null
    specificDate?: DateTimeNullableWithAggregatesFilter<"ConsultantAvailability"> | Date | string | null
    startTime?: StringWithAggregatesFilter<"ConsultantAvailability"> | string
    endTime?: StringWithAggregatesFilter<"ConsultantAvailability"> | string
    maxSessions?: IntWithAggregatesFilter<"ConsultantAvailability"> | number
    bufferMinutes?: IntWithAggregatesFilter<"ConsultantAvailability"> | number
    isAvailable?: BoolWithAggregatesFilter<"ConsultantAvailability"> | boolean
    bookingWindowDays?: IntWithAggregatesFilter<"ConsultantAvailability"> | number
    minimumNoticeHours?: IntWithAggregatesFilter<"ConsultantAvailability"> | number
    autoApprove?: BoolWithAggregatesFilter<"ConsultantAvailability"> | boolean
    timezone?: StringWithAggregatesFilter<"ConsultantAvailability"> | string
    recurringPattern?: JsonNullableWithAggregatesFilter<"ConsultantAvailability">
    createdAt?: DateTimeWithAggregatesFilter<"ConsultantAvailability"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ConsultantAvailability"> | Date | string
  }

  export type StudentDocumentWhereInput = {
    AND?: StudentDocumentWhereInput | StudentDocumentWhereInput[]
    OR?: StudentDocumentWhereInput[]
    NOT?: StudentDocumentWhereInput | StudentDocumentWhereInput[]
    id?: StringFilter<"StudentDocument"> | string
    studentId?: StringFilter<"StudentDocument"> | string
    documentType?: EnumDocumentTypeFilter<"StudentDocument"> | $Enums.DocumentType
    fileName?: StringFilter<"StudentDocument"> | string
    fileSizeBytes?: IntFilter<"StudentDocument"> | number
    filePath?: StringFilter<"StudentDocument"> | string
    mimeType?: StringFilter<"StudentDocument"> | string
    extractedText?: StringNullableFilter<"StudentDocument"> | string | null
    uploadTimestamp?: DateTimeFilter<"StudentDocument"> | Date | string
    reviewStatus?: EnumReviewStatusFilter<"StudentDocument"> | $Enums.ReviewStatus
    reviewedBy?: StringNullableFilter<"StudentDocument"> | string | null
    reviewedAt?: DateTimeNullableFilter<"StudentDocument"> | Date | string | null
    reviewNotes?: StringNullableFilter<"StudentDocument"> | string | null
    versionNumber?: IntFilter<"StudentDocument"> | number
    replacesDocumentId?: StringNullableFilter<"StudentDocument"> | string | null
    autoValidationScore?: FloatNullableFilter<"StudentDocument"> | number | null
    requiresManualReview?: BoolFilter<"StudentDocument"> | boolean
    createdAt?: DateTimeFilter<"StudentDocument"> | Date | string
    student?: XOR<StudentRelationFilter, StudentWhereInput>
  }

  export type StudentDocumentOrderByWithRelationInput = {
    id?: SortOrder
    studentId?: SortOrder
    documentType?: SortOrder
    fileName?: SortOrder
    fileSizeBytes?: SortOrder
    filePath?: SortOrder
    mimeType?: SortOrder
    extractedText?: SortOrderInput | SortOrder
    uploadTimestamp?: SortOrder
    reviewStatus?: SortOrder
    reviewedBy?: SortOrderInput | SortOrder
    reviewedAt?: SortOrderInput | SortOrder
    reviewNotes?: SortOrderInput | SortOrder
    versionNumber?: SortOrder
    replacesDocumentId?: SortOrderInput | SortOrder
    autoValidationScore?: SortOrderInput | SortOrder
    requiresManualReview?: SortOrder
    createdAt?: SortOrder
    student?: StudentOrderByWithRelationInput
  }

  export type StudentDocumentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StudentDocumentWhereInput | StudentDocumentWhereInput[]
    OR?: StudentDocumentWhereInput[]
    NOT?: StudentDocumentWhereInput | StudentDocumentWhereInput[]
    studentId?: StringFilter<"StudentDocument"> | string
    documentType?: EnumDocumentTypeFilter<"StudentDocument"> | $Enums.DocumentType
    fileName?: StringFilter<"StudentDocument"> | string
    fileSizeBytes?: IntFilter<"StudentDocument"> | number
    filePath?: StringFilter<"StudentDocument"> | string
    mimeType?: StringFilter<"StudentDocument"> | string
    extractedText?: StringNullableFilter<"StudentDocument"> | string | null
    uploadTimestamp?: DateTimeFilter<"StudentDocument"> | Date | string
    reviewStatus?: EnumReviewStatusFilter<"StudentDocument"> | $Enums.ReviewStatus
    reviewedBy?: StringNullableFilter<"StudentDocument"> | string | null
    reviewedAt?: DateTimeNullableFilter<"StudentDocument"> | Date | string | null
    reviewNotes?: StringNullableFilter<"StudentDocument"> | string | null
    versionNumber?: IntFilter<"StudentDocument"> | number
    replacesDocumentId?: StringNullableFilter<"StudentDocument"> | string | null
    autoValidationScore?: FloatNullableFilter<"StudentDocument"> | number | null
    requiresManualReview?: BoolFilter<"StudentDocument"> | boolean
    createdAt?: DateTimeFilter<"StudentDocument"> | Date | string
    student?: XOR<StudentRelationFilter, StudentWhereInput>
  }, "id">

  export type StudentDocumentOrderByWithAggregationInput = {
    id?: SortOrder
    studentId?: SortOrder
    documentType?: SortOrder
    fileName?: SortOrder
    fileSizeBytes?: SortOrder
    filePath?: SortOrder
    mimeType?: SortOrder
    extractedText?: SortOrderInput | SortOrder
    uploadTimestamp?: SortOrder
    reviewStatus?: SortOrder
    reviewedBy?: SortOrderInput | SortOrder
    reviewedAt?: SortOrderInput | SortOrder
    reviewNotes?: SortOrderInput | SortOrder
    versionNumber?: SortOrder
    replacesDocumentId?: SortOrderInput | SortOrder
    autoValidationScore?: SortOrderInput | SortOrder
    requiresManualReview?: SortOrder
    createdAt?: SortOrder
    _count?: StudentDocumentCountOrderByAggregateInput
    _avg?: StudentDocumentAvgOrderByAggregateInput
    _max?: StudentDocumentMaxOrderByAggregateInput
    _min?: StudentDocumentMinOrderByAggregateInput
    _sum?: StudentDocumentSumOrderByAggregateInput
  }

  export type StudentDocumentScalarWhereWithAggregatesInput = {
    AND?: StudentDocumentScalarWhereWithAggregatesInput | StudentDocumentScalarWhereWithAggregatesInput[]
    OR?: StudentDocumentScalarWhereWithAggregatesInput[]
    NOT?: StudentDocumentScalarWhereWithAggregatesInput | StudentDocumentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StudentDocument"> | string
    studentId?: StringWithAggregatesFilter<"StudentDocument"> | string
    documentType?: EnumDocumentTypeWithAggregatesFilter<"StudentDocument"> | $Enums.DocumentType
    fileName?: StringWithAggregatesFilter<"StudentDocument"> | string
    fileSizeBytes?: IntWithAggregatesFilter<"StudentDocument"> | number
    filePath?: StringWithAggregatesFilter<"StudentDocument"> | string
    mimeType?: StringWithAggregatesFilter<"StudentDocument"> | string
    extractedText?: StringNullableWithAggregatesFilter<"StudentDocument"> | string | null
    uploadTimestamp?: DateTimeWithAggregatesFilter<"StudentDocument"> | Date | string
    reviewStatus?: EnumReviewStatusWithAggregatesFilter<"StudentDocument"> | $Enums.ReviewStatus
    reviewedBy?: StringNullableWithAggregatesFilter<"StudentDocument"> | string | null
    reviewedAt?: DateTimeNullableWithAggregatesFilter<"StudentDocument"> | Date | string | null
    reviewNotes?: StringNullableWithAggregatesFilter<"StudentDocument"> | string | null
    versionNumber?: IntWithAggregatesFilter<"StudentDocument"> | number
    replacesDocumentId?: StringNullableWithAggregatesFilter<"StudentDocument"> | string | null
    autoValidationScore?: FloatNullableWithAggregatesFilter<"StudentDocument"> | number | null
    requiresManualReview?: BoolWithAggregatesFilter<"StudentDocument"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"StudentDocument"> | Date | string
  }

  export type SessionHistoryWhereInput = {
    AND?: SessionHistoryWhereInput | SessionHistoryWhereInput[]
    OR?: SessionHistoryWhereInput[]
    NOT?: SessionHistoryWhereInput | SessionHistoryWhereInput[]
    id?: StringFilter<"SessionHistory"> | string
    studentId?: StringFilter<"SessionHistory"> | string
    sessionDate?: DateTimeFilter<"SessionHistory"> | Date | string
    sessionDuration?: IntFilter<"SessionHistory"> | number
    consultantId?: StringFilter<"SessionHistory"> | string
    sessionType?: StringFilter<"SessionHistory"> | string
    status?: StringFilter<"SessionHistory"> | string
    rating?: IntNullableFilter<"SessionHistory"> | number | null
    createdAt?: DateTimeFilter<"SessionHistory"> | Date | string
    student?: XOR<StudentRelationFilter, StudentWhereInput>
  }

  export type SessionHistoryOrderByWithRelationInput = {
    id?: SortOrder
    studentId?: SortOrder
    sessionDate?: SortOrder
    sessionDuration?: SortOrder
    consultantId?: SortOrder
    sessionType?: SortOrder
    status?: SortOrder
    rating?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    student?: StudentOrderByWithRelationInput
  }

  export type SessionHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SessionHistoryWhereInput | SessionHistoryWhereInput[]
    OR?: SessionHistoryWhereInput[]
    NOT?: SessionHistoryWhereInput | SessionHistoryWhereInput[]
    studentId?: StringFilter<"SessionHistory"> | string
    sessionDate?: DateTimeFilter<"SessionHistory"> | Date | string
    sessionDuration?: IntFilter<"SessionHistory"> | number
    consultantId?: StringFilter<"SessionHistory"> | string
    sessionType?: StringFilter<"SessionHistory"> | string
    status?: StringFilter<"SessionHistory"> | string
    rating?: IntNullableFilter<"SessionHistory"> | number | null
    createdAt?: DateTimeFilter<"SessionHistory"> | Date | string
    student?: XOR<StudentRelationFilter, StudentWhereInput>
  }, "id">

  export type SessionHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    studentId?: SortOrder
    sessionDate?: SortOrder
    sessionDuration?: SortOrder
    consultantId?: SortOrder
    sessionType?: SortOrder
    status?: SortOrder
    rating?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: SessionHistoryCountOrderByAggregateInput
    _avg?: SessionHistoryAvgOrderByAggregateInput
    _max?: SessionHistoryMaxOrderByAggregateInput
    _min?: SessionHistoryMinOrderByAggregateInput
    _sum?: SessionHistorySumOrderByAggregateInput
  }

  export type SessionHistoryScalarWhereWithAggregatesInput = {
    AND?: SessionHistoryScalarWhereWithAggregatesInput | SessionHistoryScalarWhereWithAggregatesInput[]
    OR?: SessionHistoryScalarWhereWithAggregatesInput[]
    NOT?: SessionHistoryScalarWhereWithAggregatesInput | SessionHistoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SessionHistory"> | string
    studentId?: StringWithAggregatesFilter<"SessionHistory"> | string
    sessionDate?: DateTimeWithAggregatesFilter<"SessionHistory"> | Date | string
    sessionDuration?: IntWithAggregatesFilter<"SessionHistory"> | number
    consultantId?: StringWithAggregatesFilter<"SessionHistory"> | string
    sessionType?: StringWithAggregatesFilter<"SessionHistory"> | string
    status?: StringWithAggregatesFilter<"SessionHistory"> | string
    rating?: IntNullableWithAggregatesFilter<"SessionHistory"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"SessionHistory"> | Date | string
  }

  export type ConsultantPaymentWhereInput = {
    AND?: ConsultantPaymentWhereInput | ConsultantPaymentWhereInput[]
    OR?: ConsultantPaymentWhereInput[]
    NOT?: ConsultantPaymentWhereInput | ConsultantPaymentWhereInput[]
    id?: StringFilter<"ConsultantPayment"> | string
    consultantId?: StringFilter<"ConsultantPayment"> | string
    paymentPeriod?: StringFilter<"ConsultantPayment"> | string
    totalHours?: FloatFilter<"ConsultantPayment"> | number
    hourlyRate?: FloatFilter<"ConsultantPayment"> | number
    totalAmount?: FloatFilter<"ConsultantPayment"> | number
    paymentStatus?: EnumPaymentStatusFilter<"ConsultantPayment"> | $Enums.PaymentStatus
    paymentDate?: DateTimeNullableFilter<"ConsultantPayment"> | Date | string | null
    sessionBreakdown?: JsonNullableFilter<"ConsultantPayment">
    createdAt?: DateTimeFilter<"ConsultantPayment"> | Date | string
    consultant?: XOR<ConsultantRelationFilter, ConsultantWhereInput>
  }

  export type ConsultantPaymentOrderByWithRelationInput = {
    id?: SortOrder
    consultantId?: SortOrder
    paymentPeriod?: SortOrder
    totalHours?: SortOrder
    hourlyRate?: SortOrder
    totalAmount?: SortOrder
    paymentStatus?: SortOrder
    paymentDate?: SortOrderInput | SortOrder
    sessionBreakdown?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    consultant?: ConsultantOrderByWithRelationInput
  }

  export type ConsultantPaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ConsultantPaymentWhereInput | ConsultantPaymentWhereInput[]
    OR?: ConsultantPaymentWhereInput[]
    NOT?: ConsultantPaymentWhereInput | ConsultantPaymentWhereInput[]
    consultantId?: StringFilter<"ConsultantPayment"> | string
    paymentPeriod?: StringFilter<"ConsultantPayment"> | string
    totalHours?: FloatFilter<"ConsultantPayment"> | number
    hourlyRate?: FloatFilter<"ConsultantPayment"> | number
    totalAmount?: FloatFilter<"ConsultantPayment"> | number
    paymentStatus?: EnumPaymentStatusFilter<"ConsultantPayment"> | $Enums.PaymentStatus
    paymentDate?: DateTimeNullableFilter<"ConsultantPayment"> | Date | string | null
    sessionBreakdown?: JsonNullableFilter<"ConsultantPayment">
    createdAt?: DateTimeFilter<"ConsultantPayment"> | Date | string
    consultant?: XOR<ConsultantRelationFilter, ConsultantWhereInput>
  }, "id">

  export type ConsultantPaymentOrderByWithAggregationInput = {
    id?: SortOrder
    consultantId?: SortOrder
    paymentPeriod?: SortOrder
    totalHours?: SortOrder
    hourlyRate?: SortOrder
    totalAmount?: SortOrder
    paymentStatus?: SortOrder
    paymentDate?: SortOrderInput | SortOrder
    sessionBreakdown?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ConsultantPaymentCountOrderByAggregateInput
    _avg?: ConsultantPaymentAvgOrderByAggregateInput
    _max?: ConsultantPaymentMaxOrderByAggregateInput
    _min?: ConsultantPaymentMinOrderByAggregateInput
    _sum?: ConsultantPaymentSumOrderByAggregateInput
  }

  export type ConsultantPaymentScalarWhereWithAggregatesInput = {
    AND?: ConsultantPaymentScalarWhereWithAggregatesInput | ConsultantPaymentScalarWhereWithAggregatesInput[]
    OR?: ConsultantPaymentScalarWhereWithAggregatesInput[]
    NOT?: ConsultantPaymentScalarWhereWithAggregatesInput | ConsultantPaymentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ConsultantPayment"> | string
    consultantId?: StringWithAggregatesFilter<"ConsultantPayment"> | string
    paymentPeriod?: StringWithAggregatesFilter<"ConsultantPayment"> | string
    totalHours?: FloatWithAggregatesFilter<"ConsultantPayment"> | number
    hourlyRate?: FloatWithAggregatesFilter<"ConsultantPayment"> | number
    totalAmount?: FloatWithAggregatesFilter<"ConsultantPayment"> | number
    paymentStatus?: EnumPaymentStatusWithAggregatesFilter<"ConsultantPayment"> | $Enums.PaymentStatus
    paymentDate?: DateTimeNullableWithAggregatesFilter<"ConsultantPayment"> | Date | string | null
    sessionBreakdown?: JsonNullableWithAggregatesFilter<"ConsultantPayment">
    createdAt?: DateTimeWithAggregatesFilter<"ConsultantPayment"> | Date | string
  }

  export type SystemHealthMetricWhereInput = {
    AND?: SystemHealthMetricWhereInput | SystemHealthMetricWhereInput[]
    OR?: SystemHealthMetricWhereInput[]
    NOT?: SystemHealthMetricWhereInput | SystemHealthMetricWhereInput[]
    id?: StringFilter<"SystemHealthMetric"> | string
    metricType?: StringFilter<"SystemHealthMetric"> | string
    metricValue?: FloatFilter<"SystemHealthMetric"> | number
    metricUnit?: StringNullableFilter<"SystemHealthMetric"> | string | null
    timestamp?: DateTimeFilter<"SystemHealthMetric"> | Date | string
    additionalData?: JsonNullableFilter<"SystemHealthMetric">
    createdAt?: DateTimeFilter<"SystemHealthMetric"> | Date | string
  }

  export type SystemHealthMetricOrderByWithRelationInput = {
    id?: SortOrder
    metricType?: SortOrder
    metricValue?: SortOrder
    metricUnit?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    additionalData?: SortOrderInput | SortOrder
    createdAt?: SortOrder
  }

  export type SystemHealthMetricWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SystemHealthMetricWhereInput | SystemHealthMetricWhereInput[]
    OR?: SystemHealthMetricWhereInput[]
    NOT?: SystemHealthMetricWhereInput | SystemHealthMetricWhereInput[]
    metricType?: StringFilter<"SystemHealthMetric"> | string
    metricValue?: FloatFilter<"SystemHealthMetric"> | number
    metricUnit?: StringNullableFilter<"SystemHealthMetric"> | string | null
    timestamp?: DateTimeFilter<"SystemHealthMetric"> | Date | string
    additionalData?: JsonNullableFilter<"SystemHealthMetric">
    createdAt?: DateTimeFilter<"SystemHealthMetric"> | Date | string
  }, "id">

  export type SystemHealthMetricOrderByWithAggregationInput = {
    id?: SortOrder
    metricType?: SortOrder
    metricValue?: SortOrder
    metricUnit?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    additionalData?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: SystemHealthMetricCountOrderByAggregateInput
    _avg?: SystemHealthMetricAvgOrderByAggregateInput
    _max?: SystemHealthMetricMaxOrderByAggregateInput
    _min?: SystemHealthMetricMinOrderByAggregateInput
    _sum?: SystemHealthMetricSumOrderByAggregateInput
  }

  export type SystemHealthMetricScalarWhereWithAggregatesInput = {
    AND?: SystemHealthMetricScalarWhereWithAggregatesInput | SystemHealthMetricScalarWhereWithAggregatesInput[]
    OR?: SystemHealthMetricScalarWhereWithAggregatesInput[]
    NOT?: SystemHealthMetricScalarWhereWithAggregatesInput | SystemHealthMetricScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SystemHealthMetric"> | string
    metricType?: StringWithAggregatesFilter<"SystemHealthMetric"> | string
    metricValue?: FloatWithAggregatesFilter<"SystemHealthMetric"> | number
    metricUnit?: StringNullableWithAggregatesFilter<"SystemHealthMetric"> | string | null
    timestamp?: DateTimeWithAggregatesFilter<"SystemHealthMetric"> | Date | string
    additionalData?: JsonNullableWithAggregatesFilter<"SystemHealthMetric">
    createdAt?: DateTimeWithAggregatesFilter<"SystemHealthMetric"> | Date | string
  }

  export type InAppNotificationWhereInput = {
    AND?: InAppNotificationWhereInput | InAppNotificationWhereInput[]
    OR?: InAppNotificationWhereInput[]
    NOT?: InAppNotificationWhereInput | InAppNotificationWhereInput[]
    id?: StringFilter<"InAppNotification"> | string
    userId?: StringFilter<"InAppNotification"> | string
    title?: StringFilter<"InAppNotification"> | string
    message?: StringFilter<"InAppNotification"> | string
    type?: StringFilter<"InAppNotification"> | string
    data?: JsonNullableFilter<"InAppNotification">
    read?: BoolFilter<"InAppNotification"> | boolean
    createdAt?: DateTimeFilter<"InAppNotification"> | Date | string
  }

  export type InAppNotificationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    data?: SortOrderInput | SortOrder
    read?: SortOrder
    createdAt?: SortOrder
  }

  export type InAppNotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InAppNotificationWhereInput | InAppNotificationWhereInput[]
    OR?: InAppNotificationWhereInput[]
    NOT?: InAppNotificationWhereInput | InAppNotificationWhereInput[]
    userId?: StringFilter<"InAppNotification"> | string
    title?: StringFilter<"InAppNotification"> | string
    message?: StringFilter<"InAppNotification"> | string
    type?: StringFilter<"InAppNotification"> | string
    data?: JsonNullableFilter<"InAppNotification">
    read?: BoolFilter<"InAppNotification"> | boolean
    createdAt?: DateTimeFilter<"InAppNotification"> | Date | string
  }, "id">

  export type InAppNotificationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    data?: SortOrderInput | SortOrder
    read?: SortOrder
    createdAt?: SortOrder
    _count?: InAppNotificationCountOrderByAggregateInput
    _max?: InAppNotificationMaxOrderByAggregateInput
    _min?: InAppNotificationMinOrderByAggregateInput
  }

  export type InAppNotificationScalarWhereWithAggregatesInput = {
    AND?: InAppNotificationScalarWhereWithAggregatesInput | InAppNotificationScalarWhereWithAggregatesInput[]
    OR?: InAppNotificationScalarWhereWithAggregatesInput[]
    NOT?: InAppNotificationScalarWhereWithAggregatesInput | InAppNotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"InAppNotification"> | string
    userId?: StringWithAggregatesFilter<"InAppNotification"> | string
    title?: StringWithAggregatesFilter<"InAppNotification"> | string
    message?: StringWithAggregatesFilter<"InAppNotification"> | string
    type?: StringWithAggregatesFilter<"InAppNotification"> | string
    data?: JsonNullableWithAggregatesFilter<"InAppNotification">
    read?: BoolWithAggregatesFilter<"InAppNotification"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"InAppNotification"> | Date | string
  }

  export type ScheduledNotificationWhereInput = {
    AND?: ScheduledNotificationWhereInput | ScheduledNotificationWhereInput[]
    OR?: ScheduledNotificationWhereInput[]
    NOT?: ScheduledNotificationWhereInput | ScheduledNotificationWhereInput[]
    id?: StringFilter<"ScheduledNotification"> | string
    userId?: StringFilter<"ScheduledNotification"> | string
    type?: StringFilter<"ScheduledNotification"> | string
    title?: StringFilter<"ScheduledNotification"> | string
    message?: StringFilter<"ScheduledNotification"> | string
    data?: JsonNullableFilter<"ScheduledNotification">
    priority?: StringFilter<"ScheduledNotification"> | string
    scheduledFor?: DateTimeFilter<"ScheduledNotification"> | Date | string
    status?: EnumScheduledNotificationStatusFilter<"ScheduledNotification"> | $Enums.ScheduledNotificationStatus
    sentAt?: DateTimeNullableFilter<"ScheduledNotification"> | Date | string | null
    createdAt?: DateTimeFilter<"ScheduledNotification"> | Date | string
  }

  export type ScheduledNotificationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    data?: SortOrderInput | SortOrder
    priority?: SortOrder
    scheduledFor?: SortOrder
    status?: SortOrder
    sentAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
  }

  export type ScheduledNotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ScheduledNotificationWhereInput | ScheduledNotificationWhereInput[]
    OR?: ScheduledNotificationWhereInput[]
    NOT?: ScheduledNotificationWhereInput | ScheduledNotificationWhereInput[]
    userId?: StringFilter<"ScheduledNotification"> | string
    type?: StringFilter<"ScheduledNotification"> | string
    title?: StringFilter<"ScheduledNotification"> | string
    message?: StringFilter<"ScheduledNotification"> | string
    data?: JsonNullableFilter<"ScheduledNotification">
    priority?: StringFilter<"ScheduledNotification"> | string
    scheduledFor?: DateTimeFilter<"ScheduledNotification"> | Date | string
    status?: EnumScheduledNotificationStatusFilter<"ScheduledNotification"> | $Enums.ScheduledNotificationStatus
    sentAt?: DateTimeNullableFilter<"ScheduledNotification"> | Date | string | null
    createdAt?: DateTimeFilter<"ScheduledNotification"> | Date | string
  }, "id">

  export type ScheduledNotificationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    data?: SortOrderInput | SortOrder
    priority?: SortOrder
    scheduledFor?: SortOrder
    status?: SortOrder
    sentAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ScheduledNotificationCountOrderByAggregateInput
    _max?: ScheduledNotificationMaxOrderByAggregateInput
    _min?: ScheduledNotificationMinOrderByAggregateInput
  }

  export type ScheduledNotificationScalarWhereWithAggregatesInput = {
    AND?: ScheduledNotificationScalarWhereWithAggregatesInput | ScheduledNotificationScalarWhereWithAggregatesInput[]
    OR?: ScheduledNotificationScalarWhereWithAggregatesInput[]
    NOT?: ScheduledNotificationScalarWhereWithAggregatesInput | ScheduledNotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ScheduledNotification"> | string
    userId?: StringWithAggregatesFilter<"ScheduledNotification"> | string
    type?: StringWithAggregatesFilter<"ScheduledNotification"> | string
    title?: StringWithAggregatesFilter<"ScheduledNotification"> | string
    message?: StringWithAggregatesFilter<"ScheduledNotification"> | string
    data?: JsonNullableWithAggregatesFilter<"ScheduledNotification">
    priority?: StringWithAggregatesFilter<"ScheduledNotification"> | string
    scheduledFor?: DateTimeWithAggregatesFilter<"ScheduledNotification"> | Date | string
    status?: EnumScheduledNotificationStatusWithAggregatesFilter<"ScheduledNotification"> | $Enums.ScheduledNotificationStatus
    sentAt?: DateTimeNullableWithAggregatesFilter<"ScheduledNotification"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ScheduledNotification"> | Date | string
  }

  export type NotificationLogWhereInput = {
    AND?: NotificationLogWhereInput | NotificationLogWhereInput[]
    OR?: NotificationLogWhereInput[]
    NOT?: NotificationLogWhereInput | NotificationLogWhereInput[]
    id?: StringFilter<"NotificationLog"> | string
    userId?: StringFilter<"NotificationLog"> | string
    type?: StringFilter<"NotificationLog"> | string
    title?: StringFilter<"NotificationLog"> | string
    message?: StringFilter<"NotificationLog"> | string
    data?: JsonNullableFilter<"NotificationLog">
    priority?: StringFilter<"NotificationLog"> | string
    sentAt?: DateTimeFilter<"NotificationLog"> | Date | string
  }

  export type NotificationLogOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    data?: SortOrderInput | SortOrder
    priority?: SortOrder
    sentAt?: SortOrder
  }

  export type NotificationLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationLogWhereInput | NotificationLogWhereInput[]
    OR?: NotificationLogWhereInput[]
    NOT?: NotificationLogWhereInput | NotificationLogWhereInput[]
    userId?: StringFilter<"NotificationLog"> | string
    type?: StringFilter<"NotificationLog"> | string
    title?: StringFilter<"NotificationLog"> | string
    message?: StringFilter<"NotificationLog"> | string
    data?: JsonNullableFilter<"NotificationLog">
    priority?: StringFilter<"NotificationLog"> | string
    sentAt?: DateTimeFilter<"NotificationLog"> | Date | string
  }, "id">

  export type NotificationLogOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    data?: SortOrderInput | SortOrder
    priority?: SortOrder
    sentAt?: SortOrder
    _count?: NotificationLogCountOrderByAggregateInput
    _max?: NotificationLogMaxOrderByAggregateInput
    _min?: NotificationLogMinOrderByAggregateInput
  }

  export type NotificationLogScalarWhereWithAggregatesInput = {
    AND?: NotificationLogScalarWhereWithAggregatesInput | NotificationLogScalarWhereWithAggregatesInput[]
    OR?: NotificationLogScalarWhereWithAggregatesInput[]
    NOT?: NotificationLogScalarWhereWithAggregatesInput | NotificationLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"NotificationLog"> | string
    userId?: StringWithAggregatesFilter<"NotificationLog"> | string
    type?: StringWithAggregatesFilter<"NotificationLog"> | string
    title?: StringWithAggregatesFilter<"NotificationLog"> | string
    message?: StringWithAggregatesFilter<"NotificationLog"> | string
    data?: JsonNullableWithAggregatesFilter<"NotificationLog">
    priority?: StringWithAggregatesFilter<"NotificationLog"> | string
    sentAt?: DateTimeWithAggregatesFilter<"NotificationLog"> | Date | string
  }

  export type UserNotificationPreferencesWhereInput = {
    AND?: UserNotificationPreferencesWhereInput | UserNotificationPreferencesWhereInput[]
    OR?: UserNotificationPreferencesWhereInput[]
    NOT?: UserNotificationPreferencesWhereInput | UserNotificationPreferencesWhereInput[]
    id?: StringFilter<"UserNotificationPreferences"> | string
    userId?: StringFilter<"UserNotificationPreferences"> | string
    emailEnabled?: BoolFilter<"UserNotificationPreferences"> | boolean
    smsEnabled?: BoolFilter<"UserNotificationPreferences"> | boolean
    inAppEnabled?: BoolFilter<"UserNotificationPreferences"> | boolean
    pushEnabled?: BoolFilter<"UserNotificationPreferences"> | boolean
    quietHours?: JsonNullableFilter<"UserNotificationPreferences">
    notificationTypes?: JsonNullableFilter<"UserNotificationPreferences">
    createdAt?: DateTimeFilter<"UserNotificationPreferences"> | Date | string
    updatedAt?: DateTimeFilter<"UserNotificationPreferences"> | Date | string
  }

  export type UserNotificationPreferencesOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    emailEnabled?: SortOrder
    smsEnabled?: SortOrder
    inAppEnabled?: SortOrder
    pushEnabled?: SortOrder
    quietHours?: SortOrderInput | SortOrder
    notificationTypes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserNotificationPreferencesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: UserNotificationPreferencesWhereInput | UserNotificationPreferencesWhereInput[]
    OR?: UserNotificationPreferencesWhereInput[]
    NOT?: UserNotificationPreferencesWhereInput | UserNotificationPreferencesWhereInput[]
    emailEnabled?: BoolFilter<"UserNotificationPreferences"> | boolean
    smsEnabled?: BoolFilter<"UserNotificationPreferences"> | boolean
    inAppEnabled?: BoolFilter<"UserNotificationPreferences"> | boolean
    pushEnabled?: BoolFilter<"UserNotificationPreferences"> | boolean
    quietHours?: JsonNullableFilter<"UserNotificationPreferences">
    notificationTypes?: JsonNullableFilter<"UserNotificationPreferences">
    createdAt?: DateTimeFilter<"UserNotificationPreferences"> | Date | string
    updatedAt?: DateTimeFilter<"UserNotificationPreferences"> | Date | string
  }, "id" | "userId">

  export type UserNotificationPreferencesOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    emailEnabled?: SortOrder
    smsEnabled?: SortOrder
    inAppEnabled?: SortOrder
    pushEnabled?: SortOrder
    quietHours?: SortOrderInput | SortOrder
    notificationTypes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserNotificationPreferencesCountOrderByAggregateInput
    _max?: UserNotificationPreferencesMaxOrderByAggregateInput
    _min?: UserNotificationPreferencesMinOrderByAggregateInput
  }

  export type UserNotificationPreferencesScalarWhereWithAggregatesInput = {
    AND?: UserNotificationPreferencesScalarWhereWithAggregatesInput | UserNotificationPreferencesScalarWhereWithAggregatesInput[]
    OR?: UserNotificationPreferencesScalarWhereWithAggregatesInput[]
    NOT?: UserNotificationPreferencesScalarWhereWithAggregatesInput | UserNotificationPreferencesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserNotificationPreferences"> | string
    userId?: StringWithAggregatesFilter<"UserNotificationPreferences"> | string
    emailEnabled?: BoolWithAggregatesFilter<"UserNotificationPreferences"> | boolean
    smsEnabled?: BoolWithAggregatesFilter<"UserNotificationPreferences"> | boolean
    inAppEnabled?: BoolWithAggregatesFilter<"UserNotificationPreferences"> | boolean
    pushEnabled?: BoolWithAggregatesFilter<"UserNotificationPreferences"> | boolean
    quietHours?: JsonNullableWithAggregatesFilter<"UserNotificationPreferences">
    notificationTypes?: JsonNullableWithAggregatesFilter<"UserNotificationPreferences">
    createdAt?: DateTimeWithAggregatesFilter<"UserNotificationPreferences"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserNotificationPreferences"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    userType?: $Enums.UserType
    phone?: string | null
    status?: $Enums.UserStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    student?: StudentCreateNestedOneWithoutUserInput
    consultant?: ConsultantCreateNestedOneWithoutUserInput
    admin?: AdminCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    userType?: $Enums.UserType
    phone?: string | null
    status?: $Enums.UserStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    student?: StudentUncheckedCreateNestedOneWithoutUserInput
    consultant?: ConsultantUncheckedCreateNestedOneWithoutUserInput
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneWithoutUserNestedInput
    consultant?: ConsultantUpdateOneWithoutUserNestedInput
    admin?: AdminUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUncheckedUpdateOneWithoutUserNestedInput
    consultant?: ConsultantUncheckedUpdateOneWithoutUserNestedInput
    admin?: AdminUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    userType?: $Enums.UserType
    phone?: string | null
    status?: $Enums.UserStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentCreateInput = {
    id?: string
    kajabiUserId?: string | null
    courseCompletionDate: Date | string
    totalVerifiedHours?: number
    totalVideoHours?: number
    certificationStatus?: $Enums.StudentStatus
    preferredSessionLength?: number
    consultationPreferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutStudentInput
    consultationSessions?: ConsultationSessionCreateNestedManyWithoutStudentInput
    studentDocuments?: StudentDocumentCreateNestedManyWithoutStudentInput
    sessionHistory?: SessionHistoryCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateInput = {
    id?: string
    userId: string
    kajabiUserId?: string | null
    courseCompletionDate: Date | string
    totalVerifiedHours?: number
    totalVideoHours?: number
    certificationStatus?: $Enums.StudentStatus
    preferredSessionLength?: number
    consultationPreferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    consultationSessions?: ConsultationSessionUncheckedCreateNestedManyWithoutStudentInput
    studentDocuments?: StudentDocumentUncheckedCreateNestedManyWithoutStudentInput
    sessionHistory?: SessionHistoryUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    kajabiUserId?: NullableStringFieldUpdateOperationsInput | string | null
    courseCompletionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalVerifiedHours?: FloatFieldUpdateOperationsInput | number
    totalVideoHours?: FloatFieldUpdateOperationsInput | number
    certificationStatus?: EnumStudentStatusFieldUpdateOperationsInput | $Enums.StudentStatus
    preferredSessionLength?: IntFieldUpdateOperationsInput | number
    consultationPreferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStudentNestedInput
    consultationSessions?: ConsultationSessionUpdateManyWithoutStudentNestedInput
    studentDocuments?: StudentDocumentUpdateManyWithoutStudentNestedInput
    sessionHistory?: SessionHistoryUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    kajabiUserId?: NullableStringFieldUpdateOperationsInput | string | null
    courseCompletionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalVerifiedHours?: FloatFieldUpdateOperationsInput | number
    totalVideoHours?: FloatFieldUpdateOperationsInput | number
    certificationStatus?: EnumStudentStatusFieldUpdateOperationsInput | $Enums.StudentStatus
    preferredSessionLength?: IntFieldUpdateOperationsInput | number
    consultationPreferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    consultationSessions?: ConsultationSessionUncheckedUpdateManyWithoutStudentNestedInput
    studentDocuments?: StudentDocumentUncheckedUpdateManyWithoutStudentNestedInput
    sessionHistory?: SessionHistoryUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type StudentCreateManyInput = {
    id?: string
    userId: string
    kajabiUserId?: string | null
    courseCompletionDate: Date | string
    totalVerifiedHours?: number
    totalVideoHours?: number
    certificationStatus?: $Enums.StudentStatus
    preferredSessionLength?: number
    consultationPreferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    kajabiUserId?: NullableStringFieldUpdateOperationsInput | string | null
    courseCompletionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalVerifiedHours?: FloatFieldUpdateOperationsInput | number
    totalVideoHours?: FloatFieldUpdateOperationsInput | number
    certificationStatus?: EnumStudentStatusFieldUpdateOperationsInput | $Enums.StudentStatus
    preferredSessionLength?: IntFieldUpdateOperationsInput | number
    consultationPreferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    kajabiUserId?: NullableStringFieldUpdateOperationsInput | string | null
    courseCompletionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalVerifiedHours?: FloatFieldUpdateOperationsInput | number
    totalVideoHours?: FloatFieldUpdateOperationsInput | number
    certificationStatus?: EnumStudentStatusFieldUpdateOperationsInput | $Enums.StudentStatus
    preferredSessionLength?: IntFieldUpdateOperationsInput | number
    consultationPreferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConsultantCreateInput = {
    id?: string
    bio?: string | null
    specialties?: ConsultantCreatespecialtiesInput | string[]
    hourlyRate?: number
    isActive?: boolean
    timezone?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutConsultantInput
    consultationSessions?: ConsultationSessionCreateNestedManyWithoutConsultantInput
    consultantAvailability?: ConsultantAvailabilityCreateNestedManyWithoutConsultantInput
    consultantPayments?: ConsultantPaymentCreateNestedManyWithoutConsultantInput
  }

  export type ConsultantUncheckedCreateInput = {
    id?: string
    userId: string
    bio?: string | null
    specialties?: ConsultantCreatespecialtiesInput | string[]
    hourlyRate?: number
    isActive?: boolean
    timezone?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    consultationSessions?: ConsultationSessionUncheckedCreateNestedManyWithoutConsultantInput
    consultantAvailability?: ConsultantAvailabilityUncheckedCreateNestedManyWithoutConsultantInput
    consultantPayments?: ConsultantPaymentUncheckedCreateNestedManyWithoutConsultantInput
  }

  export type ConsultantUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    specialties?: ConsultantUpdatespecialtiesInput | string[]
    hourlyRate?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    timezone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutConsultantNestedInput
    consultationSessions?: ConsultationSessionUpdateManyWithoutConsultantNestedInput
    consultantAvailability?: ConsultantAvailabilityUpdateManyWithoutConsultantNestedInput
    consultantPayments?: ConsultantPaymentUpdateManyWithoutConsultantNestedInput
  }

  export type ConsultantUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    specialties?: ConsultantUpdatespecialtiesInput | string[]
    hourlyRate?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    timezone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    consultationSessions?: ConsultationSessionUncheckedUpdateManyWithoutConsultantNestedInput
    consultantAvailability?: ConsultantAvailabilityUncheckedUpdateManyWithoutConsultantNestedInput
    consultantPayments?: ConsultantPaymentUncheckedUpdateManyWithoutConsultantNestedInput
  }

  export type ConsultantCreateManyInput = {
    id?: string
    userId: string
    bio?: string | null
    specialties?: ConsultantCreatespecialtiesInput | string[]
    hourlyRate?: number
    isActive?: boolean
    timezone?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConsultantUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    specialties?: ConsultantUpdatespecialtiesInput | string[]
    hourlyRate?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    timezone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConsultantUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    specialties?: ConsultantUpdatespecialtiesInput | string[]
    hourlyRate?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    timezone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminCreateInput = {
    id?: string
    role?: string
    permissions?: AdminCreatepermissionsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAdminInput
  }

  export type AdminUncheckedCreateInput = {
    id?: string
    userId: string
    role?: string
    permissions?: AdminCreatepermissionsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    permissions?: AdminUpdatepermissionsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAdminNestedInput
  }

  export type AdminUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    permissions?: AdminUpdatepermissionsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminCreateManyInput = {
    id?: string
    userId: string
    role?: string
    permissions?: AdminCreatepermissionsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    permissions?: AdminUpdatepermissionsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    permissions?: AdminUpdatepermissionsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConsultationSessionCreateInput = {
    id?: string
    scheduledStart: Date | string
    scheduledEnd: Date | string
    actualStart?: Date | string | null
    actualEnd?: Date | string | null
    status?: $Enums.SessionStatus
    sessionType?: string
    studentVerifiedAt?: Date | string | null
    consultantVerifiedAt?: Date | string | null
    studentNotes?: string | null
    consultantNotes?: string | null
    sessionRating?: number | null
    technicalIssuesReported?: boolean
    makeupSessionFor?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutConsultationSessionsInput
    consultant: ConsultantCreateNestedOneWithoutConsultationSessionsInput
    videoSession?: VideoSessionCreateNestedOneWithoutConsultationSessionInput
  }

  export type ConsultationSessionUncheckedCreateInput = {
    id?: string
    studentId: string
    consultantId: string
    scheduledStart: Date | string
    scheduledEnd: Date | string
    actualStart?: Date | string | null
    actualEnd?: Date | string | null
    status?: $Enums.SessionStatus
    sessionType?: string
    studentVerifiedAt?: Date | string | null
    consultantVerifiedAt?: Date | string | null
    studentNotes?: string | null
    consultantNotes?: string | null
    sessionRating?: number | null
    technicalIssuesReported?: boolean
    makeupSessionFor?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    videoSession?: VideoSessionUncheckedCreateNestedOneWithoutConsultationSessionInput
  }

  export type ConsultationSessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduledStart?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    actualStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    sessionType?: StringFieldUpdateOperationsInput | string
    studentVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    consultantVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    studentNotes?: NullableStringFieldUpdateOperationsInput | string | null
    consultantNotes?: NullableStringFieldUpdateOperationsInput | string | null
    sessionRating?: NullableIntFieldUpdateOperationsInput | number | null
    technicalIssuesReported?: BoolFieldUpdateOperationsInput | boolean
    makeupSessionFor?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutConsultationSessionsNestedInput
    consultant?: ConsultantUpdateOneRequiredWithoutConsultationSessionsNestedInput
    videoSession?: VideoSessionUpdateOneWithoutConsultationSessionNestedInput
  }

  export type ConsultationSessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    consultantId?: StringFieldUpdateOperationsInput | string
    scheduledStart?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    actualStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    sessionType?: StringFieldUpdateOperationsInput | string
    studentVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    consultantVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    studentNotes?: NullableStringFieldUpdateOperationsInput | string | null
    consultantNotes?: NullableStringFieldUpdateOperationsInput | string | null
    sessionRating?: NullableIntFieldUpdateOperationsInput | number | null
    technicalIssuesReported?: BoolFieldUpdateOperationsInput | boolean
    makeupSessionFor?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    videoSession?: VideoSessionUncheckedUpdateOneWithoutConsultationSessionNestedInput
  }

  export type ConsultationSessionCreateManyInput = {
    id?: string
    studentId: string
    consultantId: string
    scheduledStart: Date | string
    scheduledEnd: Date | string
    actualStart?: Date | string | null
    actualEnd?: Date | string | null
    status?: $Enums.SessionStatus
    sessionType?: string
    studentVerifiedAt?: Date | string | null
    consultantVerifiedAt?: Date | string | null
    studentNotes?: string | null
    consultantNotes?: string | null
    sessionRating?: number | null
    technicalIssuesReported?: boolean
    makeupSessionFor?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConsultationSessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduledStart?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    actualStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    sessionType?: StringFieldUpdateOperationsInput | string
    studentVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    consultantVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    studentNotes?: NullableStringFieldUpdateOperationsInput | string | null
    consultantNotes?: NullableStringFieldUpdateOperationsInput | string | null
    sessionRating?: NullableIntFieldUpdateOperationsInput | number | null
    technicalIssuesReported?: BoolFieldUpdateOperationsInput | boolean
    makeupSessionFor?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConsultationSessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    consultantId?: StringFieldUpdateOperationsInput | string
    scheduledStart?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    actualStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    sessionType?: StringFieldUpdateOperationsInput | string
    studentVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    consultantVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    studentNotes?: NullableStringFieldUpdateOperationsInput | string | null
    consultantNotes?: NullableStringFieldUpdateOperationsInput | string | null
    sessionRating?: NullableIntFieldUpdateOperationsInput | number | null
    technicalIssuesReported?: BoolFieldUpdateOperationsInput | boolean
    makeupSessionFor?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoSessionCreateInput = {
    id?: string
    roomId: string
    recordingEnabled?: boolean
    recordingUrl?: string | null
    recordingDurationSeconds?: number | null
    videoQuality?: string
    connectionQualityAvg?: number | null
    bandwidthUsageMb?: number | null
    technicalIssues?: NullableJsonNullValueInput | InputJsonValue
    sessionMetadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    consultationSession: ConsultationSessionCreateNestedOneWithoutVideoSessionInput
    videoParticipants?: VideoParticipantCreateNestedManyWithoutVideoSessionInput
  }

  export type VideoSessionUncheckedCreateInput = {
    id?: string
    consultationSessionId: string
    roomId: string
    recordingEnabled?: boolean
    recordingUrl?: string | null
    recordingDurationSeconds?: number | null
    videoQuality?: string
    connectionQualityAvg?: number | null
    bandwidthUsageMb?: number | null
    technicalIssues?: NullableJsonNullValueInput | InputJsonValue
    sessionMetadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    videoParticipants?: VideoParticipantUncheckedCreateNestedManyWithoutVideoSessionInput
  }

  export type VideoSessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    recordingEnabled?: BoolFieldUpdateOperationsInput | boolean
    recordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    recordingDurationSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    videoQuality?: StringFieldUpdateOperationsInput | string
    connectionQualityAvg?: NullableFloatFieldUpdateOperationsInput | number | null
    bandwidthUsageMb?: NullableFloatFieldUpdateOperationsInput | number | null
    technicalIssues?: NullableJsonNullValueInput | InputJsonValue
    sessionMetadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    consultationSession?: ConsultationSessionUpdateOneRequiredWithoutVideoSessionNestedInput
    videoParticipants?: VideoParticipantUpdateManyWithoutVideoSessionNestedInput
  }

  export type VideoSessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    consultationSessionId?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    recordingEnabled?: BoolFieldUpdateOperationsInput | boolean
    recordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    recordingDurationSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    videoQuality?: StringFieldUpdateOperationsInput | string
    connectionQualityAvg?: NullableFloatFieldUpdateOperationsInput | number | null
    bandwidthUsageMb?: NullableFloatFieldUpdateOperationsInput | number | null
    technicalIssues?: NullableJsonNullValueInput | InputJsonValue
    sessionMetadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    videoParticipants?: VideoParticipantUncheckedUpdateManyWithoutVideoSessionNestedInput
  }

  export type VideoSessionCreateManyInput = {
    id?: string
    consultationSessionId: string
    roomId: string
    recordingEnabled?: boolean
    recordingUrl?: string | null
    recordingDurationSeconds?: number | null
    videoQuality?: string
    connectionQualityAvg?: number | null
    bandwidthUsageMb?: number | null
    technicalIssues?: NullableJsonNullValueInput | InputJsonValue
    sessionMetadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type VideoSessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    recordingEnabled?: BoolFieldUpdateOperationsInput | boolean
    recordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    recordingDurationSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    videoQuality?: StringFieldUpdateOperationsInput | string
    connectionQualityAvg?: NullableFloatFieldUpdateOperationsInput | number | null
    bandwidthUsageMb?: NullableFloatFieldUpdateOperationsInput | number | null
    technicalIssues?: NullableJsonNullValueInput | InputJsonValue
    sessionMetadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoSessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    consultationSessionId?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    recordingEnabled?: BoolFieldUpdateOperationsInput | boolean
    recordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    recordingDurationSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    videoQuality?: StringFieldUpdateOperationsInput | string
    connectionQualityAvg?: NullableFloatFieldUpdateOperationsInput | number | null
    bandwidthUsageMb?: NullableFloatFieldUpdateOperationsInput | number | null
    technicalIssues?: NullableJsonNullValueInput | InputJsonValue
    sessionMetadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoParticipantCreateInput = {
    id?: string
    userId: string
    userType: $Enums.UserType
    joinTime: Date | string
    leaveTime?: Date | string | null
    totalDurationSeconds?: number | null
    audioQualityAvg?: number | null
    videoQualityAvg?: number | null
    screenShareDurationSeconds?: number
    chatMessagesCount?: number
    connectionInterruptions?: number
    createdAt?: Date | string
    videoSession: VideoSessionCreateNestedOneWithoutVideoParticipantsInput
  }

  export type VideoParticipantUncheckedCreateInput = {
    id?: string
    videoSessionId: string
    userId: string
    userType: $Enums.UserType
    joinTime: Date | string
    leaveTime?: Date | string | null
    totalDurationSeconds?: number | null
    audioQualityAvg?: number | null
    videoQualityAvg?: number | null
    screenShareDurationSeconds?: number
    chatMessagesCount?: number
    connectionInterruptions?: number
    createdAt?: Date | string
  }

  export type VideoParticipantUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    joinTime?: DateTimeFieldUpdateOperationsInput | Date | string
    leaveTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalDurationSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    audioQualityAvg?: NullableFloatFieldUpdateOperationsInput | number | null
    videoQualityAvg?: NullableFloatFieldUpdateOperationsInput | number | null
    screenShareDurationSeconds?: IntFieldUpdateOperationsInput | number
    chatMessagesCount?: IntFieldUpdateOperationsInput | number
    connectionInterruptions?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    videoSession?: VideoSessionUpdateOneRequiredWithoutVideoParticipantsNestedInput
  }

  export type VideoParticipantUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    videoSessionId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    joinTime?: DateTimeFieldUpdateOperationsInput | Date | string
    leaveTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalDurationSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    audioQualityAvg?: NullableFloatFieldUpdateOperationsInput | number | null
    videoQualityAvg?: NullableFloatFieldUpdateOperationsInput | number | null
    screenShareDurationSeconds?: IntFieldUpdateOperationsInput | number
    chatMessagesCount?: IntFieldUpdateOperationsInput | number
    connectionInterruptions?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoParticipantCreateManyInput = {
    id?: string
    videoSessionId: string
    userId: string
    userType: $Enums.UserType
    joinTime: Date | string
    leaveTime?: Date | string | null
    totalDurationSeconds?: number | null
    audioQualityAvg?: number | null
    videoQualityAvg?: number | null
    screenShareDurationSeconds?: number
    chatMessagesCount?: number
    connectionInterruptions?: number
    createdAt?: Date | string
  }

  export type VideoParticipantUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    joinTime?: DateTimeFieldUpdateOperationsInput | Date | string
    leaveTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalDurationSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    audioQualityAvg?: NullableFloatFieldUpdateOperationsInput | number | null
    videoQualityAvg?: NullableFloatFieldUpdateOperationsInput | number | null
    screenShareDurationSeconds?: IntFieldUpdateOperationsInput | number
    chatMessagesCount?: IntFieldUpdateOperationsInput | number
    connectionInterruptions?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoParticipantUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    videoSessionId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    joinTime?: DateTimeFieldUpdateOperationsInput | Date | string
    leaveTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalDurationSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    audioQualityAvg?: NullableFloatFieldUpdateOperationsInput | number | null
    videoQualityAvg?: NullableFloatFieldUpdateOperationsInput | number | null
    screenShareDurationSeconds?: IntFieldUpdateOperationsInput | number
    chatMessagesCount?: IntFieldUpdateOperationsInput | number
    connectionInterruptions?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConsultantAvailabilityCreateInput = {
    id?: string
    availabilityType: $Enums.AvailabilityType
    dayOfWeek?: number | null
    specificDate?: Date | string | null
    startTime: string
    endTime: string
    maxSessions?: number
    bufferMinutes?: number
    isAvailable?: boolean
    bookingWindowDays?: number
    minimumNoticeHours?: number
    autoApprove?: boolean
    timezone: string
    recurringPattern?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    consultant: ConsultantCreateNestedOneWithoutConsultantAvailabilityInput
  }

  export type ConsultantAvailabilityUncheckedCreateInput = {
    id?: string
    consultantId: string
    availabilityType: $Enums.AvailabilityType
    dayOfWeek?: number | null
    specificDate?: Date | string | null
    startTime: string
    endTime: string
    maxSessions?: number
    bufferMinutes?: number
    isAvailable?: boolean
    bookingWindowDays?: number
    minimumNoticeHours?: number
    autoApprove?: boolean
    timezone: string
    recurringPattern?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConsultantAvailabilityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    availabilityType?: EnumAvailabilityTypeFieldUpdateOperationsInput | $Enums.AvailabilityType
    dayOfWeek?: NullableIntFieldUpdateOperationsInput | number | null
    specificDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    maxSessions?: IntFieldUpdateOperationsInput | number
    bufferMinutes?: IntFieldUpdateOperationsInput | number
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    bookingWindowDays?: IntFieldUpdateOperationsInput | number
    minimumNoticeHours?: IntFieldUpdateOperationsInput | number
    autoApprove?: BoolFieldUpdateOperationsInput | boolean
    timezone?: StringFieldUpdateOperationsInput | string
    recurringPattern?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    consultant?: ConsultantUpdateOneRequiredWithoutConsultantAvailabilityNestedInput
  }

  export type ConsultantAvailabilityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    consultantId?: StringFieldUpdateOperationsInput | string
    availabilityType?: EnumAvailabilityTypeFieldUpdateOperationsInput | $Enums.AvailabilityType
    dayOfWeek?: NullableIntFieldUpdateOperationsInput | number | null
    specificDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    maxSessions?: IntFieldUpdateOperationsInput | number
    bufferMinutes?: IntFieldUpdateOperationsInput | number
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    bookingWindowDays?: IntFieldUpdateOperationsInput | number
    minimumNoticeHours?: IntFieldUpdateOperationsInput | number
    autoApprove?: BoolFieldUpdateOperationsInput | boolean
    timezone?: StringFieldUpdateOperationsInput | string
    recurringPattern?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConsultantAvailabilityCreateManyInput = {
    id?: string
    consultantId: string
    availabilityType: $Enums.AvailabilityType
    dayOfWeek?: number | null
    specificDate?: Date | string | null
    startTime: string
    endTime: string
    maxSessions?: number
    bufferMinutes?: number
    isAvailable?: boolean
    bookingWindowDays?: number
    minimumNoticeHours?: number
    autoApprove?: boolean
    timezone: string
    recurringPattern?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConsultantAvailabilityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    availabilityType?: EnumAvailabilityTypeFieldUpdateOperationsInput | $Enums.AvailabilityType
    dayOfWeek?: NullableIntFieldUpdateOperationsInput | number | null
    specificDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    maxSessions?: IntFieldUpdateOperationsInput | number
    bufferMinutes?: IntFieldUpdateOperationsInput | number
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    bookingWindowDays?: IntFieldUpdateOperationsInput | number
    minimumNoticeHours?: IntFieldUpdateOperationsInput | number
    autoApprove?: BoolFieldUpdateOperationsInput | boolean
    timezone?: StringFieldUpdateOperationsInput | string
    recurringPattern?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConsultantAvailabilityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    consultantId?: StringFieldUpdateOperationsInput | string
    availabilityType?: EnumAvailabilityTypeFieldUpdateOperationsInput | $Enums.AvailabilityType
    dayOfWeek?: NullableIntFieldUpdateOperationsInput | number | null
    specificDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    maxSessions?: IntFieldUpdateOperationsInput | number
    bufferMinutes?: IntFieldUpdateOperationsInput | number
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    bookingWindowDays?: IntFieldUpdateOperationsInput | number
    minimumNoticeHours?: IntFieldUpdateOperationsInput | number
    autoApprove?: BoolFieldUpdateOperationsInput | boolean
    timezone?: StringFieldUpdateOperationsInput | string
    recurringPattern?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentDocumentCreateInput = {
    id?: string
    documentType: $Enums.DocumentType
    fileName: string
    fileSizeBytes: number
    filePath: string
    mimeType: string
    extractedText?: string | null
    uploadTimestamp?: Date | string
    reviewStatus?: $Enums.ReviewStatus
    reviewedBy?: string | null
    reviewedAt?: Date | string | null
    reviewNotes?: string | null
    versionNumber?: number
    replacesDocumentId?: string | null
    autoValidationScore?: number | null
    requiresManualReview?: boolean
    createdAt?: Date | string
    student: StudentCreateNestedOneWithoutStudentDocumentsInput
  }

  export type StudentDocumentUncheckedCreateInput = {
    id?: string
    studentId: string
    documentType: $Enums.DocumentType
    fileName: string
    fileSizeBytes: number
    filePath: string
    mimeType: string
    extractedText?: string | null
    uploadTimestamp?: Date | string
    reviewStatus?: $Enums.ReviewStatus
    reviewedBy?: string | null
    reviewedAt?: Date | string | null
    reviewNotes?: string | null
    versionNumber?: number
    replacesDocumentId?: string | null
    autoValidationScore?: number | null
    requiresManualReview?: boolean
    createdAt?: Date | string
  }

  export type StudentDocumentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    fileName?: StringFieldUpdateOperationsInput | string
    fileSizeBytes?: IntFieldUpdateOperationsInput | number
    filePath?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    extractedText?: NullableStringFieldUpdateOperationsInput | string | null
    uploadTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewStatus?: EnumReviewStatusFieldUpdateOperationsInput | $Enums.ReviewStatus
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null
    versionNumber?: IntFieldUpdateOperationsInput | number
    replacesDocumentId?: NullableStringFieldUpdateOperationsInput | string | null
    autoValidationScore?: NullableFloatFieldUpdateOperationsInput | number | null
    requiresManualReview?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutStudentDocumentsNestedInput
  }

  export type StudentDocumentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    fileName?: StringFieldUpdateOperationsInput | string
    fileSizeBytes?: IntFieldUpdateOperationsInput | number
    filePath?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    extractedText?: NullableStringFieldUpdateOperationsInput | string | null
    uploadTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewStatus?: EnumReviewStatusFieldUpdateOperationsInput | $Enums.ReviewStatus
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null
    versionNumber?: IntFieldUpdateOperationsInput | number
    replacesDocumentId?: NullableStringFieldUpdateOperationsInput | string | null
    autoValidationScore?: NullableFloatFieldUpdateOperationsInput | number | null
    requiresManualReview?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentDocumentCreateManyInput = {
    id?: string
    studentId: string
    documentType: $Enums.DocumentType
    fileName: string
    fileSizeBytes: number
    filePath: string
    mimeType: string
    extractedText?: string | null
    uploadTimestamp?: Date | string
    reviewStatus?: $Enums.ReviewStatus
    reviewedBy?: string | null
    reviewedAt?: Date | string | null
    reviewNotes?: string | null
    versionNumber?: number
    replacesDocumentId?: string | null
    autoValidationScore?: number | null
    requiresManualReview?: boolean
    createdAt?: Date | string
  }

  export type StudentDocumentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    fileName?: StringFieldUpdateOperationsInput | string
    fileSizeBytes?: IntFieldUpdateOperationsInput | number
    filePath?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    extractedText?: NullableStringFieldUpdateOperationsInput | string | null
    uploadTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewStatus?: EnumReviewStatusFieldUpdateOperationsInput | $Enums.ReviewStatus
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null
    versionNumber?: IntFieldUpdateOperationsInput | number
    replacesDocumentId?: NullableStringFieldUpdateOperationsInput | string | null
    autoValidationScore?: NullableFloatFieldUpdateOperationsInput | number | null
    requiresManualReview?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentDocumentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    fileName?: StringFieldUpdateOperationsInput | string
    fileSizeBytes?: IntFieldUpdateOperationsInput | number
    filePath?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    extractedText?: NullableStringFieldUpdateOperationsInput | string | null
    uploadTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewStatus?: EnumReviewStatusFieldUpdateOperationsInput | $Enums.ReviewStatus
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null
    versionNumber?: IntFieldUpdateOperationsInput | number
    replacesDocumentId?: NullableStringFieldUpdateOperationsInput | string | null
    autoValidationScore?: NullableFloatFieldUpdateOperationsInput | number | null
    requiresManualReview?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionHistoryCreateInput = {
    id?: string
    sessionDate: Date | string
    sessionDuration: number
    consultantId: string
    sessionType: string
    status: string
    rating?: number | null
    createdAt?: Date | string
    student: StudentCreateNestedOneWithoutSessionHistoryInput
  }

  export type SessionHistoryUncheckedCreateInput = {
    id?: string
    studentId: string
    sessionDate: Date | string
    sessionDuration: number
    consultantId: string
    sessionType: string
    status: string
    rating?: number | null
    createdAt?: Date | string
  }

  export type SessionHistoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionDuration?: IntFieldUpdateOperationsInput | number
    consultantId?: StringFieldUpdateOperationsInput | string
    sessionType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutSessionHistoryNestedInput
  }

  export type SessionHistoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    sessionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionDuration?: IntFieldUpdateOperationsInput | number
    consultantId?: StringFieldUpdateOperationsInput | string
    sessionType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionHistoryCreateManyInput = {
    id?: string
    studentId: string
    sessionDate: Date | string
    sessionDuration: number
    consultantId: string
    sessionType: string
    status: string
    rating?: number | null
    createdAt?: Date | string
  }

  export type SessionHistoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionDuration?: IntFieldUpdateOperationsInput | number
    consultantId?: StringFieldUpdateOperationsInput | string
    sessionType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionHistoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    sessionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionDuration?: IntFieldUpdateOperationsInput | number
    consultantId?: StringFieldUpdateOperationsInput | string
    sessionType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConsultantPaymentCreateInput = {
    id?: string
    paymentPeriod: string
    totalHours: number
    hourlyRate: number
    totalAmount: number
    paymentStatus?: $Enums.PaymentStatus
    paymentDate?: Date | string | null
    sessionBreakdown?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    consultant: ConsultantCreateNestedOneWithoutConsultantPaymentsInput
  }

  export type ConsultantPaymentUncheckedCreateInput = {
    id?: string
    consultantId: string
    paymentPeriod: string
    totalHours: number
    hourlyRate: number
    totalAmount: number
    paymentStatus?: $Enums.PaymentStatus
    paymentDate?: Date | string | null
    sessionBreakdown?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ConsultantPaymentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentPeriod?: StringFieldUpdateOperationsInput | string
    totalHours?: FloatFieldUpdateOperationsInput | number
    hourlyRate?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessionBreakdown?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    consultant?: ConsultantUpdateOneRequiredWithoutConsultantPaymentsNestedInput
  }

  export type ConsultantPaymentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    consultantId?: StringFieldUpdateOperationsInput | string
    paymentPeriod?: StringFieldUpdateOperationsInput | string
    totalHours?: FloatFieldUpdateOperationsInput | number
    hourlyRate?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessionBreakdown?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConsultantPaymentCreateManyInput = {
    id?: string
    consultantId: string
    paymentPeriod: string
    totalHours: number
    hourlyRate: number
    totalAmount: number
    paymentStatus?: $Enums.PaymentStatus
    paymentDate?: Date | string | null
    sessionBreakdown?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ConsultantPaymentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentPeriod?: StringFieldUpdateOperationsInput | string
    totalHours?: FloatFieldUpdateOperationsInput | number
    hourlyRate?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessionBreakdown?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConsultantPaymentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    consultantId?: StringFieldUpdateOperationsInput | string
    paymentPeriod?: StringFieldUpdateOperationsInput | string
    totalHours?: FloatFieldUpdateOperationsInput | number
    hourlyRate?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessionBreakdown?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemHealthMetricCreateInput = {
    id?: string
    metricType: string
    metricValue: number
    metricUnit?: string | null
    timestamp?: Date | string
    additionalData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type SystemHealthMetricUncheckedCreateInput = {
    id?: string
    metricType: string
    metricValue: number
    metricUnit?: string | null
    timestamp?: Date | string
    additionalData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type SystemHealthMetricUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    metricType?: StringFieldUpdateOperationsInput | string
    metricValue?: FloatFieldUpdateOperationsInput | number
    metricUnit?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    additionalData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemHealthMetricUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    metricType?: StringFieldUpdateOperationsInput | string
    metricValue?: FloatFieldUpdateOperationsInput | number
    metricUnit?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    additionalData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemHealthMetricCreateManyInput = {
    id?: string
    metricType: string
    metricValue: number
    metricUnit?: string | null
    timestamp?: Date | string
    additionalData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type SystemHealthMetricUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    metricType?: StringFieldUpdateOperationsInput | string
    metricValue?: FloatFieldUpdateOperationsInput | number
    metricUnit?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    additionalData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemHealthMetricUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    metricType?: StringFieldUpdateOperationsInput | string
    metricValue?: FloatFieldUpdateOperationsInput | number
    metricUnit?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    additionalData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InAppNotificationCreateInput = {
    id?: string
    userId: string
    title: string
    message: string
    type: string
    data?: NullableJsonNullValueInput | InputJsonValue
    read?: boolean
    createdAt?: Date | string
  }

  export type InAppNotificationUncheckedCreateInput = {
    id?: string
    userId: string
    title: string
    message: string
    type: string
    data?: NullableJsonNullValueInput | InputJsonValue
    read?: boolean
    createdAt?: Date | string
  }

  export type InAppNotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InAppNotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InAppNotificationCreateManyInput = {
    id?: string
    userId: string
    title: string
    message: string
    type: string
    data?: NullableJsonNullValueInput | InputJsonValue
    read?: boolean
    createdAt?: Date | string
  }

  export type InAppNotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InAppNotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduledNotificationCreateInput = {
    id?: string
    userId: string
    type: string
    title: string
    message: string
    data?: NullableJsonNullValueInput | InputJsonValue
    priority: string
    scheduledFor: Date | string
    status?: $Enums.ScheduledNotificationStatus
    sentAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ScheduledNotificationUncheckedCreateInput = {
    id?: string
    userId: string
    type: string
    title: string
    message: string
    data?: NullableJsonNullValueInput | InputJsonValue
    priority: string
    scheduledFor: Date | string
    status?: $Enums.ScheduledNotificationStatus
    sentAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ScheduledNotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    priority?: StringFieldUpdateOperationsInput | string
    scheduledFor?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumScheduledNotificationStatusFieldUpdateOperationsInput | $Enums.ScheduledNotificationStatus
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduledNotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    priority?: StringFieldUpdateOperationsInput | string
    scheduledFor?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumScheduledNotificationStatusFieldUpdateOperationsInput | $Enums.ScheduledNotificationStatus
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduledNotificationCreateManyInput = {
    id?: string
    userId: string
    type: string
    title: string
    message: string
    data?: NullableJsonNullValueInput | InputJsonValue
    priority: string
    scheduledFor: Date | string
    status?: $Enums.ScheduledNotificationStatus
    sentAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ScheduledNotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    priority?: StringFieldUpdateOperationsInput | string
    scheduledFor?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumScheduledNotificationStatusFieldUpdateOperationsInput | $Enums.ScheduledNotificationStatus
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduledNotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    priority?: StringFieldUpdateOperationsInput | string
    scheduledFor?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumScheduledNotificationStatusFieldUpdateOperationsInput | $Enums.ScheduledNotificationStatus
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationLogCreateInput = {
    id?: string
    userId: string
    type: string
    title: string
    message: string
    data?: NullableJsonNullValueInput | InputJsonValue
    priority: string
    sentAt?: Date | string
  }

  export type NotificationLogUncheckedCreateInput = {
    id?: string
    userId: string
    type: string
    title: string
    message: string
    data?: NullableJsonNullValueInput | InputJsonValue
    priority: string
    sentAt?: Date | string
  }

  export type NotificationLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    priority?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    priority?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationLogCreateManyInput = {
    id?: string
    userId: string
    type: string
    title: string
    message: string
    data?: NullableJsonNullValueInput | InputJsonValue
    priority: string
    sentAt?: Date | string
  }

  export type NotificationLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    priority?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    priority?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserNotificationPreferencesCreateInput = {
    id?: string
    userId: string
    emailEnabled?: boolean
    smsEnabled?: boolean
    inAppEnabled?: boolean
    pushEnabled?: boolean
    quietHours?: NullableJsonNullValueInput | InputJsonValue
    notificationTypes?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserNotificationPreferencesUncheckedCreateInput = {
    id?: string
    userId: string
    emailEnabled?: boolean
    smsEnabled?: boolean
    inAppEnabled?: boolean
    pushEnabled?: boolean
    quietHours?: NullableJsonNullValueInput | InputJsonValue
    notificationTypes?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserNotificationPreferencesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    emailEnabled?: BoolFieldUpdateOperationsInput | boolean
    smsEnabled?: BoolFieldUpdateOperationsInput | boolean
    inAppEnabled?: BoolFieldUpdateOperationsInput | boolean
    pushEnabled?: BoolFieldUpdateOperationsInput | boolean
    quietHours?: NullableJsonNullValueInput | InputJsonValue
    notificationTypes?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserNotificationPreferencesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    emailEnabled?: BoolFieldUpdateOperationsInput | boolean
    smsEnabled?: BoolFieldUpdateOperationsInput | boolean
    inAppEnabled?: BoolFieldUpdateOperationsInput | boolean
    pushEnabled?: BoolFieldUpdateOperationsInput | boolean
    quietHours?: NullableJsonNullValueInput | InputJsonValue
    notificationTypes?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserNotificationPreferencesCreateManyInput = {
    id?: string
    userId: string
    emailEnabled?: boolean
    smsEnabled?: boolean
    inAppEnabled?: boolean
    pushEnabled?: boolean
    quietHours?: NullableJsonNullValueInput | InputJsonValue
    notificationTypes?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserNotificationPreferencesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    emailEnabled?: BoolFieldUpdateOperationsInput | boolean
    smsEnabled?: BoolFieldUpdateOperationsInput | boolean
    inAppEnabled?: BoolFieldUpdateOperationsInput | boolean
    pushEnabled?: BoolFieldUpdateOperationsInput | boolean
    quietHours?: NullableJsonNullValueInput | InputJsonValue
    notificationTypes?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserNotificationPreferencesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    emailEnabled?: BoolFieldUpdateOperationsInput | boolean
    smsEnabled?: BoolFieldUpdateOperationsInput | boolean
    inAppEnabled?: BoolFieldUpdateOperationsInput | boolean
    pushEnabled?: BoolFieldUpdateOperationsInput | boolean
    quietHours?: NullableJsonNullValueInput | InputJsonValue
    notificationTypes?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type EnumUserTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.UserType | EnumUserTypeFieldRefInput<$PrismaModel>
    in?: $Enums.UserType[] | ListEnumUserTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserType[] | ListEnumUserTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumUserTypeFilter<$PrismaModel> | $Enums.UserType
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumUserStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserStatusFilter<$PrismaModel> | $Enums.UserStatus
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type StudentNullableRelationFilter = {
    is?: StudentWhereInput | null
    isNot?: StudentWhereInput | null
  }

  export type ConsultantNullableRelationFilter = {
    is?: ConsultantWhereInput | null
    isNot?: ConsultantWhereInput | null
  }

  export type AdminNullableRelationFilter = {
    is?: AdminWhereInput | null
    isNot?: AdminWhereInput | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    userType?: SortOrder
    phone?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    userType?: SortOrder
    phone?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    userType?: SortOrder
    phone?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumUserTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserType | EnumUserTypeFieldRefInput<$PrismaModel>
    in?: $Enums.UserType[] | ListEnumUserTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserType[] | ListEnumUserTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumUserTypeWithAggregatesFilter<$PrismaModel> | $Enums.UserType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserTypeFilter<$PrismaModel>
    _max?: NestedEnumUserTypeFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumUserStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserStatusWithAggregatesFilter<$PrismaModel> | $Enums.UserStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserStatusFilter<$PrismaModel>
    _max?: NestedEnumUserStatusFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type EnumStudentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.StudentStatus | EnumStudentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StudentStatus[] | ListEnumStudentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.StudentStatus[] | ListEnumStudentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStudentStatusFilter<$PrismaModel> | $Enums.StudentStatus
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type ConsultationSessionListRelationFilter = {
    every?: ConsultationSessionWhereInput
    some?: ConsultationSessionWhereInput
    none?: ConsultationSessionWhereInput
  }

  export type StudentDocumentListRelationFilter = {
    every?: StudentDocumentWhereInput
    some?: StudentDocumentWhereInput
    none?: StudentDocumentWhereInput
  }

  export type SessionHistoryListRelationFilter = {
    every?: SessionHistoryWhereInput
    some?: SessionHistoryWhereInput
    none?: SessionHistoryWhereInput
  }

  export type ConsultationSessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StudentDocumentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SessionHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StudentCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    kajabiUserId?: SortOrder
    courseCompletionDate?: SortOrder
    totalVerifiedHours?: SortOrder
    totalVideoHours?: SortOrder
    certificationStatus?: SortOrder
    preferredSessionLength?: SortOrder
    consultationPreferences?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentAvgOrderByAggregateInput = {
    totalVerifiedHours?: SortOrder
    totalVideoHours?: SortOrder
    preferredSessionLength?: SortOrder
  }

  export type StudentMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    kajabiUserId?: SortOrder
    courseCompletionDate?: SortOrder
    totalVerifiedHours?: SortOrder
    totalVideoHours?: SortOrder
    certificationStatus?: SortOrder
    preferredSessionLength?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    kajabiUserId?: SortOrder
    courseCompletionDate?: SortOrder
    totalVerifiedHours?: SortOrder
    totalVideoHours?: SortOrder
    certificationStatus?: SortOrder
    preferredSessionLength?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentSumOrderByAggregateInput = {
    totalVerifiedHours?: SortOrder
    totalVideoHours?: SortOrder
    preferredSessionLength?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type EnumStudentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StudentStatus | EnumStudentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StudentStatus[] | ListEnumStudentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.StudentStatus[] | ListEnumStudentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStudentStatusWithAggregatesFilter<$PrismaModel> | $Enums.StudentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStudentStatusFilter<$PrismaModel>
    _max?: NestedEnumStudentStatusFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type ConsultantAvailabilityListRelationFilter = {
    every?: ConsultantAvailabilityWhereInput
    some?: ConsultantAvailabilityWhereInput
    none?: ConsultantAvailabilityWhereInput
  }

  export type ConsultantPaymentListRelationFilter = {
    every?: ConsultantPaymentWhereInput
    some?: ConsultantPaymentWhereInput
    none?: ConsultantPaymentWhereInput
  }

  export type ConsultantAvailabilityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ConsultantPaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ConsultantCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    bio?: SortOrder
    specialties?: SortOrder
    hourlyRate?: SortOrder
    isActive?: SortOrder
    timezone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConsultantAvgOrderByAggregateInput = {
    hourlyRate?: SortOrder
  }

  export type ConsultantMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    bio?: SortOrder
    hourlyRate?: SortOrder
    isActive?: SortOrder
    timezone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConsultantMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    bio?: SortOrder
    hourlyRate?: SortOrder
    isActive?: SortOrder
    timezone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConsultantSumOrderByAggregateInput = {
    hourlyRate?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type AdminCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    permissions?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdminMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdminMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type EnumSessionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SessionStatus | EnumSessionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SessionStatus[] | ListEnumSessionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SessionStatus[] | ListEnumSessionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSessionStatusFilter<$PrismaModel> | $Enums.SessionStatus
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type StudentRelationFilter = {
    is?: StudentWhereInput
    isNot?: StudentWhereInput
  }

  export type ConsultantRelationFilter = {
    is?: ConsultantWhereInput
    isNot?: ConsultantWhereInput
  }

  export type VideoSessionNullableRelationFilter = {
    is?: VideoSessionWhereInput | null
    isNot?: VideoSessionWhereInput | null
  }

  export type ConsultationSessionCountOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    consultantId?: SortOrder
    scheduledStart?: SortOrder
    scheduledEnd?: SortOrder
    actualStart?: SortOrder
    actualEnd?: SortOrder
    status?: SortOrder
    sessionType?: SortOrder
    studentVerifiedAt?: SortOrder
    consultantVerifiedAt?: SortOrder
    studentNotes?: SortOrder
    consultantNotes?: SortOrder
    sessionRating?: SortOrder
    technicalIssuesReported?: SortOrder
    makeupSessionFor?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConsultationSessionAvgOrderByAggregateInput = {
    sessionRating?: SortOrder
  }

  export type ConsultationSessionMaxOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    consultantId?: SortOrder
    scheduledStart?: SortOrder
    scheduledEnd?: SortOrder
    actualStart?: SortOrder
    actualEnd?: SortOrder
    status?: SortOrder
    sessionType?: SortOrder
    studentVerifiedAt?: SortOrder
    consultantVerifiedAt?: SortOrder
    studentNotes?: SortOrder
    consultantNotes?: SortOrder
    sessionRating?: SortOrder
    technicalIssuesReported?: SortOrder
    makeupSessionFor?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConsultationSessionMinOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    consultantId?: SortOrder
    scheduledStart?: SortOrder
    scheduledEnd?: SortOrder
    actualStart?: SortOrder
    actualEnd?: SortOrder
    status?: SortOrder
    sessionType?: SortOrder
    studentVerifiedAt?: SortOrder
    consultantVerifiedAt?: SortOrder
    studentNotes?: SortOrder
    consultantNotes?: SortOrder
    sessionRating?: SortOrder
    technicalIssuesReported?: SortOrder
    makeupSessionFor?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConsultationSessionSumOrderByAggregateInput = {
    sessionRating?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumSessionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SessionStatus | EnumSessionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SessionStatus[] | ListEnumSessionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SessionStatus[] | ListEnumSessionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSessionStatusWithAggregatesFilter<$PrismaModel> | $Enums.SessionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSessionStatusFilter<$PrismaModel>
    _max?: NestedEnumSessionStatusFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type ConsultationSessionRelationFilter = {
    is?: ConsultationSessionWhereInput
    isNot?: ConsultationSessionWhereInput
  }

  export type VideoParticipantListRelationFilter = {
    every?: VideoParticipantWhereInput
    some?: VideoParticipantWhereInput
    none?: VideoParticipantWhereInput
  }

  export type VideoParticipantOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VideoSessionCountOrderByAggregateInput = {
    id?: SortOrder
    consultationSessionId?: SortOrder
    roomId?: SortOrder
    recordingEnabled?: SortOrder
    recordingUrl?: SortOrder
    recordingDurationSeconds?: SortOrder
    videoQuality?: SortOrder
    connectionQualityAvg?: SortOrder
    bandwidthUsageMb?: SortOrder
    technicalIssues?: SortOrder
    sessionMetadata?: SortOrder
    createdAt?: SortOrder
  }

  export type VideoSessionAvgOrderByAggregateInput = {
    recordingDurationSeconds?: SortOrder
    connectionQualityAvg?: SortOrder
    bandwidthUsageMb?: SortOrder
  }

  export type VideoSessionMaxOrderByAggregateInput = {
    id?: SortOrder
    consultationSessionId?: SortOrder
    roomId?: SortOrder
    recordingEnabled?: SortOrder
    recordingUrl?: SortOrder
    recordingDurationSeconds?: SortOrder
    videoQuality?: SortOrder
    connectionQualityAvg?: SortOrder
    bandwidthUsageMb?: SortOrder
    createdAt?: SortOrder
  }

  export type VideoSessionMinOrderByAggregateInput = {
    id?: SortOrder
    consultationSessionId?: SortOrder
    roomId?: SortOrder
    recordingEnabled?: SortOrder
    recordingUrl?: SortOrder
    recordingDurationSeconds?: SortOrder
    videoQuality?: SortOrder
    connectionQualityAvg?: SortOrder
    bandwidthUsageMb?: SortOrder
    createdAt?: SortOrder
  }

  export type VideoSessionSumOrderByAggregateInput = {
    recordingDurationSeconds?: SortOrder
    connectionQualityAvg?: SortOrder
    bandwidthUsageMb?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type VideoSessionRelationFilter = {
    is?: VideoSessionWhereInput
    isNot?: VideoSessionWhereInput
  }

  export type VideoParticipantCountOrderByAggregateInput = {
    id?: SortOrder
    videoSessionId?: SortOrder
    userId?: SortOrder
    userType?: SortOrder
    joinTime?: SortOrder
    leaveTime?: SortOrder
    totalDurationSeconds?: SortOrder
    audioQualityAvg?: SortOrder
    videoQualityAvg?: SortOrder
    screenShareDurationSeconds?: SortOrder
    chatMessagesCount?: SortOrder
    connectionInterruptions?: SortOrder
    createdAt?: SortOrder
  }

  export type VideoParticipantAvgOrderByAggregateInput = {
    totalDurationSeconds?: SortOrder
    audioQualityAvg?: SortOrder
    videoQualityAvg?: SortOrder
    screenShareDurationSeconds?: SortOrder
    chatMessagesCount?: SortOrder
    connectionInterruptions?: SortOrder
  }

  export type VideoParticipantMaxOrderByAggregateInput = {
    id?: SortOrder
    videoSessionId?: SortOrder
    userId?: SortOrder
    userType?: SortOrder
    joinTime?: SortOrder
    leaveTime?: SortOrder
    totalDurationSeconds?: SortOrder
    audioQualityAvg?: SortOrder
    videoQualityAvg?: SortOrder
    screenShareDurationSeconds?: SortOrder
    chatMessagesCount?: SortOrder
    connectionInterruptions?: SortOrder
    createdAt?: SortOrder
  }

  export type VideoParticipantMinOrderByAggregateInput = {
    id?: SortOrder
    videoSessionId?: SortOrder
    userId?: SortOrder
    userType?: SortOrder
    joinTime?: SortOrder
    leaveTime?: SortOrder
    totalDurationSeconds?: SortOrder
    audioQualityAvg?: SortOrder
    videoQualityAvg?: SortOrder
    screenShareDurationSeconds?: SortOrder
    chatMessagesCount?: SortOrder
    connectionInterruptions?: SortOrder
    createdAt?: SortOrder
  }

  export type VideoParticipantSumOrderByAggregateInput = {
    totalDurationSeconds?: SortOrder
    audioQualityAvg?: SortOrder
    videoQualityAvg?: SortOrder
    screenShareDurationSeconds?: SortOrder
    chatMessagesCount?: SortOrder
    connectionInterruptions?: SortOrder
  }

  export type EnumAvailabilityTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AvailabilityType | EnumAvailabilityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AvailabilityType[] | ListEnumAvailabilityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AvailabilityType[] | ListEnumAvailabilityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAvailabilityTypeFilter<$PrismaModel> | $Enums.AvailabilityType
  }

  export type ConsultantAvailabilityCountOrderByAggregateInput = {
    id?: SortOrder
    consultantId?: SortOrder
    availabilityType?: SortOrder
    dayOfWeek?: SortOrder
    specificDate?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    maxSessions?: SortOrder
    bufferMinutes?: SortOrder
    isAvailable?: SortOrder
    bookingWindowDays?: SortOrder
    minimumNoticeHours?: SortOrder
    autoApprove?: SortOrder
    timezone?: SortOrder
    recurringPattern?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConsultantAvailabilityAvgOrderByAggregateInput = {
    dayOfWeek?: SortOrder
    maxSessions?: SortOrder
    bufferMinutes?: SortOrder
    bookingWindowDays?: SortOrder
    minimumNoticeHours?: SortOrder
  }

  export type ConsultantAvailabilityMaxOrderByAggregateInput = {
    id?: SortOrder
    consultantId?: SortOrder
    availabilityType?: SortOrder
    dayOfWeek?: SortOrder
    specificDate?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    maxSessions?: SortOrder
    bufferMinutes?: SortOrder
    isAvailable?: SortOrder
    bookingWindowDays?: SortOrder
    minimumNoticeHours?: SortOrder
    autoApprove?: SortOrder
    timezone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConsultantAvailabilityMinOrderByAggregateInput = {
    id?: SortOrder
    consultantId?: SortOrder
    availabilityType?: SortOrder
    dayOfWeek?: SortOrder
    specificDate?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    maxSessions?: SortOrder
    bufferMinutes?: SortOrder
    isAvailable?: SortOrder
    bookingWindowDays?: SortOrder
    minimumNoticeHours?: SortOrder
    autoApprove?: SortOrder
    timezone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConsultantAvailabilitySumOrderByAggregateInput = {
    dayOfWeek?: SortOrder
    maxSessions?: SortOrder
    bufferMinutes?: SortOrder
    bookingWindowDays?: SortOrder
    minimumNoticeHours?: SortOrder
  }

  export type EnumAvailabilityTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AvailabilityType | EnumAvailabilityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AvailabilityType[] | ListEnumAvailabilityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AvailabilityType[] | ListEnumAvailabilityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAvailabilityTypeWithAggregatesFilter<$PrismaModel> | $Enums.AvailabilityType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAvailabilityTypeFilter<$PrismaModel>
    _max?: NestedEnumAvailabilityTypeFilter<$PrismaModel>
  }

  export type EnumDocumentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentType | EnumDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentTypeFilter<$PrismaModel> | $Enums.DocumentType
  }

  export type EnumReviewStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ReviewStatus | EnumReviewStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReviewStatus[] | ListEnumReviewStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReviewStatus[] | ListEnumReviewStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReviewStatusFilter<$PrismaModel> | $Enums.ReviewStatus
  }

  export type StudentDocumentCountOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    documentType?: SortOrder
    fileName?: SortOrder
    fileSizeBytes?: SortOrder
    filePath?: SortOrder
    mimeType?: SortOrder
    extractedText?: SortOrder
    uploadTimestamp?: SortOrder
    reviewStatus?: SortOrder
    reviewedBy?: SortOrder
    reviewedAt?: SortOrder
    reviewNotes?: SortOrder
    versionNumber?: SortOrder
    replacesDocumentId?: SortOrder
    autoValidationScore?: SortOrder
    requiresManualReview?: SortOrder
    createdAt?: SortOrder
  }

  export type StudentDocumentAvgOrderByAggregateInput = {
    fileSizeBytes?: SortOrder
    versionNumber?: SortOrder
    autoValidationScore?: SortOrder
  }

  export type StudentDocumentMaxOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    documentType?: SortOrder
    fileName?: SortOrder
    fileSizeBytes?: SortOrder
    filePath?: SortOrder
    mimeType?: SortOrder
    extractedText?: SortOrder
    uploadTimestamp?: SortOrder
    reviewStatus?: SortOrder
    reviewedBy?: SortOrder
    reviewedAt?: SortOrder
    reviewNotes?: SortOrder
    versionNumber?: SortOrder
    replacesDocumentId?: SortOrder
    autoValidationScore?: SortOrder
    requiresManualReview?: SortOrder
    createdAt?: SortOrder
  }

  export type StudentDocumentMinOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    documentType?: SortOrder
    fileName?: SortOrder
    fileSizeBytes?: SortOrder
    filePath?: SortOrder
    mimeType?: SortOrder
    extractedText?: SortOrder
    uploadTimestamp?: SortOrder
    reviewStatus?: SortOrder
    reviewedBy?: SortOrder
    reviewedAt?: SortOrder
    reviewNotes?: SortOrder
    versionNumber?: SortOrder
    replacesDocumentId?: SortOrder
    autoValidationScore?: SortOrder
    requiresManualReview?: SortOrder
    createdAt?: SortOrder
  }

  export type StudentDocumentSumOrderByAggregateInput = {
    fileSizeBytes?: SortOrder
    versionNumber?: SortOrder
    autoValidationScore?: SortOrder
  }

  export type EnumDocumentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentType | EnumDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentTypeWithAggregatesFilter<$PrismaModel> | $Enums.DocumentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDocumentTypeFilter<$PrismaModel>
    _max?: NestedEnumDocumentTypeFilter<$PrismaModel>
  }

  export type EnumReviewStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReviewStatus | EnumReviewStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReviewStatus[] | ListEnumReviewStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReviewStatus[] | ListEnumReviewStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReviewStatusWithAggregatesFilter<$PrismaModel> | $Enums.ReviewStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReviewStatusFilter<$PrismaModel>
    _max?: NestedEnumReviewStatusFilter<$PrismaModel>
  }

  export type SessionHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    sessionDate?: SortOrder
    sessionDuration?: SortOrder
    consultantId?: SortOrder
    sessionType?: SortOrder
    status?: SortOrder
    rating?: SortOrder
    createdAt?: SortOrder
  }

  export type SessionHistoryAvgOrderByAggregateInput = {
    sessionDuration?: SortOrder
    rating?: SortOrder
  }

  export type SessionHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    sessionDate?: SortOrder
    sessionDuration?: SortOrder
    consultantId?: SortOrder
    sessionType?: SortOrder
    status?: SortOrder
    rating?: SortOrder
    createdAt?: SortOrder
  }

  export type SessionHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    sessionDate?: SortOrder
    sessionDuration?: SortOrder
    consultantId?: SortOrder
    sessionType?: SortOrder
    status?: SortOrder
    rating?: SortOrder
    createdAt?: SortOrder
  }

  export type SessionHistorySumOrderByAggregateInput = {
    sessionDuration?: SortOrder
    rating?: SortOrder
  }

  export type EnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus
  }

  export type ConsultantPaymentCountOrderByAggregateInput = {
    id?: SortOrder
    consultantId?: SortOrder
    paymentPeriod?: SortOrder
    totalHours?: SortOrder
    hourlyRate?: SortOrder
    totalAmount?: SortOrder
    paymentStatus?: SortOrder
    paymentDate?: SortOrder
    sessionBreakdown?: SortOrder
    createdAt?: SortOrder
  }

  export type ConsultantPaymentAvgOrderByAggregateInput = {
    totalHours?: SortOrder
    hourlyRate?: SortOrder
    totalAmount?: SortOrder
  }

  export type ConsultantPaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    consultantId?: SortOrder
    paymentPeriod?: SortOrder
    totalHours?: SortOrder
    hourlyRate?: SortOrder
    totalAmount?: SortOrder
    paymentStatus?: SortOrder
    paymentDate?: SortOrder
    createdAt?: SortOrder
  }

  export type ConsultantPaymentMinOrderByAggregateInput = {
    id?: SortOrder
    consultantId?: SortOrder
    paymentPeriod?: SortOrder
    totalHours?: SortOrder
    hourlyRate?: SortOrder
    totalAmount?: SortOrder
    paymentStatus?: SortOrder
    paymentDate?: SortOrder
    createdAt?: SortOrder
  }

  export type ConsultantPaymentSumOrderByAggregateInput = {
    totalHours?: SortOrder
    hourlyRate?: SortOrder
    totalAmount?: SortOrder
  }

  export type EnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>
  }

  export type SystemHealthMetricCountOrderByAggregateInput = {
    id?: SortOrder
    metricType?: SortOrder
    metricValue?: SortOrder
    metricUnit?: SortOrder
    timestamp?: SortOrder
    additionalData?: SortOrder
    createdAt?: SortOrder
  }

  export type SystemHealthMetricAvgOrderByAggregateInput = {
    metricValue?: SortOrder
  }

  export type SystemHealthMetricMaxOrderByAggregateInput = {
    id?: SortOrder
    metricType?: SortOrder
    metricValue?: SortOrder
    metricUnit?: SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
  }

  export type SystemHealthMetricMinOrderByAggregateInput = {
    id?: SortOrder
    metricType?: SortOrder
    metricValue?: SortOrder
    metricUnit?: SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
  }

  export type SystemHealthMetricSumOrderByAggregateInput = {
    metricValue?: SortOrder
  }

  export type InAppNotificationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    data?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
  }

  export type InAppNotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
  }

  export type InAppNotificationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumScheduledNotificationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ScheduledNotificationStatus | EnumScheduledNotificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ScheduledNotificationStatus[] | ListEnumScheduledNotificationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ScheduledNotificationStatus[] | ListEnumScheduledNotificationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumScheduledNotificationStatusFilter<$PrismaModel> | $Enums.ScheduledNotificationStatus
  }

  export type ScheduledNotificationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    data?: SortOrder
    priority?: SortOrder
    scheduledFor?: SortOrder
    status?: SortOrder
    sentAt?: SortOrder
    createdAt?: SortOrder
  }

  export type ScheduledNotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    priority?: SortOrder
    scheduledFor?: SortOrder
    status?: SortOrder
    sentAt?: SortOrder
    createdAt?: SortOrder
  }

  export type ScheduledNotificationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    priority?: SortOrder
    scheduledFor?: SortOrder
    status?: SortOrder
    sentAt?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumScheduledNotificationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ScheduledNotificationStatus | EnumScheduledNotificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ScheduledNotificationStatus[] | ListEnumScheduledNotificationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ScheduledNotificationStatus[] | ListEnumScheduledNotificationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumScheduledNotificationStatusWithAggregatesFilter<$PrismaModel> | $Enums.ScheduledNotificationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumScheduledNotificationStatusFilter<$PrismaModel>
    _max?: NestedEnumScheduledNotificationStatusFilter<$PrismaModel>
  }

  export type NotificationLogCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    data?: SortOrder
    priority?: SortOrder
    sentAt?: SortOrder
  }

  export type NotificationLogMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    priority?: SortOrder
    sentAt?: SortOrder
  }

  export type NotificationLogMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    priority?: SortOrder
    sentAt?: SortOrder
  }

  export type UserNotificationPreferencesCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    emailEnabled?: SortOrder
    smsEnabled?: SortOrder
    inAppEnabled?: SortOrder
    pushEnabled?: SortOrder
    quietHours?: SortOrder
    notificationTypes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserNotificationPreferencesMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    emailEnabled?: SortOrder
    smsEnabled?: SortOrder
    inAppEnabled?: SortOrder
    pushEnabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserNotificationPreferencesMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    emailEnabled?: SortOrder
    smsEnabled?: SortOrder
    inAppEnabled?: SortOrder
    pushEnabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentCreateNestedOneWithoutUserInput = {
    create?: XOR<StudentCreateWithoutUserInput, StudentUncheckedCreateWithoutUserInput>
    connectOrCreate?: StudentCreateOrConnectWithoutUserInput
    connect?: StudentWhereUniqueInput
  }

  export type ConsultantCreateNestedOneWithoutUserInput = {
    create?: XOR<ConsultantCreateWithoutUserInput, ConsultantUncheckedCreateWithoutUserInput>
    connectOrCreate?: ConsultantCreateOrConnectWithoutUserInput
    connect?: ConsultantWhereUniqueInput
  }

  export type AdminCreateNestedOneWithoutUserInput = {
    create?: XOR<AdminCreateWithoutUserInput, AdminUncheckedCreateWithoutUserInput>
    connectOrCreate?: AdminCreateOrConnectWithoutUserInput
    connect?: AdminWhereUniqueInput
  }

  export type StudentUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<StudentCreateWithoutUserInput, StudentUncheckedCreateWithoutUserInput>
    connectOrCreate?: StudentCreateOrConnectWithoutUserInput
    connect?: StudentWhereUniqueInput
  }

  export type ConsultantUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<ConsultantCreateWithoutUserInput, ConsultantUncheckedCreateWithoutUserInput>
    connectOrCreate?: ConsultantCreateOrConnectWithoutUserInput
    connect?: ConsultantWhereUniqueInput
  }

  export type AdminUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<AdminCreateWithoutUserInput, AdminUncheckedCreateWithoutUserInput>
    connectOrCreate?: AdminCreateOrConnectWithoutUserInput
    connect?: AdminWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type EnumUserTypeFieldUpdateOperationsInput = {
    set?: $Enums.UserType
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnumUserStatusFieldUpdateOperationsInput = {
    set?: $Enums.UserStatus
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type StudentUpdateOneWithoutUserNestedInput = {
    create?: XOR<StudentCreateWithoutUserInput, StudentUncheckedCreateWithoutUserInput>
    connectOrCreate?: StudentCreateOrConnectWithoutUserInput
    upsert?: StudentUpsertWithoutUserInput
    disconnect?: StudentWhereInput | boolean
    delete?: StudentWhereInput | boolean
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutUserInput, StudentUpdateWithoutUserInput>, StudentUncheckedUpdateWithoutUserInput>
  }

  export type ConsultantUpdateOneWithoutUserNestedInput = {
    create?: XOR<ConsultantCreateWithoutUserInput, ConsultantUncheckedCreateWithoutUserInput>
    connectOrCreate?: ConsultantCreateOrConnectWithoutUserInput
    upsert?: ConsultantUpsertWithoutUserInput
    disconnect?: ConsultantWhereInput | boolean
    delete?: ConsultantWhereInput | boolean
    connect?: ConsultantWhereUniqueInput
    update?: XOR<XOR<ConsultantUpdateToOneWithWhereWithoutUserInput, ConsultantUpdateWithoutUserInput>, ConsultantUncheckedUpdateWithoutUserInput>
  }

  export type AdminUpdateOneWithoutUserNestedInput = {
    create?: XOR<AdminCreateWithoutUserInput, AdminUncheckedCreateWithoutUserInput>
    connectOrCreate?: AdminCreateOrConnectWithoutUserInput
    upsert?: AdminUpsertWithoutUserInput
    disconnect?: AdminWhereInput | boolean
    delete?: AdminWhereInput | boolean
    connect?: AdminWhereUniqueInput
    update?: XOR<XOR<AdminUpdateToOneWithWhereWithoutUserInput, AdminUpdateWithoutUserInput>, AdminUncheckedUpdateWithoutUserInput>
  }

  export type StudentUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<StudentCreateWithoutUserInput, StudentUncheckedCreateWithoutUserInput>
    connectOrCreate?: StudentCreateOrConnectWithoutUserInput
    upsert?: StudentUpsertWithoutUserInput
    disconnect?: StudentWhereInput | boolean
    delete?: StudentWhereInput | boolean
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutUserInput, StudentUpdateWithoutUserInput>, StudentUncheckedUpdateWithoutUserInput>
  }

  export type ConsultantUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<ConsultantCreateWithoutUserInput, ConsultantUncheckedCreateWithoutUserInput>
    connectOrCreate?: ConsultantCreateOrConnectWithoutUserInput
    upsert?: ConsultantUpsertWithoutUserInput
    disconnect?: ConsultantWhereInput | boolean
    delete?: ConsultantWhereInput | boolean
    connect?: ConsultantWhereUniqueInput
    update?: XOR<XOR<ConsultantUpdateToOneWithWhereWithoutUserInput, ConsultantUpdateWithoutUserInput>, ConsultantUncheckedUpdateWithoutUserInput>
  }

  export type AdminUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<AdminCreateWithoutUserInput, AdminUncheckedCreateWithoutUserInput>
    connectOrCreate?: AdminCreateOrConnectWithoutUserInput
    upsert?: AdminUpsertWithoutUserInput
    disconnect?: AdminWhereInput | boolean
    delete?: AdminWhereInput | boolean
    connect?: AdminWhereUniqueInput
    update?: XOR<XOR<AdminUpdateToOneWithWhereWithoutUserInput, AdminUpdateWithoutUserInput>, AdminUncheckedUpdateWithoutUserInput>
  }

  export type UserCreateNestedOneWithoutStudentInput = {
    create?: XOR<UserCreateWithoutStudentInput, UserUncheckedCreateWithoutStudentInput>
    connectOrCreate?: UserCreateOrConnectWithoutStudentInput
    connect?: UserWhereUniqueInput
  }

  export type ConsultationSessionCreateNestedManyWithoutStudentInput = {
    create?: XOR<ConsultationSessionCreateWithoutStudentInput, ConsultationSessionUncheckedCreateWithoutStudentInput> | ConsultationSessionCreateWithoutStudentInput[] | ConsultationSessionUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: ConsultationSessionCreateOrConnectWithoutStudentInput | ConsultationSessionCreateOrConnectWithoutStudentInput[]
    createMany?: ConsultationSessionCreateManyStudentInputEnvelope
    connect?: ConsultationSessionWhereUniqueInput | ConsultationSessionWhereUniqueInput[]
  }

  export type StudentDocumentCreateNestedManyWithoutStudentInput = {
    create?: XOR<StudentDocumentCreateWithoutStudentInput, StudentDocumentUncheckedCreateWithoutStudentInput> | StudentDocumentCreateWithoutStudentInput[] | StudentDocumentUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentDocumentCreateOrConnectWithoutStudentInput | StudentDocumentCreateOrConnectWithoutStudentInput[]
    createMany?: StudentDocumentCreateManyStudentInputEnvelope
    connect?: StudentDocumentWhereUniqueInput | StudentDocumentWhereUniqueInput[]
  }

  export type SessionHistoryCreateNestedManyWithoutStudentInput = {
    create?: XOR<SessionHistoryCreateWithoutStudentInput, SessionHistoryUncheckedCreateWithoutStudentInput> | SessionHistoryCreateWithoutStudentInput[] | SessionHistoryUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: SessionHistoryCreateOrConnectWithoutStudentInput | SessionHistoryCreateOrConnectWithoutStudentInput[]
    createMany?: SessionHistoryCreateManyStudentInputEnvelope
    connect?: SessionHistoryWhereUniqueInput | SessionHistoryWhereUniqueInput[]
  }

  export type ConsultationSessionUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<ConsultationSessionCreateWithoutStudentInput, ConsultationSessionUncheckedCreateWithoutStudentInput> | ConsultationSessionCreateWithoutStudentInput[] | ConsultationSessionUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: ConsultationSessionCreateOrConnectWithoutStudentInput | ConsultationSessionCreateOrConnectWithoutStudentInput[]
    createMany?: ConsultationSessionCreateManyStudentInputEnvelope
    connect?: ConsultationSessionWhereUniqueInput | ConsultationSessionWhereUniqueInput[]
  }

  export type StudentDocumentUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<StudentDocumentCreateWithoutStudentInput, StudentDocumentUncheckedCreateWithoutStudentInput> | StudentDocumentCreateWithoutStudentInput[] | StudentDocumentUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentDocumentCreateOrConnectWithoutStudentInput | StudentDocumentCreateOrConnectWithoutStudentInput[]
    createMany?: StudentDocumentCreateManyStudentInputEnvelope
    connect?: StudentDocumentWhereUniqueInput | StudentDocumentWhereUniqueInput[]
  }

  export type SessionHistoryUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<SessionHistoryCreateWithoutStudentInput, SessionHistoryUncheckedCreateWithoutStudentInput> | SessionHistoryCreateWithoutStudentInput[] | SessionHistoryUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: SessionHistoryCreateOrConnectWithoutStudentInput | SessionHistoryCreateOrConnectWithoutStudentInput[]
    createMany?: SessionHistoryCreateManyStudentInputEnvelope
    connect?: SessionHistoryWhereUniqueInput | SessionHistoryWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumStudentStatusFieldUpdateOperationsInput = {
    set?: $Enums.StudentStatus
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutStudentNestedInput = {
    create?: XOR<UserCreateWithoutStudentInput, UserUncheckedCreateWithoutStudentInput>
    connectOrCreate?: UserCreateOrConnectWithoutStudentInput
    upsert?: UserUpsertWithoutStudentInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutStudentInput, UserUpdateWithoutStudentInput>, UserUncheckedUpdateWithoutStudentInput>
  }

  export type ConsultationSessionUpdateManyWithoutStudentNestedInput = {
    create?: XOR<ConsultationSessionCreateWithoutStudentInput, ConsultationSessionUncheckedCreateWithoutStudentInput> | ConsultationSessionCreateWithoutStudentInput[] | ConsultationSessionUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: ConsultationSessionCreateOrConnectWithoutStudentInput | ConsultationSessionCreateOrConnectWithoutStudentInput[]
    upsert?: ConsultationSessionUpsertWithWhereUniqueWithoutStudentInput | ConsultationSessionUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: ConsultationSessionCreateManyStudentInputEnvelope
    set?: ConsultationSessionWhereUniqueInput | ConsultationSessionWhereUniqueInput[]
    disconnect?: ConsultationSessionWhereUniqueInput | ConsultationSessionWhereUniqueInput[]
    delete?: ConsultationSessionWhereUniqueInput | ConsultationSessionWhereUniqueInput[]
    connect?: ConsultationSessionWhereUniqueInput | ConsultationSessionWhereUniqueInput[]
    update?: ConsultationSessionUpdateWithWhereUniqueWithoutStudentInput | ConsultationSessionUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: ConsultationSessionUpdateManyWithWhereWithoutStudentInput | ConsultationSessionUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: ConsultationSessionScalarWhereInput | ConsultationSessionScalarWhereInput[]
  }

  export type StudentDocumentUpdateManyWithoutStudentNestedInput = {
    create?: XOR<StudentDocumentCreateWithoutStudentInput, StudentDocumentUncheckedCreateWithoutStudentInput> | StudentDocumentCreateWithoutStudentInput[] | StudentDocumentUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentDocumentCreateOrConnectWithoutStudentInput | StudentDocumentCreateOrConnectWithoutStudentInput[]
    upsert?: StudentDocumentUpsertWithWhereUniqueWithoutStudentInput | StudentDocumentUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: StudentDocumentCreateManyStudentInputEnvelope
    set?: StudentDocumentWhereUniqueInput | StudentDocumentWhereUniqueInput[]
    disconnect?: StudentDocumentWhereUniqueInput | StudentDocumentWhereUniqueInput[]
    delete?: StudentDocumentWhereUniqueInput | StudentDocumentWhereUniqueInput[]
    connect?: StudentDocumentWhereUniqueInput | StudentDocumentWhereUniqueInput[]
    update?: StudentDocumentUpdateWithWhereUniqueWithoutStudentInput | StudentDocumentUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: StudentDocumentUpdateManyWithWhereWithoutStudentInput | StudentDocumentUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: StudentDocumentScalarWhereInput | StudentDocumentScalarWhereInput[]
  }

  export type SessionHistoryUpdateManyWithoutStudentNestedInput = {
    create?: XOR<SessionHistoryCreateWithoutStudentInput, SessionHistoryUncheckedCreateWithoutStudentInput> | SessionHistoryCreateWithoutStudentInput[] | SessionHistoryUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: SessionHistoryCreateOrConnectWithoutStudentInput | SessionHistoryCreateOrConnectWithoutStudentInput[]
    upsert?: SessionHistoryUpsertWithWhereUniqueWithoutStudentInput | SessionHistoryUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: SessionHistoryCreateManyStudentInputEnvelope
    set?: SessionHistoryWhereUniqueInput | SessionHistoryWhereUniqueInput[]
    disconnect?: SessionHistoryWhereUniqueInput | SessionHistoryWhereUniqueInput[]
    delete?: SessionHistoryWhereUniqueInput | SessionHistoryWhereUniqueInput[]
    connect?: SessionHistoryWhereUniqueInput | SessionHistoryWhereUniqueInput[]
    update?: SessionHistoryUpdateWithWhereUniqueWithoutStudentInput | SessionHistoryUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: SessionHistoryUpdateManyWithWhereWithoutStudentInput | SessionHistoryUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: SessionHistoryScalarWhereInput | SessionHistoryScalarWhereInput[]
  }

  export type ConsultationSessionUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<ConsultationSessionCreateWithoutStudentInput, ConsultationSessionUncheckedCreateWithoutStudentInput> | ConsultationSessionCreateWithoutStudentInput[] | ConsultationSessionUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: ConsultationSessionCreateOrConnectWithoutStudentInput | ConsultationSessionCreateOrConnectWithoutStudentInput[]
    upsert?: ConsultationSessionUpsertWithWhereUniqueWithoutStudentInput | ConsultationSessionUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: ConsultationSessionCreateManyStudentInputEnvelope
    set?: ConsultationSessionWhereUniqueInput | ConsultationSessionWhereUniqueInput[]
    disconnect?: ConsultationSessionWhereUniqueInput | ConsultationSessionWhereUniqueInput[]
    delete?: ConsultationSessionWhereUniqueInput | ConsultationSessionWhereUniqueInput[]
    connect?: ConsultationSessionWhereUniqueInput | ConsultationSessionWhereUniqueInput[]
    update?: ConsultationSessionUpdateWithWhereUniqueWithoutStudentInput | ConsultationSessionUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: ConsultationSessionUpdateManyWithWhereWithoutStudentInput | ConsultationSessionUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: ConsultationSessionScalarWhereInput | ConsultationSessionScalarWhereInput[]
  }

  export type StudentDocumentUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<StudentDocumentCreateWithoutStudentInput, StudentDocumentUncheckedCreateWithoutStudentInput> | StudentDocumentCreateWithoutStudentInput[] | StudentDocumentUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentDocumentCreateOrConnectWithoutStudentInput | StudentDocumentCreateOrConnectWithoutStudentInput[]
    upsert?: StudentDocumentUpsertWithWhereUniqueWithoutStudentInput | StudentDocumentUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: StudentDocumentCreateManyStudentInputEnvelope
    set?: StudentDocumentWhereUniqueInput | StudentDocumentWhereUniqueInput[]
    disconnect?: StudentDocumentWhereUniqueInput | StudentDocumentWhereUniqueInput[]
    delete?: StudentDocumentWhereUniqueInput | StudentDocumentWhereUniqueInput[]
    connect?: StudentDocumentWhereUniqueInput | StudentDocumentWhereUniqueInput[]
    update?: StudentDocumentUpdateWithWhereUniqueWithoutStudentInput | StudentDocumentUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: StudentDocumentUpdateManyWithWhereWithoutStudentInput | StudentDocumentUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: StudentDocumentScalarWhereInput | StudentDocumentScalarWhereInput[]
  }

  export type SessionHistoryUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<SessionHistoryCreateWithoutStudentInput, SessionHistoryUncheckedCreateWithoutStudentInput> | SessionHistoryCreateWithoutStudentInput[] | SessionHistoryUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: SessionHistoryCreateOrConnectWithoutStudentInput | SessionHistoryCreateOrConnectWithoutStudentInput[]
    upsert?: SessionHistoryUpsertWithWhereUniqueWithoutStudentInput | SessionHistoryUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: SessionHistoryCreateManyStudentInputEnvelope
    set?: SessionHistoryWhereUniqueInput | SessionHistoryWhereUniqueInput[]
    disconnect?: SessionHistoryWhereUniqueInput | SessionHistoryWhereUniqueInput[]
    delete?: SessionHistoryWhereUniqueInput | SessionHistoryWhereUniqueInput[]
    connect?: SessionHistoryWhereUniqueInput | SessionHistoryWhereUniqueInput[]
    update?: SessionHistoryUpdateWithWhereUniqueWithoutStudentInput | SessionHistoryUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: SessionHistoryUpdateManyWithWhereWithoutStudentInput | SessionHistoryUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: SessionHistoryScalarWhereInput | SessionHistoryScalarWhereInput[]
  }

  export type ConsultantCreatespecialtiesInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutConsultantInput = {
    create?: XOR<UserCreateWithoutConsultantInput, UserUncheckedCreateWithoutConsultantInput>
    connectOrCreate?: UserCreateOrConnectWithoutConsultantInput
    connect?: UserWhereUniqueInput
  }

  export type ConsultationSessionCreateNestedManyWithoutConsultantInput = {
    create?: XOR<ConsultationSessionCreateWithoutConsultantInput, ConsultationSessionUncheckedCreateWithoutConsultantInput> | ConsultationSessionCreateWithoutConsultantInput[] | ConsultationSessionUncheckedCreateWithoutConsultantInput[]
    connectOrCreate?: ConsultationSessionCreateOrConnectWithoutConsultantInput | ConsultationSessionCreateOrConnectWithoutConsultantInput[]
    createMany?: ConsultationSessionCreateManyConsultantInputEnvelope
    connect?: ConsultationSessionWhereUniqueInput | ConsultationSessionWhereUniqueInput[]
  }

  export type ConsultantAvailabilityCreateNestedManyWithoutConsultantInput = {
    create?: XOR<ConsultantAvailabilityCreateWithoutConsultantInput, ConsultantAvailabilityUncheckedCreateWithoutConsultantInput> | ConsultantAvailabilityCreateWithoutConsultantInput[] | ConsultantAvailabilityUncheckedCreateWithoutConsultantInput[]
    connectOrCreate?: ConsultantAvailabilityCreateOrConnectWithoutConsultantInput | ConsultantAvailabilityCreateOrConnectWithoutConsultantInput[]
    createMany?: ConsultantAvailabilityCreateManyConsultantInputEnvelope
    connect?: ConsultantAvailabilityWhereUniqueInput | ConsultantAvailabilityWhereUniqueInput[]
  }

  export type ConsultantPaymentCreateNestedManyWithoutConsultantInput = {
    create?: XOR<ConsultantPaymentCreateWithoutConsultantInput, ConsultantPaymentUncheckedCreateWithoutConsultantInput> | ConsultantPaymentCreateWithoutConsultantInput[] | ConsultantPaymentUncheckedCreateWithoutConsultantInput[]
    connectOrCreate?: ConsultantPaymentCreateOrConnectWithoutConsultantInput | ConsultantPaymentCreateOrConnectWithoutConsultantInput[]
    createMany?: ConsultantPaymentCreateManyConsultantInputEnvelope
    connect?: ConsultantPaymentWhereUniqueInput | ConsultantPaymentWhereUniqueInput[]
  }

  export type ConsultationSessionUncheckedCreateNestedManyWithoutConsultantInput = {
    create?: XOR<ConsultationSessionCreateWithoutConsultantInput, ConsultationSessionUncheckedCreateWithoutConsultantInput> | ConsultationSessionCreateWithoutConsultantInput[] | ConsultationSessionUncheckedCreateWithoutConsultantInput[]
    connectOrCreate?: ConsultationSessionCreateOrConnectWithoutConsultantInput | ConsultationSessionCreateOrConnectWithoutConsultantInput[]
    createMany?: ConsultationSessionCreateManyConsultantInputEnvelope
    connect?: ConsultationSessionWhereUniqueInput | ConsultationSessionWhereUniqueInput[]
  }

  export type ConsultantAvailabilityUncheckedCreateNestedManyWithoutConsultantInput = {
    create?: XOR<ConsultantAvailabilityCreateWithoutConsultantInput, ConsultantAvailabilityUncheckedCreateWithoutConsultantInput> | ConsultantAvailabilityCreateWithoutConsultantInput[] | ConsultantAvailabilityUncheckedCreateWithoutConsultantInput[]
    connectOrCreate?: ConsultantAvailabilityCreateOrConnectWithoutConsultantInput | ConsultantAvailabilityCreateOrConnectWithoutConsultantInput[]
    createMany?: ConsultantAvailabilityCreateManyConsultantInputEnvelope
    connect?: ConsultantAvailabilityWhereUniqueInput | ConsultantAvailabilityWhereUniqueInput[]
  }

  export type ConsultantPaymentUncheckedCreateNestedManyWithoutConsultantInput = {
    create?: XOR<ConsultantPaymentCreateWithoutConsultantInput, ConsultantPaymentUncheckedCreateWithoutConsultantInput> | ConsultantPaymentCreateWithoutConsultantInput[] | ConsultantPaymentUncheckedCreateWithoutConsultantInput[]
    connectOrCreate?: ConsultantPaymentCreateOrConnectWithoutConsultantInput | ConsultantPaymentCreateOrConnectWithoutConsultantInput[]
    createMany?: ConsultantPaymentCreateManyConsultantInputEnvelope
    connect?: ConsultantPaymentWhereUniqueInput | ConsultantPaymentWhereUniqueInput[]
  }

  export type ConsultantUpdatespecialtiesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type UserUpdateOneRequiredWithoutConsultantNestedInput = {
    create?: XOR<UserCreateWithoutConsultantInput, UserUncheckedCreateWithoutConsultantInput>
    connectOrCreate?: UserCreateOrConnectWithoutConsultantInput
    upsert?: UserUpsertWithoutConsultantInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutConsultantInput, UserUpdateWithoutConsultantInput>, UserUncheckedUpdateWithoutConsultantInput>
  }

  export type ConsultationSessionUpdateManyWithoutConsultantNestedInput = {
    create?: XOR<ConsultationSessionCreateWithoutConsultantInput, ConsultationSessionUncheckedCreateWithoutConsultantInput> | ConsultationSessionCreateWithoutConsultantInput[] | ConsultationSessionUncheckedCreateWithoutConsultantInput[]
    connectOrCreate?: ConsultationSessionCreateOrConnectWithoutConsultantInput | ConsultationSessionCreateOrConnectWithoutConsultantInput[]
    upsert?: ConsultationSessionUpsertWithWhereUniqueWithoutConsultantInput | ConsultationSessionUpsertWithWhereUniqueWithoutConsultantInput[]
    createMany?: ConsultationSessionCreateManyConsultantInputEnvelope
    set?: ConsultationSessionWhereUniqueInput | ConsultationSessionWhereUniqueInput[]
    disconnect?: ConsultationSessionWhereUniqueInput | ConsultationSessionWhereUniqueInput[]
    delete?: ConsultationSessionWhereUniqueInput | ConsultationSessionWhereUniqueInput[]
    connect?: ConsultationSessionWhereUniqueInput | ConsultationSessionWhereUniqueInput[]
    update?: ConsultationSessionUpdateWithWhereUniqueWithoutConsultantInput | ConsultationSessionUpdateWithWhereUniqueWithoutConsultantInput[]
    updateMany?: ConsultationSessionUpdateManyWithWhereWithoutConsultantInput | ConsultationSessionUpdateManyWithWhereWithoutConsultantInput[]
    deleteMany?: ConsultationSessionScalarWhereInput | ConsultationSessionScalarWhereInput[]
  }

  export type ConsultantAvailabilityUpdateManyWithoutConsultantNestedInput = {
    create?: XOR<ConsultantAvailabilityCreateWithoutConsultantInput, ConsultantAvailabilityUncheckedCreateWithoutConsultantInput> | ConsultantAvailabilityCreateWithoutConsultantInput[] | ConsultantAvailabilityUncheckedCreateWithoutConsultantInput[]
    connectOrCreate?: ConsultantAvailabilityCreateOrConnectWithoutConsultantInput | ConsultantAvailabilityCreateOrConnectWithoutConsultantInput[]
    upsert?: ConsultantAvailabilityUpsertWithWhereUniqueWithoutConsultantInput | ConsultantAvailabilityUpsertWithWhereUniqueWithoutConsultantInput[]
    createMany?: ConsultantAvailabilityCreateManyConsultantInputEnvelope
    set?: ConsultantAvailabilityWhereUniqueInput | ConsultantAvailabilityWhereUniqueInput[]
    disconnect?: ConsultantAvailabilityWhereUniqueInput | ConsultantAvailabilityWhereUniqueInput[]
    delete?: ConsultantAvailabilityWhereUniqueInput | ConsultantAvailabilityWhereUniqueInput[]
    connect?: ConsultantAvailabilityWhereUniqueInput | ConsultantAvailabilityWhereUniqueInput[]
    update?: ConsultantAvailabilityUpdateWithWhereUniqueWithoutConsultantInput | ConsultantAvailabilityUpdateWithWhereUniqueWithoutConsultantInput[]
    updateMany?: ConsultantAvailabilityUpdateManyWithWhereWithoutConsultantInput | ConsultantAvailabilityUpdateManyWithWhereWithoutConsultantInput[]
    deleteMany?: ConsultantAvailabilityScalarWhereInput | ConsultantAvailabilityScalarWhereInput[]
  }

  export type ConsultantPaymentUpdateManyWithoutConsultantNestedInput = {
    create?: XOR<ConsultantPaymentCreateWithoutConsultantInput, ConsultantPaymentUncheckedCreateWithoutConsultantInput> | ConsultantPaymentCreateWithoutConsultantInput[] | ConsultantPaymentUncheckedCreateWithoutConsultantInput[]
    connectOrCreate?: ConsultantPaymentCreateOrConnectWithoutConsultantInput | ConsultantPaymentCreateOrConnectWithoutConsultantInput[]
    upsert?: ConsultantPaymentUpsertWithWhereUniqueWithoutConsultantInput | ConsultantPaymentUpsertWithWhereUniqueWithoutConsultantInput[]
    createMany?: ConsultantPaymentCreateManyConsultantInputEnvelope
    set?: ConsultantPaymentWhereUniqueInput | ConsultantPaymentWhereUniqueInput[]
    disconnect?: ConsultantPaymentWhereUniqueInput | ConsultantPaymentWhereUniqueInput[]
    delete?: ConsultantPaymentWhereUniqueInput | ConsultantPaymentWhereUniqueInput[]
    connect?: ConsultantPaymentWhereUniqueInput | ConsultantPaymentWhereUniqueInput[]
    update?: ConsultantPaymentUpdateWithWhereUniqueWithoutConsultantInput | ConsultantPaymentUpdateWithWhereUniqueWithoutConsultantInput[]
    updateMany?: ConsultantPaymentUpdateManyWithWhereWithoutConsultantInput | ConsultantPaymentUpdateManyWithWhereWithoutConsultantInput[]
    deleteMany?: ConsultantPaymentScalarWhereInput | ConsultantPaymentScalarWhereInput[]
  }

  export type ConsultationSessionUncheckedUpdateManyWithoutConsultantNestedInput = {
    create?: XOR<ConsultationSessionCreateWithoutConsultantInput, ConsultationSessionUncheckedCreateWithoutConsultantInput> | ConsultationSessionCreateWithoutConsultantInput[] | ConsultationSessionUncheckedCreateWithoutConsultantInput[]
    connectOrCreate?: ConsultationSessionCreateOrConnectWithoutConsultantInput | ConsultationSessionCreateOrConnectWithoutConsultantInput[]
    upsert?: ConsultationSessionUpsertWithWhereUniqueWithoutConsultantInput | ConsultationSessionUpsertWithWhereUniqueWithoutConsultantInput[]
    createMany?: ConsultationSessionCreateManyConsultantInputEnvelope
    set?: ConsultationSessionWhereUniqueInput | ConsultationSessionWhereUniqueInput[]
    disconnect?: ConsultationSessionWhereUniqueInput | ConsultationSessionWhereUniqueInput[]
    delete?: ConsultationSessionWhereUniqueInput | ConsultationSessionWhereUniqueInput[]
    connect?: ConsultationSessionWhereUniqueInput | ConsultationSessionWhereUniqueInput[]
    update?: ConsultationSessionUpdateWithWhereUniqueWithoutConsultantInput | ConsultationSessionUpdateWithWhereUniqueWithoutConsultantInput[]
    updateMany?: ConsultationSessionUpdateManyWithWhereWithoutConsultantInput | ConsultationSessionUpdateManyWithWhereWithoutConsultantInput[]
    deleteMany?: ConsultationSessionScalarWhereInput | ConsultationSessionScalarWhereInput[]
  }

  export type ConsultantAvailabilityUncheckedUpdateManyWithoutConsultantNestedInput = {
    create?: XOR<ConsultantAvailabilityCreateWithoutConsultantInput, ConsultantAvailabilityUncheckedCreateWithoutConsultantInput> | ConsultantAvailabilityCreateWithoutConsultantInput[] | ConsultantAvailabilityUncheckedCreateWithoutConsultantInput[]
    connectOrCreate?: ConsultantAvailabilityCreateOrConnectWithoutConsultantInput | ConsultantAvailabilityCreateOrConnectWithoutConsultantInput[]
    upsert?: ConsultantAvailabilityUpsertWithWhereUniqueWithoutConsultantInput | ConsultantAvailabilityUpsertWithWhereUniqueWithoutConsultantInput[]
    createMany?: ConsultantAvailabilityCreateManyConsultantInputEnvelope
    set?: ConsultantAvailabilityWhereUniqueInput | ConsultantAvailabilityWhereUniqueInput[]
    disconnect?: ConsultantAvailabilityWhereUniqueInput | ConsultantAvailabilityWhereUniqueInput[]
    delete?: ConsultantAvailabilityWhereUniqueInput | ConsultantAvailabilityWhereUniqueInput[]
    connect?: ConsultantAvailabilityWhereUniqueInput | ConsultantAvailabilityWhereUniqueInput[]
    update?: ConsultantAvailabilityUpdateWithWhereUniqueWithoutConsultantInput | ConsultantAvailabilityUpdateWithWhereUniqueWithoutConsultantInput[]
    updateMany?: ConsultantAvailabilityUpdateManyWithWhereWithoutConsultantInput | ConsultantAvailabilityUpdateManyWithWhereWithoutConsultantInput[]
    deleteMany?: ConsultantAvailabilityScalarWhereInput | ConsultantAvailabilityScalarWhereInput[]
  }

  export type ConsultantPaymentUncheckedUpdateManyWithoutConsultantNestedInput = {
    create?: XOR<ConsultantPaymentCreateWithoutConsultantInput, ConsultantPaymentUncheckedCreateWithoutConsultantInput> | ConsultantPaymentCreateWithoutConsultantInput[] | ConsultantPaymentUncheckedCreateWithoutConsultantInput[]
    connectOrCreate?: ConsultantPaymentCreateOrConnectWithoutConsultantInput | ConsultantPaymentCreateOrConnectWithoutConsultantInput[]
    upsert?: ConsultantPaymentUpsertWithWhereUniqueWithoutConsultantInput | ConsultantPaymentUpsertWithWhereUniqueWithoutConsultantInput[]
    createMany?: ConsultantPaymentCreateManyConsultantInputEnvelope
    set?: ConsultantPaymentWhereUniqueInput | ConsultantPaymentWhereUniqueInput[]
    disconnect?: ConsultantPaymentWhereUniqueInput | ConsultantPaymentWhereUniqueInput[]
    delete?: ConsultantPaymentWhereUniqueInput | ConsultantPaymentWhereUniqueInput[]
    connect?: ConsultantPaymentWhereUniqueInput | ConsultantPaymentWhereUniqueInput[]
    update?: ConsultantPaymentUpdateWithWhereUniqueWithoutConsultantInput | ConsultantPaymentUpdateWithWhereUniqueWithoutConsultantInput[]
    updateMany?: ConsultantPaymentUpdateManyWithWhereWithoutConsultantInput | ConsultantPaymentUpdateManyWithWhereWithoutConsultantInput[]
    deleteMany?: ConsultantPaymentScalarWhereInput | ConsultantPaymentScalarWhereInput[]
  }

  export type AdminCreatepermissionsInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutAdminInput = {
    create?: XOR<UserCreateWithoutAdminInput, UserUncheckedCreateWithoutAdminInput>
    connectOrCreate?: UserCreateOrConnectWithoutAdminInput
    connect?: UserWhereUniqueInput
  }

  export type AdminUpdatepermissionsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneRequiredWithoutAdminNestedInput = {
    create?: XOR<UserCreateWithoutAdminInput, UserUncheckedCreateWithoutAdminInput>
    connectOrCreate?: UserCreateOrConnectWithoutAdminInput
    upsert?: UserUpsertWithoutAdminInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAdminInput, UserUpdateWithoutAdminInput>, UserUncheckedUpdateWithoutAdminInput>
  }

  export type StudentCreateNestedOneWithoutConsultationSessionsInput = {
    create?: XOR<StudentCreateWithoutConsultationSessionsInput, StudentUncheckedCreateWithoutConsultationSessionsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutConsultationSessionsInput
    connect?: StudentWhereUniqueInput
  }

  export type ConsultantCreateNestedOneWithoutConsultationSessionsInput = {
    create?: XOR<ConsultantCreateWithoutConsultationSessionsInput, ConsultantUncheckedCreateWithoutConsultationSessionsInput>
    connectOrCreate?: ConsultantCreateOrConnectWithoutConsultationSessionsInput
    connect?: ConsultantWhereUniqueInput
  }

  export type VideoSessionCreateNestedOneWithoutConsultationSessionInput = {
    create?: XOR<VideoSessionCreateWithoutConsultationSessionInput, VideoSessionUncheckedCreateWithoutConsultationSessionInput>
    connectOrCreate?: VideoSessionCreateOrConnectWithoutConsultationSessionInput
    connect?: VideoSessionWhereUniqueInput
  }

  export type VideoSessionUncheckedCreateNestedOneWithoutConsultationSessionInput = {
    create?: XOR<VideoSessionCreateWithoutConsultationSessionInput, VideoSessionUncheckedCreateWithoutConsultationSessionInput>
    connectOrCreate?: VideoSessionCreateOrConnectWithoutConsultationSessionInput
    connect?: VideoSessionWhereUniqueInput
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type EnumSessionStatusFieldUpdateOperationsInput = {
    set?: $Enums.SessionStatus
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type StudentUpdateOneRequiredWithoutConsultationSessionsNestedInput = {
    create?: XOR<StudentCreateWithoutConsultationSessionsInput, StudentUncheckedCreateWithoutConsultationSessionsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutConsultationSessionsInput
    upsert?: StudentUpsertWithoutConsultationSessionsInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutConsultationSessionsInput, StudentUpdateWithoutConsultationSessionsInput>, StudentUncheckedUpdateWithoutConsultationSessionsInput>
  }

  export type ConsultantUpdateOneRequiredWithoutConsultationSessionsNestedInput = {
    create?: XOR<ConsultantCreateWithoutConsultationSessionsInput, ConsultantUncheckedCreateWithoutConsultationSessionsInput>
    connectOrCreate?: ConsultantCreateOrConnectWithoutConsultationSessionsInput
    upsert?: ConsultantUpsertWithoutConsultationSessionsInput
    connect?: ConsultantWhereUniqueInput
    update?: XOR<XOR<ConsultantUpdateToOneWithWhereWithoutConsultationSessionsInput, ConsultantUpdateWithoutConsultationSessionsInput>, ConsultantUncheckedUpdateWithoutConsultationSessionsInput>
  }

  export type VideoSessionUpdateOneWithoutConsultationSessionNestedInput = {
    create?: XOR<VideoSessionCreateWithoutConsultationSessionInput, VideoSessionUncheckedCreateWithoutConsultationSessionInput>
    connectOrCreate?: VideoSessionCreateOrConnectWithoutConsultationSessionInput
    upsert?: VideoSessionUpsertWithoutConsultationSessionInput
    disconnect?: VideoSessionWhereInput | boolean
    delete?: VideoSessionWhereInput | boolean
    connect?: VideoSessionWhereUniqueInput
    update?: XOR<XOR<VideoSessionUpdateToOneWithWhereWithoutConsultationSessionInput, VideoSessionUpdateWithoutConsultationSessionInput>, VideoSessionUncheckedUpdateWithoutConsultationSessionInput>
  }

  export type VideoSessionUncheckedUpdateOneWithoutConsultationSessionNestedInput = {
    create?: XOR<VideoSessionCreateWithoutConsultationSessionInput, VideoSessionUncheckedCreateWithoutConsultationSessionInput>
    connectOrCreate?: VideoSessionCreateOrConnectWithoutConsultationSessionInput
    upsert?: VideoSessionUpsertWithoutConsultationSessionInput
    disconnect?: VideoSessionWhereInput | boolean
    delete?: VideoSessionWhereInput | boolean
    connect?: VideoSessionWhereUniqueInput
    update?: XOR<XOR<VideoSessionUpdateToOneWithWhereWithoutConsultationSessionInput, VideoSessionUpdateWithoutConsultationSessionInput>, VideoSessionUncheckedUpdateWithoutConsultationSessionInput>
  }

  export type ConsultationSessionCreateNestedOneWithoutVideoSessionInput = {
    create?: XOR<ConsultationSessionCreateWithoutVideoSessionInput, ConsultationSessionUncheckedCreateWithoutVideoSessionInput>
    connectOrCreate?: ConsultationSessionCreateOrConnectWithoutVideoSessionInput
    connect?: ConsultationSessionWhereUniqueInput
  }

  export type VideoParticipantCreateNestedManyWithoutVideoSessionInput = {
    create?: XOR<VideoParticipantCreateWithoutVideoSessionInput, VideoParticipantUncheckedCreateWithoutVideoSessionInput> | VideoParticipantCreateWithoutVideoSessionInput[] | VideoParticipantUncheckedCreateWithoutVideoSessionInput[]
    connectOrCreate?: VideoParticipantCreateOrConnectWithoutVideoSessionInput | VideoParticipantCreateOrConnectWithoutVideoSessionInput[]
    createMany?: VideoParticipantCreateManyVideoSessionInputEnvelope
    connect?: VideoParticipantWhereUniqueInput | VideoParticipantWhereUniqueInput[]
  }

  export type VideoParticipantUncheckedCreateNestedManyWithoutVideoSessionInput = {
    create?: XOR<VideoParticipantCreateWithoutVideoSessionInput, VideoParticipantUncheckedCreateWithoutVideoSessionInput> | VideoParticipantCreateWithoutVideoSessionInput[] | VideoParticipantUncheckedCreateWithoutVideoSessionInput[]
    connectOrCreate?: VideoParticipantCreateOrConnectWithoutVideoSessionInput | VideoParticipantCreateOrConnectWithoutVideoSessionInput[]
    createMany?: VideoParticipantCreateManyVideoSessionInputEnvelope
    connect?: VideoParticipantWhereUniqueInput | VideoParticipantWhereUniqueInput[]
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ConsultationSessionUpdateOneRequiredWithoutVideoSessionNestedInput = {
    create?: XOR<ConsultationSessionCreateWithoutVideoSessionInput, ConsultationSessionUncheckedCreateWithoutVideoSessionInput>
    connectOrCreate?: ConsultationSessionCreateOrConnectWithoutVideoSessionInput
    upsert?: ConsultationSessionUpsertWithoutVideoSessionInput
    connect?: ConsultationSessionWhereUniqueInput
    update?: XOR<XOR<ConsultationSessionUpdateToOneWithWhereWithoutVideoSessionInput, ConsultationSessionUpdateWithoutVideoSessionInput>, ConsultationSessionUncheckedUpdateWithoutVideoSessionInput>
  }

  export type VideoParticipantUpdateManyWithoutVideoSessionNestedInput = {
    create?: XOR<VideoParticipantCreateWithoutVideoSessionInput, VideoParticipantUncheckedCreateWithoutVideoSessionInput> | VideoParticipantCreateWithoutVideoSessionInput[] | VideoParticipantUncheckedCreateWithoutVideoSessionInput[]
    connectOrCreate?: VideoParticipantCreateOrConnectWithoutVideoSessionInput | VideoParticipantCreateOrConnectWithoutVideoSessionInput[]
    upsert?: VideoParticipantUpsertWithWhereUniqueWithoutVideoSessionInput | VideoParticipantUpsertWithWhereUniqueWithoutVideoSessionInput[]
    createMany?: VideoParticipantCreateManyVideoSessionInputEnvelope
    set?: VideoParticipantWhereUniqueInput | VideoParticipantWhereUniqueInput[]
    disconnect?: VideoParticipantWhereUniqueInput | VideoParticipantWhereUniqueInput[]
    delete?: VideoParticipantWhereUniqueInput | VideoParticipantWhereUniqueInput[]
    connect?: VideoParticipantWhereUniqueInput | VideoParticipantWhereUniqueInput[]
    update?: VideoParticipantUpdateWithWhereUniqueWithoutVideoSessionInput | VideoParticipantUpdateWithWhereUniqueWithoutVideoSessionInput[]
    updateMany?: VideoParticipantUpdateManyWithWhereWithoutVideoSessionInput | VideoParticipantUpdateManyWithWhereWithoutVideoSessionInput[]
    deleteMany?: VideoParticipantScalarWhereInput | VideoParticipantScalarWhereInput[]
  }

  export type VideoParticipantUncheckedUpdateManyWithoutVideoSessionNestedInput = {
    create?: XOR<VideoParticipantCreateWithoutVideoSessionInput, VideoParticipantUncheckedCreateWithoutVideoSessionInput> | VideoParticipantCreateWithoutVideoSessionInput[] | VideoParticipantUncheckedCreateWithoutVideoSessionInput[]
    connectOrCreate?: VideoParticipantCreateOrConnectWithoutVideoSessionInput | VideoParticipantCreateOrConnectWithoutVideoSessionInput[]
    upsert?: VideoParticipantUpsertWithWhereUniqueWithoutVideoSessionInput | VideoParticipantUpsertWithWhereUniqueWithoutVideoSessionInput[]
    createMany?: VideoParticipantCreateManyVideoSessionInputEnvelope
    set?: VideoParticipantWhereUniqueInput | VideoParticipantWhereUniqueInput[]
    disconnect?: VideoParticipantWhereUniqueInput | VideoParticipantWhereUniqueInput[]
    delete?: VideoParticipantWhereUniqueInput | VideoParticipantWhereUniqueInput[]
    connect?: VideoParticipantWhereUniqueInput | VideoParticipantWhereUniqueInput[]
    update?: VideoParticipantUpdateWithWhereUniqueWithoutVideoSessionInput | VideoParticipantUpdateWithWhereUniqueWithoutVideoSessionInput[]
    updateMany?: VideoParticipantUpdateManyWithWhereWithoutVideoSessionInput | VideoParticipantUpdateManyWithWhereWithoutVideoSessionInput[]
    deleteMany?: VideoParticipantScalarWhereInput | VideoParticipantScalarWhereInput[]
  }

  export type VideoSessionCreateNestedOneWithoutVideoParticipantsInput = {
    create?: XOR<VideoSessionCreateWithoutVideoParticipantsInput, VideoSessionUncheckedCreateWithoutVideoParticipantsInput>
    connectOrCreate?: VideoSessionCreateOrConnectWithoutVideoParticipantsInput
    connect?: VideoSessionWhereUniqueInput
  }

  export type VideoSessionUpdateOneRequiredWithoutVideoParticipantsNestedInput = {
    create?: XOR<VideoSessionCreateWithoutVideoParticipantsInput, VideoSessionUncheckedCreateWithoutVideoParticipantsInput>
    connectOrCreate?: VideoSessionCreateOrConnectWithoutVideoParticipantsInput
    upsert?: VideoSessionUpsertWithoutVideoParticipantsInput
    connect?: VideoSessionWhereUniqueInput
    update?: XOR<XOR<VideoSessionUpdateToOneWithWhereWithoutVideoParticipantsInput, VideoSessionUpdateWithoutVideoParticipantsInput>, VideoSessionUncheckedUpdateWithoutVideoParticipantsInput>
  }

  export type ConsultantCreateNestedOneWithoutConsultantAvailabilityInput = {
    create?: XOR<ConsultantCreateWithoutConsultantAvailabilityInput, ConsultantUncheckedCreateWithoutConsultantAvailabilityInput>
    connectOrCreate?: ConsultantCreateOrConnectWithoutConsultantAvailabilityInput
    connect?: ConsultantWhereUniqueInput
  }

  export type EnumAvailabilityTypeFieldUpdateOperationsInput = {
    set?: $Enums.AvailabilityType
  }

  export type ConsultantUpdateOneRequiredWithoutConsultantAvailabilityNestedInput = {
    create?: XOR<ConsultantCreateWithoutConsultantAvailabilityInput, ConsultantUncheckedCreateWithoutConsultantAvailabilityInput>
    connectOrCreate?: ConsultantCreateOrConnectWithoutConsultantAvailabilityInput
    upsert?: ConsultantUpsertWithoutConsultantAvailabilityInput
    connect?: ConsultantWhereUniqueInput
    update?: XOR<XOR<ConsultantUpdateToOneWithWhereWithoutConsultantAvailabilityInput, ConsultantUpdateWithoutConsultantAvailabilityInput>, ConsultantUncheckedUpdateWithoutConsultantAvailabilityInput>
  }

  export type StudentCreateNestedOneWithoutStudentDocumentsInput = {
    create?: XOR<StudentCreateWithoutStudentDocumentsInput, StudentUncheckedCreateWithoutStudentDocumentsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutStudentDocumentsInput
    connect?: StudentWhereUniqueInput
  }

  export type EnumDocumentTypeFieldUpdateOperationsInput = {
    set?: $Enums.DocumentType
  }

  export type EnumReviewStatusFieldUpdateOperationsInput = {
    set?: $Enums.ReviewStatus
  }

  export type StudentUpdateOneRequiredWithoutStudentDocumentsNestedInput = {
    create?: XOR<StudentCreateWithoutStudentDocumentsInput, StudentUncheckedCreateWithoutStudentDocumentsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutStudentDocumentsInput
    upsert?: StudentUpsertWithoutStudentDocumentsInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutStudentDocumentsInput, StudentUpdateWithoutStudentDocumentsInput>, StudentUncheckedUpdateWithoutStudentDocumentsInput>
  }

  export type StudentCreateNestedOneWithoutSessionHistoryInput = {
    create?: XOR<StudentCreateWithoutSessionHistoryInput, StudentUncheckedCreateWithoutSessionHistoryInput>
    connectOrCreate?: StudentCreateOrConnectWithoutSessionHistoryInput
    connect?: StudentWhereUniqueInput
  }

  export type StudentUpdateOneRequiredWithoutSessionHistoryNestedInput = {
    create?: XOR<StudentCreateWithoutSessionHistoryInput, StudentUncheckedCreateWithoutSessionHistoryInput>
    connectOrCreate?: StudentCreateOrConnectWithoutSessionHistoryInput
    upsert?: StudentUpsertWithoutSessionHistoryInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutSessionHistoryInput, StudentUpdateWithoutSessionHistoryInput>, StudentUncheckedUpdateWithoutSessionHistoryInput>
  }

  export type ConsultantCreateNestedOneWithoutConsultantPaymentsInput = {
    create?: XOR<ConsultantCreateWithoutConsultantPaymentsInput, ConsultantUncheckedCreateWithoutConsultantPaymentsInput>
    connectOrCreate?: ConsultantCreateOrConnectWithoutConsultantPaymentsInput
    connect?: ConsultantWhereUniqueInput
  }

  export type EnumPaymentStatusFieldUpdateOperationsInput = {
    set?: $Enums.PaymentStatus
  }

  export type ConsultantUpdateOneRequiredWithoutConsultantPaymentsNestedInput = {
    create?: XOR<ConsultantCreateWithoutConsultantPaymentsInput, ConsultantUncheckedCreateWithoutConsultantPaymentsInput>
    connectOrCreate?: ConsultantCreateOrConnectWithoutConsultantPaymentsInput
    upsert?: ConsultantUpsertWithoutConsultantPaymentsInput
    connect?: ConsultantWhereUniqueInput
    update?: XOR<XOR<ConsultantUpdateToOneWithWhereWithoutConsultantPaymentsInput, ConsultantUpdateWithoutConsultantPaymentsInput>, ConsultantUncheckedUpdateWithoutConsultantPaymentsInput>
  }

  export type EnumScheduledNotificationStatusFieldUpdateOperationsInput = {
    set?: $Enums.ScheduledNotificationStatus
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedEnumUserTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.UserType | EnumUserTypeFieldRefInput<$PrismaModel>
    in?: $Enums.UserType[] | ListEnumUserTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserType[] | ListEnumUserTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumUserTypeFilter<$PrismaModel> | $Enums.UserType
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumUserStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserStatusFilter<$PrismaModel> | $Enums.UserStatus
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedEnumUserTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserType | EnumUserTypeFieldRefInput<$PrismaModel>
    in?: $Enums.UserType[] | ListEnumUserTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserType[] | ListEnumUserTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumUserTypeWithAggregatesFilter<$PrismaModel> | $Enums.UserType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserTypeFilter<$PrismaModel>
    _max?: NestedEnumUserTypeFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumUserStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserStatusWithAggregatesFilter<$PrismaModel> | $Enums.UserStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserStatusFilter<$PrismaModel>
    _max?: NestedEnumUserStatusFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumStudentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.StudentStatus | EnumStudentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StudentStatus[] | ListEnumStudentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.StudentStatus[] | ListEnumStudentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStudentStatusFilter<$PrismaModel> | $Enums.StudentStatus
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumStudentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StudentStatus | EnumStudentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StudentStatus[] | ListEnumStudentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.StudentStatus[] | ListEnumStudentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStudentStatusWithAggregatesFilter<$PrismaModel> | $Enums.StudentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStudentStatusFilter<$PrismaModel>
    _max?: NestedEnumStudentStatusFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumSessionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SessionStatus | EnumSessionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SessionStatus[] | ListEnumSessionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SessionStatus[] | ListEnumSessionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSessionStatusFilter<$PrismaModel> | $Enums.SessionStatus
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumSessionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SessionStatus | EnumSessionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SessionStatus[] | ListEnumSessionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SessionStatus[] | ListEnumSessionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSessionStatusWithAggregatesFilter<$PrismaModel> | $Enums.SessionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSessionStatusFilter<$PrismaModel>
    _max?: NestedEnumSessionStatusFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumAvailabilityTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AvailabilityType | EnumAvailabilityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AvailabilityType[] | ListEnumAvailabilityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AvailabilityType[] | ListEnumAvailabilityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAvailabilityTypeFilter<$PrismaModel> | $Enums.AvailabilityType
  }

  export type NestedEnumAvailabilityTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AvailabilityType | EnumAvailabilityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AvailabilityType[] | ListEnumAvailabilityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AvailabilityType[] | ListEnumAvailabilityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAvailabilityTypeWithAggregatesFilter<$PrismaModel> | $Enums.AvailabilityType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAvailabilityTypeFilter<$PrismaModel>
    _max?: NestedEnumAvailabilityTypeFilter<$PrismaModel>
  }

  export type NestedEnumDocumentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentType | EnumDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentTypeFilter<$PrismaModel> | $Enums.DocumentType
  }

  export type NestedEnumReviewStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ReviewStatus | EnumReviewStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReviewStatus[] | ListEnumReviewStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReviewStatus[] | ListEnumReviewStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReviewStatusFilter<$PrismaModel> | $Enums.ReviewStatus
  }

  export type NestedEnumDocumentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentType | EnumDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentTypeWithAggregatesFilter<$PrismaModel> | $Enums.DocumentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDocumentTypeFilter<$PrismaModel>
    _max?: NestedEnumDocumentTypeFilter<$PrismaModel>
  }

  export type NestedEnumReviewStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReviewStatus | EnumReviewStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReviewStatus[] | ListEnumReviewStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReviewStatus[] | ListEnumReviewStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReviewStatusWithAggregatesFilter<$PrismaModel> | $Enums.ReviewStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReviewStatusFilter<$PrismaModel>
    _max?: NestedEnumReviewStatusFilter<$PrismaModel>
  }

  export type NestedEnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus
  }

  export type NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>
  }

  export type NestedEnumScheduledNotificationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ScheduledNotificationStatus | EnumScheduledNotificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ScheduledNotificationStatus[] | ListEnumScheduledNotificationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ScheduledNotificationStatus[] | ListEnumScheduledNotificationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumScheduledNotificationStatusFilter<$PrismaModel> | $Enums.ScheduledNotificationStatus
  }

  export type NestedEnumScheduledNotificationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ScheduledNotificationStatus | EnumScheduledNotificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ScheduledNotificationStatus[] | ListEnumScheduledNotificationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ScheduledNotificationStatus[] | ListEnumScheduledNotificationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumScheduledNotificationStatusWithAggregatesFilter<$PrismaModel> | $Enums.ScheduledNotificationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumScheduledNotificationStatusFilter<$PrismaModel>
    _max?: NestedEnumScheduledNotificationStatusFilter<$PrismaModel>
  }

  export type StudentCreateWithoutUserInput = {
    id?: string
    kajabiUserId?: string | null
    courseCompletionDate: Date | string
    totalVerifiedHours?: number
    totalVideoHours?: number
    certificationStatus?: $Enums.StudentStatus
    preferredSessionLength?: number
    consultationPreferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    consultationSessions?: ConsultationSessionCreateNestedManyWithoutStudentInput
    studentDocuments?: StudentDocumentCreateNestedManyWithoutStudentInput
    sessionHistory?: SessionHistoryCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutUserInput = {
    id?: string
    kajabiUserId?: string | null
    courseCompletionDate: Date | string
    totalVerifiedHours?: number
    totalVideoHours?: number
    certificationStatus?: $Enums.StudentStatus
    preferredSessionLength?: number
    consultationPreferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    consultationSessions?: ConsultationSessionUncheckedCreateNestedManyWithoutStudentInput
    studentDocuments?: StudentDocumentUncheckedCreateNestedManyWithoutStudentInput
    sessionHistory?: SessionHistoryUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutUserInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutUserInput, StudentUncheckedCreateWithoutUserInput>
  }

  export type ConsultantCreateWithoutUserInput = {
    id?: string
    bio?: string | null
    specialties?: ConsultantCreatespecialtiesInput | string[]
    hourlyRate?: number
    isActive?: boolean
    timezone?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    consultationSessions?: ConsultationSessionCreateNestedManyWithoutConsultantInput
    consultantAvailability?: ConsultantAvailabilityCreateNestedManyWithoutConsultantInput
    consultantPayments?: ConsultantPaymentCreateNestedManyWithoutConsultantInput
  }

  export type ConsultantUncheckedCreateWithoutUserInput = {
    id?: string
    bio?: string | null
    specialties?: ConsultantCreatespecialtiesInput | string[]
    hourlyRate?: number
    isActive?: boolean
    timezone?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    consultationSessions?: ConsultationSessionUncheckedCreateNestedManyWithoutConsultantInput
    consultantAvailability?: ConsultantAvailabilityUncheckedCreateNestedManyWithoutConsultantInput
    consultantPayments?: ConsultantPaymentUncheckedCreateNestedManyWithoutConsultantInput
  }

  export type ConsultantCreateOrConnectWithoutUserInput = {
    where: ConsultantWhereUniqueInput
    create: XOR<ConsultantCreateWithoutUserInput, ConsultantUncheckedCreateWithoutUserInput>
  }

  export type AdminCreateWithoutUserInput = {
    id?: string
    role?: string
    permissions?: AdminCreatepermissionsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminUncheckedCreateWithoutUserInput = {
    id?: string
    role?: string
    permissions?: AdminCreatepermissionsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminCreateOrConnectWithoutUserInput = {
    where: AdminWhereUniqueInput
    create: XOR<AdminCreateWithoutUserInput, AdminUncheckedCreateWithoutUserInput>
  }

  export type StudentUpsertWithoutUserInput = {
    update: XOR<StudentUpdateWithoutUserInput, StudentUncheckedUpdateWithoutUserInput>
    create: XOR<StudentCreateWithoutUserInput, StudentUncheckedCreateWithoutUserInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutUserInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutUserInput, StudentUncheckedUpdateWithoutUserInput>
  }

  export type StudentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    kajabiUserId?: NullableStringFieldUpdateOperationsInput | string | null
    courseCompletionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalVerifiedHours?: FloatFieldUpdateOperationsInput | number
    totalVideoHours?: FloatFieldUpdateOperationsInput | number
    certificationStatus?: EnumStudentStatusFieldUpdateOperationsInput | $Enums.StudentStatus
    preferredSessionLength?: IntFieldUpdateOperationsInput | number
    consultationPreferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    consultationSessions?: ConsultationSessionUpdateManyWithoutStudentNestedInput
    studentDocuments?: StudentDocumentUpdateManyWithoutStudentNestedInput
    sessionHistory?: SessionHistoryUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    kajabiUserId?: NullableStringFieldUpdateOperationsInput | string | null
    courseCompletionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalVerifiedHours?: FloatFieldUpdateOperationsInput | number
    totalVideoHours?: FloatFieldUpdateOperationsInput | number
    certificationStatus?: EnumStudentStatusFieldUpdateOperationsInput | $Enums.StudentStatus
    preferredSessionLength?: IntFieldUpdateOperationsInput | number
    consultationPreferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    consultationSessions?: ConsultationSessionUncheckedUpdateManyWithoutStudentNestedInput
    studentDocuments?: StudentDocumentUncheckedUpdateManyWithoutStudentNestedInput
    sessionHistory?: SessionHistoryUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type ConsultantUpsertWithoutUserInput = {
    update: XOR<ConsultantUpdateWithoutUserInput, ConsultantUncheckedUpdateWithoutUserInput>
    create: XOR<ConsultantCreateWithoutUserInput, ConsultantUncheckedCreateWithoutUserInput>
    where?: ConsultantWhereInput
  }

  export type ConsultantUpdateToOneWithWhereWithoutUserInput = {
    where?: ConsultantWhereInput
    data: XOR<ConsultantUpdateWithoutUserInput, ConsultantUncheckedUpdateWithoutUserInput>
  }

  export type ConsultantUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    specialties?: ConsultantUpdatespecialtiesInput | string[]
    hourlyRate?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    timezone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    consultationSessions?: ConsultationSessionUpdateManyWithoutConsultantNestedInput
    consultantAvailability?: ConsultantAvailabilityUpdateManyWithoutConsultantNestedInput
    consultantPayments?: ConsultantPaymentUpdateManyWithoutConsultantNestedInput
  }

  export type ConsultantUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    specialties?: ConsultantUpdatespecialtiesInput | string[]
    hourlyRate?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    timezone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    consultationSessions?: ConsultationSessionUncheckedUpdateManyWithoutConsultantNestedInput
    consultantAvailability?: ConsultantAvailabilityUncheckedUpdateManyWithoutConsultantNestedInput
    consultantPayments?: ConsultantPaymentUncheckedUpdateManyWithoutConsultantNestedInput
  }

  export type AdminUpsertWithoutUserInput = {
    update: XOR<AdminUpdateWithoutUserInput, AdminUncheckedUpdateWithoutUserInput>
    create: XOR<AdminCreateWithoutUserInput, AdminUncheckedCreateWithoutUserInput>
    where?: AdminWhereInput
  }

  export type AdminUpdateToOneWithWhereWithoutUserInput = {
    where?: AdminWhereInput
    data: XOR<AdminUpdateWithoutUserInput, AdminUncheckedUpdateWithoutUserInput>
  }

  export type AdminUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    permissions?: AdminUpdatepermissionsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    permissions?: AdminUpdatepermissionsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutStudentInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    userType?: $Enums.UserType
    phone?: string | null
    status?: $Enums.UserStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    consultant?: ConsultantCreateNestedOneWithoutUserInput
    admin?: AdminCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutStudentInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    userType?: $Enums.UserType
    phone?: string | null
    status?: $Enums.UserStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    consultant?: ConsultantUncheckedCreateNestedOneWithoutUserInput
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutStudentInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutStudentInput, UserUncheckedCreateWithoutStudentInput>
  }

  export type ConsultationSessionCreateWithoutStudentInput = {
    id?: string
    scheduledStart: Date | string
    scheduledEnd: Date | string
    actualStart?: Date | string | null
    actualEnd?: Date | string | null
    status?: $Enums.SessionStatus
    sessionType?: string
    studentVerifiedAt?: Date | string | null
    consultantVerifiedAt?: Date | string | null
    studentNotes?: string | null
    consultantNotes?: string | null
    sessionRating?: number | null
    technicalIssuesReported?: boolean
    makeupSessionFor?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    consultant: ConsultantCreateNestedOneWithoutConsultationSessionsInput
    videoSession?: VideoSessionCreateNestedOneWithoutConsultationSessionInput
  }

  export type ConsultationSessionUncheckedCreateWithoutStudentInput = {
    id?: string
    consultantId: string
    scheduledStart: Date | string
    scheduledEnd: Date | string
    actualStart?: Date | string | null
    actualEnd?: Date | string | null
    status?: $Enums.SessionStatus
    sessionType?: string
    studentVerifiedAt?: Date | string | null
    consultantVerifiedAt?: Date | string | null
    studentNotes?: string | null
    consultantNotes?: string | null
    sessionRating?: number | null
    technicalIssuesReported?: boolean
    makeupSessionFor?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    videoSession?: VideoSessionUncheckedCreateNestedOneWithoutConsultationSessionInput
  }

  export type ConsultationSessionCreateOrConnectWithoutStudentInput = {
    where: ConsultationSessionWhereUniqueInput
    create: XOR<ConsultationSessionCreateWithoutStudentInput, ConsultationSessionUncheckedCreateWithoutStudentInput>
  }

  export type ConsultationSessionCreateManyStudentInputEnvelope = {
    data: ConsultationSessionCreateManyStudentInput | ConsultationSessionCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type StudentDocumentCreateWithoutStudentInput = {
    id?: string
    documentType: $Enums.DocumentType
    fileName: string
    fileSizeBytes: number
    filePath: string
    mimeType: string
    extractedText?: string | null
    uploadTimestamp?: Date | string
    reviewStatus?: $Enums.ReviewStatus
    reviewedBy?: string | null
    reviewedAt?: Date | string | null
    reviewNotes?: string | null
    versionNumber?: number
    replacesDocumentId?: string | null
    autoValidationScore?: number | null
    requiresManualReview?: boolean
    createdAt?: Date | string
  }

  export type StudentDocumentUncheckedCreateWithoutStudentInput = {
    id?: string
    documentType: $Enums.DocumentType
    fileName: string
    fileSizeBytes: number
    filePath: string
    mimeType: string
    extractedText?: string | null
    uploadTimestamp?: Date | string
    reviewStatus?: $Enums.ReviewStatus
    reviewedBy?: string | null
    reviewedAt?: Date | string | null
    reviewNotes?: string | null
    versionNumber?: number
    replacesDocumentId?: string | null
    autoValidationScore?: number | null
    requiresManualReview?: boolean
    createdAt?: Date | string
  }

  export type StudentDocumentCreateOrConnectWithoutStudentInput = {
    where: StudentDocumentWhereUniqueInput
    create: XOR<StudentDocumentCreateWithoutStudentInput, StudentDocumentUncheckedCreateWithoutStudentInput>
  }

  export type StudentDocumentCreateManyStudentInputEnvelope = {
    data: StudentDocumentCreateManyStudentInput | StudentDocumentCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type SessionHistoryCreateWithoutStudentInput = {
    id?: string
    sessionDate: Date | string
    sessionDuration: number
    consultantId: string
    sessionType: string
    status: string
    rating?: number | null
    createdAt?: Date | string
  }

  export type SessionHistoryUncheckedCreateWithoutStudentInput = {
    id?: string
    sessionDate: Date | string
    sessionDuration: number
    consultantId: string
    sessionType: string
    status: string
    rating?: number | null
    createdAt?: Date | string
  }

  export type SessionHistoryCreateOrConnectWithoutStudentInput = {
    where: SessionHistoryWhereUniqueInput
    create: XOR<SessionHistoryCreateWithoutStudentInput, SessionHistoryUncheckedCreateWithoutStudentInput>
  }

  export type SessionHistoryCreateManyStudentInputEnvelope = {
    data: SessionHistoryCreateManyStudentInput | SessionHistoryCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutStudentInput = {
    update: XOR<UserUpdateWithoutStudentInput, UserUncheckedUpdateWithoutStudentInput>
    create: XOR<UserCreateWithoutStudentInput, UserUncheckedCreateWithoutStudentInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutStudentInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutStudentInput, UserUncheckedUpdateWithoutStudentInput>
  }

  export type UserUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    consultant?: ConsultantUpdateOneWithoutUserNestedInput
    admin?: AdminUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    consultant?: ConsultantUncheckedUpdateOneWithoutUserNestedInput
    admin?: AdminUncheckedUpdateOneWithoutUserNestedInput
  }

  export type ConsultationSessionUpsertWithWhereUniqueWithoutStudentInput = {
    where: ConsultationSessionWhereUniqueInput
    update: XOR<ConsultationSessionUpdateWithoutStudentInput, ConsultationSessionUncheckedUpdateWithoutStudentInput>
    create: XOR<ConsultationSessionCreateWithoutStudentInput, ConsultationSessionUncheckedCreateWithoutStudentInput>
  }

  export type ConsultationSessionUpdateWithWhereUniqueWithoutStudentInput = {
    where: ConsultationSessionWhereUniqueInput
    data: XOR<ConsultationSessionUpdateWithoutStudentInput, ConsultationSessionUncheckedUpdateWithoutStudentInput>
  }

  export type ConsultationSessionUpdateManyWithWhereWithoutStudentInput = {
    where: ConsultationSessionScalarWhereInput
    data: XOR<ConsultationSessionUpdateManyMutationInput, ConsultationSessionUncheckedUpdateManyWithoutStudentInput>
  }

  export type ConsultationSessionScalarWhereInput = {
    AND?: ConsultationSessionScalarWhereInput | ConsultationSessionScalarWhereInput[]
    OR?: ConsultationSessionScalarWhereInput[]
    NOT?: ConsultationSessionScalarWhereInput | ConsultationSessionScalarWhereInput[]
    id?: StringFilter<"ConsultationSession"> | string
    studentId?: StringFilter<"ConsultationSession"> | string
    consultantId?: StringFilter<"ConsultationSession"> | string
    scheduledStart?: DateTimeFilter<"ConsultationSession"> | Date | string
    scheduledEnd?: DateTimeFilter<"ConsultationSession"> | Date | string
    actualStart?: DateTimeNullableFilter<"ConsultationSession"> | Date | string | null
    actualEnd?: DateTimeNullableFilter<"ConsultationSession"> | Date | string | null
    status?: EnumSessionStatusFilter<"ConsultationSession"> | $Enums.SessionStatus
    sessionType?: StringFilter<"ConsultationSession"> | string
    studentVerifiedAt?: DateTimeNullableFilter<"ConsultationSession"> | Date | string | null
    consultantVerifiedAt?: DateTimeNullableFilter<"ConsultationSession"> | Date | string | null
    studentNotes?: StringNullableFilter<"ConsultationSession"> | string | null
    consultantNotes?: StringNullableFilter<"ConsultationSession"> | string | null
    sessionRating?: IntNullableFilter<"ConsultationSession"> | number | null
    technicalIssuesReported?: BoolFilter<"ConsultationSession"> | boolean
    makeupSessionFor?: StringNullableFilter<"ConsultationSession"> | string | null
    createdAt?: DateTimeFilter<"ConsultationSession"> | Date | string
    updatedAt?: DateTimeFilter<"ConsultationSession"> | Date | string
  }

  export type StudentDocumentUpsertWithWhereUniqueWithoutStudentInput = {
    where: StudentDocumentWhereUniqueInput
    update: XOR<StudentDocumentUpdateWithoutStudentInput, StudentDocumentUncheckedUpdateWithoutStudentInput>
    create: XOR<StudentDocumentCreateWithoutStudentInput, StudentDocumentUncheckedCreateWithoutStudentInput>
  }

  export type StudentDocumentUpdateWithWhereUniqueWithoutStudentInput = {
    where: StudentDocumentWhereUniqueInput
    data: XOR<StudentDocumentUpdateWithoutStudentInput, StudentDocumentUncheckedUpdateWithoutStudentInput>
  }

  export type StudentDocumentUpdateManyWithWhereWithoutStudentInput = {
    where: StudentDocumentScalarWhereInput
    data: XOR<StudentDocumentUpdateManyMutationInput, StudentDocumentUncheckedUpdateManyWithoutStudentInput>
  }

  export type StudentDocumentScalarWhereInput = {
    AND?: StudentDocumentScalarWhereInput | StudentDocumentScalarWhereInput[]
    OR?: StudentDocumentScalarWhereInput[]
    NOT?: StudentDocumentScalarWhereInput | StudentDocumentScalarWhereInput[]
    id?: StringFilter<"StudentDocument"> | string
    studentId?: StringFilter<"StudentDocument"> | string
    documentType?: EnumDocumentTypeFilter<"StudentDocument"> | $Enums.DocumentType
    fileName?: StringFilter<"StudentDocument"> | string
    fileSizeBytes?: IntFilter<"StudentDocument"> | number
    filePath?: StringFilter<"StudentDocument"> | string
    mimeType?: StringFilter<"StudentDocument"> | string
    extractedText?: StringNullableFilter<"StudentDocument"> | string | null
    uploadTimestamp?: DateTimeFilter<"StudentDocument"> | Date | string
    reviewStatus?: EnumReviewStatusFilter<"StudentDocument"> | $Enums.ReviewStatus
    reviewedBy?: StringNullableFilter<"StudentDocument"> | string | null
    reviewedAt?: DateTimeNullableFilter<"StudentDocument"> | Date | string | null
    reviewNotes?: StringNullableFilter<"StudentDocument"> | string | null
    versionNumber?: IntFilter<"StudentDocument"> | number
    replacesDocumentId?: StringNullableFilter<"StudentDocument"> | string | null
    autoValidationScore?: FloatNullableFilter<"StudentDocument"> | number | null
    requiresManualReview?: BoolFilter<"StudentDocument"> | boolean
    createdAt?: DateTimeFilter<"StudentDocument"> | Date | string
  }

  export type SessionHistoryUpsertWithWhereUniqueWithoutStudentInput = {
    where: SessionHistoryWhereUniqueInput
    update: XOR<SessionHistoryUpdateWithoutStudentInput, SessionHistoryUncheckedUpdateWithoutStudentInput>
    create: XOR<SessionHistoryCreateWithoutStudentInput, SessionHistoryUncheckedCreateWithoutStudentInput>
  }

  export type SessionHistoryUpdateWithWhereUniqueWithoutStudentInput = {
    where: SessionHistoryWhereUniqueInput
    data: XOR<SessionHistoryUpdateWithoutStudentInput, SessionHistoryUncheckedUpdateWithoutStudentInput>
  }

  export type SessionHistoryUpdateManyWithWhereWithoutStudentInput = {
    where: SessionHistoryScalarWhereInput
    data: XOR<SessionHistoryUpdateManyMutationInput, SessionHistoryUncheckedUpdateManyWithoutStudentInput>
  }

  export type SessionHistoryScalarWhereInput = {
    AND?: SessionHistoryScalarWhereInput | SessionHistoryScalarWhereInput[]
    OR?: SessionHistoryScalarWhereInput[]
    NOT?: SessionHistoryScalarWhereInput | SessionHistoryScalarWhereInput[]
    id?: StringFilter<"SessionHistory"> | string
    studentId?: StringFilter<"SessionHistory"> | string
    sessionDate?: DateTimeFilter<"SessionHistory"> | Date | string
    sessionDuration?: IntFilter<"SessionHistory"> | number
    consultantId?: StringFilter<"SessionHistory"> | string
    sessionType?: StringFilter<"SessionHistory"> | string
    status?: StringFilter<"SessionHistory"> | string
    rating?: IntNullableFilter<"SessionHistory"> | number | null
    createdAt?: DateTimeFilter<"SessionHistory"> | Date | string
  }

  export type UserCreateWithoutConsultantInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    userType?: $Enums.UserType
    phone?: string | null
    status?: $Enums.UserStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    student?: StudentCreateNestedOneWithoutUserInput
    admin?: AdminCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutConsultantInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    userType?: $Enums.UserType
    phone?: string | null
    status?: $Enums.UserStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    student?: StudentUncheckedCreateNestedOneWithoutUserInput
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutConsultantInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutConsultantInput, UserUncheckedCreateWithoutConsultantInput>
  }

  export type ConsultationSessionCreateWithoutConsultantInput = {
    id?: string
    scheduledStart: Date | string
    scheduledEnd: Date | string
    actualStart?: Date | string | null
    actualEnd?: Date | string | null
    status?: $Enums.SessionStatus
    sessionType?: string
    studentVerifiedAt?: Date | string | null
    consultantVerifiedAt?: Date | string | null
    studentNotes?: string | null
    consultantNotes?: string | null
    sessionRating?: number | null
    technicalIssuesReported?: boolean
    makeupSessionFor?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutConsultationSessionsInput
    videoSession?: VideoSessionCreateNestedOneWithoutConsultationSessionInput
  }

  export type ConsultationSessionUncheckedCreateWithoutConsultantInput = {
    id?: string
    studentId: string
    scheduledStart: Date | string
    scheduledEnd: Date | string
    actualStart?: Date | string | null
    actualEnd?: Date | string | null
    status?: $Enums.SessionStatus
    sessionType?: string
    studentVerifiedAt?: Date | string | null
    consultantVerifiedAt?: Date | string | null
    studentNotes?: string | null
    consultantNotes?: string | null
    sessionRating?: number | null
    technicalIssuesReported?: boolean
    makeupSessionFor?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    videoSession?: VideoSessionUncheckedCreateNestedOneWithoutConsultationSessionInput
  }

  export type ConsultationSessionCreateOrConnectWithoutConsultantInput = {
    where: ConsultationSessionWhereUniqueInput
    create: XOR<ConsultationSessionCreateWithoutConsultantInput, ConsultationSessionUncheckedCreateWithoutConsultantInput>
  }

  export type ConsultationSessionCreateManyConsultantInputEnvelope = {
    data: ConsultationSessionCreateManyConsultantInput | ConsultationSessionCreateManyConsultantInput[]
    skipDuplicates?: boolean
  }

  export type ConsultantAvailabilityCreateWithoutConsultantInput = {
    id?: string
    availabilityType: $Enums.AvailabilityType
    dayOfWeek?: number | null
    specificDate?: Date | string | null
    startTime: string
    endTime: string
    maxSessions?: number
    bufferMinutes?: number
    isAvailable?: boolean
    bookingWindowDays?: number
    minimumNoticeHours?: number
    autoApprove?: boolean
    timezone: string
    recurringPattern?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConsultantAvailabilityUncheckedCreateWithoutConsultantInput = {
    id?: string
    availabilityType: $Enums.AvailabilityType
    dayOfWeek?: number | null
    specificDate?: Date | string | null
    startTime: string
    endTime: string
    maxSessions?: number
    bufferMinutes?: number
    isAvailable?: boolean
    bookingWindowDays?: number
    minimumNoticeHours?: number
    autoApprove?: boolean
    timezone: string
    recurringPattern?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConsultantAvailabilityCreateOrConnectWithoutConsultantInput = {
    where: ConsultantAvailabilityWhereUniqueInput
    create: XOR<ConsultantAvailabilityCreateWithoutConsultantInput, ConsultantAvailabilityUncheckedCreateWithoutConsultantInput>
  }

  export type ConsultantAvailabilityCreateManyConsultantInputEnvelope = {
    data: ConsultantAvailabilityCreateManyConsultantInput | ConsultantAvailabilityCreateManyConsultantInput[]
    skipDuplicates?: boolean
  }

  export type ConsultantPaymentCreateWithoutConsultantInput = {
    id?: string
    paymentPeriod: string
    totalHours: number
    hourlyRate: number
    totalAmount: number
    paymentStatus?: $Enums.PaymentStatus
    paymentDate?: Date | string | null
    sessionBreakdown?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ConsultantPaymentUncheckedCreateWithoutConsultantInput = {
    id?: string
    paymentPeriod: string
    totalHours: number
    hourlyRate: number
    totalAmount: number
    paymentStatus?: $Enums.PaymentStatus
    paymentDate?: Date | string | null
    sessionBreakdown?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ConsultantPaymentCreateOrConnectWithoutConsultantInput = {
    where: ConsultantPaymentWhereUniqueInput
    create: XOR<ConsultantPaymentCreateWithoutConsultantInput, ConsultantPaymentUncheckedCreateWithoutConsultantInput>
  }

  export type ConsultantPaymentCreateManyConsultantInputEnvelope = {
    data: ConsultantPaymentCreateManyConsultantInput | ConsultantPaymentCreateManyConsultantInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutConsultantInput = {
    update: XOR<UserUpdateWithoutConsultantInput, UserUncheckedUpdateWithoutConsultantInput>
    create: XOR<UserCreateWithoutConsultantInput, UserUncheckedCreateWithoutConsultantInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutConsultantInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutConsultantInput, UserUncheckedUpdateWithoutConsultantInput>
  }

  export type UserUpdateWithoutConsultantInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneWithoutUserNestedInput
    admin?: AdminUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutConsultantInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUncheckedUpdateOneWithoutUserNestedInput
    admin?: AdminUncheckedUpdateOneWithoutUserNestedInput
  }

  export type ConsultationSessionUpsertWithWhereUniqueWithoutConsultantInput = {
    where: ConsultationSessionWhereUniqueInput
    update: XOR<ConsultationSessionUpdateWithoutConsultantInput, ConsultationSessionUncheckedUpdateWithoutConsultantInput>
    create: XOR<ConsultationSessionCreateWithoutConsultantInput, ConsultationSessionUncheckedCreateWithoutConsultantInput>
  }

  export type ConsultationSessionUpdateWithWhereUniqueWithoutConsultantInput = {
    where: ConsultationSessionWhereUniqueInput
    data: XOR<ConsultationSessionUpdateWithoutConsultantInput, ConsultationSessionUncheckedUpdateWithoutConsultantInput>
  }

  export type ConsultationSessionUpdateManyWithWhereWithoutConsultantInput = {
    where: ConsultationSessionScalarWhereInput
    data: XOR<ConsultationSessionUpdateManyMutationInput, ConsultationSessionUncheckedUpdateManyWithoutConsultantInput>
  }

  export type ConsultantAvailabilityUpsertWithWhereUniqueWithoutConsultantInput = {
    where: ConsultantAvailabilityWhereUniqueInput
    update: XOR<ConsultantAvailabilityUpdateWithoutConsultantInput, ConsultantAvailabilityUncheckedUpdateWithoutConsultantInput>
    create: XOR<ConsultantAvailabilityCreateWithoutConsultantInput, ConsultantAvailabilityUncheckedCreateWithoutConsultantInput>
  }

  export type ConsultantAvailabilityUpdateWithWhereUniqueWithoutConsultantInput = {
    where: ConsultantAvailabilityWhereUniqueInput
    data: XOR<ConsultantAvailabilityUpdateWithoutConsultantInput, ConsultantAvailabilityUncheckedUpdateWithoutConsultantInput>
  }

  export type ConsultantAvailabilityUpdateManyWithWhereWithoutConsultantInput = {
    where: ConsultantAvailabilityScalarWhereInput
    data: XOR<ConsultantAvailabilityUpdateManyMutationInput, ConsultantAvailabilityUncheckedUpdateManyWithoutConsultantInput>
  }

  export type ConsultantAvailabilityScalarWhereInput = {
    AND?: ConsultantAvailabilityScalarWhereInput | ConsultantAvailabilityScalarWhereInput[]
    OR?: ConsultantAvailabilityScalarWhereInput[]
    NOT?: ConsultantAvailabilityScalarWhereInput | ConsultantAvailabilityScalarWhereInput[]
    id?: StringFilter<"ConsultantAvailability"> | string
    consultantId?: StringFilter<"ConsultantAvailability"> | string
    availabilityType?: EnumAvailabilityTypeFilter<"ConsultantAvailability"> | $Enums.AvailabilityType
    dayOfWeek?: IntNullableFilter<"ConsultantAvailability"> | number | null
    specificDate?: DateTimeNullableFilter<"ConsultantAvailability"> | Date | string | null
    startTime?: StringFilter<"ConsultantAvailability"> | string
    endTime?: StringFilter<"ConsultantAvailability"> | string
    maxSessions?: IntFilter<"ConsultantAvailability"> | number
    bufferMinutes?: IntFilter<"ConsultantAvailability"> | number
    isAvailable?: BoolFilter<"ConsultantAvailability"> | boolean
    bookingWindowDays?: IntFilter<"ConsultantAvailability"> | number
    minimumNoticeHours?: IntFilter<"ConsultantAvailability"> | number
    autoApprove?: BoolFilter<"ConsultantAvailability"> | boolean
    timezone?: StringFilter<"ConsultantAvailability"> | string
    recurringPattern?: JsonNullableFilter<"ConsultantAvailability">
    createdAt?: DateTimeFilter<"ConsultantAvailability"> | Date | string
    updatedAt?: DateTimeFilter<"ConsultantAvailability"> | Date | string
  }

  export type ConsultantPaymentUpsertWithWhereUniqueWithoutConsultantInput = {
    where: ConsultantPaymentWhereUniqueInput
    update: XOR<ConsultantPaymentUpdateWithoutConsultantInput, ConsultantPaymentUncheckedUpdateWithoutConsultantInput>
    create: XOR<ConsultantPaymentCreateWithoutConsultantInput, ConsultantPaymentUncheckedCreateWithoutConsultantInput>
  }

  export type ConsultantPaymentUpdateWithWhereUniqueWithoutConsultantInput = {
    where: ConsultantPaymentWhereUniqueInput
    data: XOR<ConsultantPaymentUpdateWithoutConsultantInput, ConsultantPaymentUncheckedUpdateWithoutConsultantInput>
  }

  export type ConsultantPaymentUpdateManyWithWhereWithoutConsultantInput = {
    where: ConsultantPaymentScalarWhereInput
    data: XOR<ConsultantPaymentUpdateManyMutationInput, ConsultantPaymentUncheckedUpdateManyWithoutConsultantInput>
  }

  export type ConsultantPaymentScalarWhereInput = {
    AND?: ConsultantPaymentScalarWhereInput | ConsultantPaymentScalarWhereInput[]
    OR?: ConsultantPaymentScalarWhereInput[]
    NOT?: ConsultantPaymentScalarWhereInput | ConsultantPaymentScalarWhereInput[]
    id?: StringFilter<"ConsultantPayment"> | string
    consultantId?: StringFilter<"ConsultantPayment"> | string
    paymentPeriod?: StringFilter<"ConsultantPayment"> | string
    totalHours?: FloatFilter<"ConsultantPayment"> | number
    hourlyRate?: FloatFilter<"ConsultantPayment"> | number
    totalAmount?: FloatFilter<"ConsultantPayment"> | number
    paymentStatus?: EnumPaymentStatusFilter<"ConsultantPayment"> | $Enums.PaymentStatus
    paymentDate?: DateTimeNullableFilter<"ConsultantPayment"> | Date | string | null
    sessionBreakdown?: JsonNullableFilter<"ConsultantPayment">
    createdAt?: DateTimeFilter<"ConsultantPayment"> | Date | string
  }

  export type UserCreateWithoutAdminInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    userType?: $Enums.UserType
    phone?: string | null
    status?: $Enums.UserStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    student?: StudentCreateNestedOneWithoutUserInput
    consultant?: ConsultantCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAdminInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    userType?: $Enums.UserType
    phone?: string | null
    status?: $Enums.UserStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    student?: StudentUncheckedCreateNestedOneWithoutUserInput
    consultant?: ConsultantUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAdminInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAdminInput, UserUncheckedCreateWithoutAdminInput>
  }

  export type UserUpsertWithoutAdminInput = {
    update: XOR<UserUpdateWithoutAdminInput, UserUncheckedUpdateWithoutAdminInput>
    create: XOR<UserCreateWithoutAdminInput, UserUncheckedCreateWithoutAdminInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAdminInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAdminInput, UserUncheckedUpdateWithoutAdminInput>
  }

  export type UserUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneWithoutUserNestedInput
    consultant?: ConsultantUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUncheckedUpdateOneWithoutUserNestedInput
    consultant?: ConsultantUncheckedUpdateOneWithoutUserNestedInput
  }

  export type StudentCreateWithoutConsultationSessionsInput = {
    id?: string
    kajabiUserId?: string | null
    courseCompletionDate: Date | string
    totalVerifiedHours?: number
    totalVideoHours?: number
    certificationStatus?: $Enums.StudentStatus
    preferredSessionLength?: number
    consultationPreferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutStudentInput
    studentDocuments?: StudentDocumentCreateNestedManyWithoutStudentInput
    sessionHistory?: SessionHistoryCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutConsultationSessionsInput = {
    id?: string
    userId: string
    kajabiUserId?: string | null
    courseCompletionDate: Date | string
    totalVerifiedHours?: number
    totalVideoHours?: number
    certificationStatus?: $Enums.StudentStatus
    preferredSessionLength?: number
    consultationPreferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    studentDocuments?: StudentDocumentUncheckedCreateNestedManyWithoutStudentInput
    sessionHistory?: SessionHistoryUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutConsultationSessionsInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutConsultationSessionsInput, StudentUncheckedCreateWithoutConsultationSessionsInput>
  }

  export type ConsultantCreateWithoutConsultationSessionsInput = {
    id?: string
    bio?: string | null
    specialties?: ConsultantCreatespecialtiesInput | string[]
    hourlyRate?: number
    isActive?: boolean
    timezone?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutConsultantInput
    consultantAvailability?: ConsultantAvailabilityCreateNestedManyWithoutConsultantInput
    consultantPayments?: ConsultantPaymentCreateNestedManyWithoutConsultantInput
  }

  export type ConsultantUncheckedCreateWithoutConsultationSessionsInput = {
    id?: string
    userId: string
    bio?: string | null
    specialties?: ConsultantCreatespecialtiesInput | string[]
    hourlyRate?: number
    isActive?: boolean
    timezone?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    consultantAvailability?: ConsultantAvailabilityUncheckedCreateNestedManyWithoutConsultantInput
    consultantPayments?: ConsultantPaymentUncheckedCreateNestedManyWithoutConsultantInput
  }

  export type ConsultantCreateOrConnectWithoutConsultationSessionsInput = {
    where: ConsultantWhereUniqueInput
    create: XOR<ConsultantCreateWithoutConsultationSessionsInput, ConsultantUncheckedCreateWithoutConsultationSessionsInput>
  }

  export type VideoSessionCreateWithoutConsultationSessionInput = {
    id?: string
    roomId: string
    recordingEnabled?: boolean
    recordingUrl?: string | null
    recordingDurationSeconds?: number | null
    videoQuality?: string
    connectionQualityAvg?: number | null
    bandwidthUsageMb?: number | null
    technicalIssues?: NullableJsonNullValueInput | InputJsonValue
    sessionMetadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    videoParticipants?: VideoParticipantCreateNestedManyWithoutVideoSessionInput
  }

  export type VideoSessionUncheckedCreateWithoutConsultationSessionInput = {
    id?: string
    roomId: string
    recordingEnabled?: boolean
    recordingUrl?: string | null
    recordingDurationSeconds?: number | null
    videoQuality?: string
    connectionQualityAvg?: number | null
    bandwidthUsageMb?: number | null
    technicalIssues?: NullableJsonNullValueInput | InputJsonValue
    sessionMetadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    videoParticipants?: VideoParticipantUncheckedCreateNestedManyWithoutVideoSessionInput
  }

  export type VideoSessionCreateOrConnectWithoutConsultationSessionInput = {
    where: VideoSessionWhereUniqueInput
    create: XOR<VideoSessionCreateWithoutConsultationSessionInput, VideoSessionUncheckedCreateWithoutConsultationSessionInput>
  }

  export type StudentUpsertWithoutConsultationSessionsInput = {
    update: XOR<StudentUpdateWithoutConsultationSessionsInput, StudentUncheckedUpdateWithoutConsultationSessionsInput>
    create: XOR<StudentCreateWithoutConsultationSessionsInput, StudentUncheckedCreateWithoutConsultationSessionsInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutConsultationSessionsInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutConsultationSessionsInput, StudentUncheckedUpdateWithoutConsultationSessionsInput>
  }

  export type StudentUpdateWithoutConsultationSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    kajabiUserId?: NullableStringFieldUpdateOperationsInput | string | null
    courseCompletionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalVerifiedHours?: FloatFieldUpdateOperationsInput | number
    totalVideoHours?: FloatFieldUpdateOperationsInput | number
    certificationStatus?: EnumStudentStatusFieldUpdateOperationsInput | $Enums.StudentStatus
    preferredSessionLength?: IntFieldUpdateOperationsInput | number
    consultationPreferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStudentNestedInput
    studentDocuments?: StudentDocumentUpdateManyWithoutStudentNestedInput
    sessionHistory?: SessionHistoryUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutConsultationSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    kajabiUserId?: NullableStringFieldUpdateOperationsInput | string | null
    courseCompletionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalVerifiedHours?: FloatFieldUpdateOperationsInput | number
    totalVideoHours?: FloatFieldUpdateOperationsInput | number
    certificationStatus?: EnumStudentStatusFieldUpdateOperationsInput | $Enums.StudentStatus
    preferredSessionLength?: IntFieldUpdateOperationsInput | number
    consultationPreferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentDocuments?: StudentDocumentUncheckedUpdateManyWithoutStudentNestedInput
    sessionHistory?: SessionHistoryUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type ConsultantUpsertWithoutConsultationSessionsInput = {
    update: XOR<ConsultantUpdateWithoutConsultationSessionsInput, ConsultantUncheckedUpdateWithoutConsultationSessionsInput>
    create: XOR<ConsultantCreateWithoutConsultationSessionsInput, ConsultantUncheckedCreateWithoutConsultationSessionsInput>
    where?: ConsultantWhereInput
  }

  export type ConsultantUpdateToOneWithWhereWithoutConsultationSessionsInput = {
    where?: ConsultantWhereInput
    data: XOR<ConsultantUpdateWithoutConsultationSessionsInput, ConsultantUncheckedUpdateWithoutConsultationSessionsInput>
  }

  export type ConsultantUpdateWithoutConsultationSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    specialties?: ConsultantUpdatespecialtiesInput | string[]
    hourlyRate?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    timezone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutConsultantNestedInput
    consultantAvailability?: ConsultantAvailabilityUpdateManyWithoutConsultantNestedInput
    consultantPayments?: ConsultantPaymentUpdateManyWithoutConsultantNestedInput
  }

  export type ConsultantUncheckedUpdateWithoutConsultationSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    specialties?: ConsultantUpdatespecialtiesInput | string[]
    hourlyRate?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    timezone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    consultantAvailability?: ConsultantAvailabilityUncheckedUpdateManyWithoutConsultantNestedInput
    consultantPayments?: ConsultantPaymentUncheckedUpdateManyWithoutConsultantNestedInput
  }

  export type VideoSessionUpsertWithoutConsultationSessionInput = {
    update: XOR<VideoSessionUpdateWithoutConsultationSessionInput, VideoSessionUncheckedUpdateWithoutConsultationSessionInput>
    create: XOR<VideoSessionCreateWithoutConsultationSessionInput, VideoSessionUncheckedCreateWithoutConsultationSessionInput>
    where?: VideoSessionWhereInput
  }

  export type VideoSessionUpdateToOneWithWhereWithoutConsultationSessionInput = {
    where?: VideoSessionWhereInput
    data: XOR<VideoSessionUpdateWithoutConsultationSessionInput, VideoSessionUncheckedUpdateWithoutConsultationSessionInput>
  }

  export type VideoSessionUpdateWithoutConsultationSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    recordingEnabled?: BoolFieldUpdateOperationsInput | boolean
    recordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    recordingDurationSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    videoQuality?: StringFieldUpdateOperationsInput | string
    connectionQualityAvg?: NullableFloatFieldUpdateOperationsInput | number | null
    bandwidthUsageMb?: NullableFloatFieldUpdateOperationsInput | number | null
    technicalIssues?: NullableJsonNullValueInput | InputJsonValue
    sessionMetadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    videoParticipants?: VideoParticipantUpdateManyWithoutVideoSessionNestedInput
  }

  export type VideoSessionUncheckedUpdateWithoutConsultationSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    recordingEnabled?: BoolFieldUpdateOperationsInput | boolean
    recordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    recordingDurationSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    videoQuality?: StringFieldUpdateOperationsInput | string
    connectionQualityAvg?: NullableFloatFieldUpdateOperationsInput | number | null
    bandwidthUsageMb?: NullableFloatFieldUpdateOperationsInput | number | null
    technicalIssues?: NullableJsonNullValueInput | InputJsonValue
    sessionMetadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    videoParticipants?: VideoParticipantUncheckedUpdateManyWithoutVideoSessionNestedInput
  }

  export type ConsultationSessionCreateWithoutVideoSessionInput = {
    id?: string
    scheduledStart: Date | string
    scheduledEnd: Date | string
    actualStart?: Date | string | null
    actualEnd?: Date | string | null
    status?: $Enums.SessionStatus
    sessionType?: string
    studentVerifiedAt?: Date | string | null
    consultantVerifiedAt?: Date | string | null
    studentNotes?: string | null
    consultantNotes?: string | null
    sessionRating?: number | null
    technicalIssuesReported?: boolean
    makeupSessionFor?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutConsultationSessionsInput
    consultant: ConsultantCreateNestedOneWithoutConsultationSessionsInput
  }

  export type ConsultationSessionUncheckedCreateWithoutVideoSessionInput = {
    id?: string
    studentId: string
    consultantId: string
    scheduledStart: Date | string
    scheduledEnd: Date | string
    actualStart?: Date | string | null
    actualEnd?: Date | string | null
    status?: $Enums.SessionStatus
    sessionType?: string
    studentVerifiedAt?: Date | string | null
    consultantVerifiedAt?: Date | string | null
    studentNotes?: string | null
    consultantNotes?: string | null
    sessionRating?: number | null
    technicalIssuesReported?: boolean
    makeupSessionFor?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConsultationSessionCreateOrConnectWithoutVideoSessionInput = {
    where: ConsultationSessionWhereUniqueInput
    create: XOR<ConsultationSessionCreateWithoutVideoSessionInput, ConsultationSessionUncheckedCreateWithoutVideoSessionInput>
  }

  export type VideoParticipantCreateWithoutVideoSessionInput = {
    id?: string
    userId: string
    userType: $Enums.UserType
    joinTime: Date | string
    leaveTime?: Date | string | null
    totalDurationSeconds?: number | null
    audioQualityAvg?: number | null
    videoQualityAvg?: number | null
    screenShareDurationSeconds?: number
    chatMessagesCount?: number
    connectionInterruptions?: number
    createdAt?: Date | string
  }

  export type VideoParticipantUncheckedCreateWithoutVideoSessionInput = {
    id?: string
    userId: string
    userType: $Enums.UserType
    joinTime: Date | string
    leaveTime?: Date | string | null
    totalDurationSeconds?: number | null
    audioQualityAvg?: number | null
    videoQualityAvg?: number | null
    screenShareDurationSeconds?: number
    chatMessagesCount?: number
    connectionInterruptions?: number
    createdAt?: Date | string
  }

  export type VideoParticipantCreateOrConnectWithoutVideoSessionInput = {
    where: VideoParticipantWhereUniqueInput
    create: XOR<VideoParticipantCreateWithoutVideoSessionInput, VideoParticipantUncheckedCreateWithoutVideoSessionInput>
  }

  export type VideoParticipantCreateManyVideoSessionInputEnvelope = {
    data: VideoParticipantCreateManyVideoSessionInput | VideoParticipantCreateManyVideoSessionInput[]
    skipDuplicates?: boolean
  }

  export type ConsultationSessionUpsertWithoutVideoSessionInput = {
    update: XOR<ConsultationSessionUpdateWithoutVideoSessionInput, ConsultationSessionUncheckedUpdateWithoutVideoSessionInput>
    create: XOR<ConsultationSessionCreateWithoutVideoSessionInput, ConsultationSessionUncheckedCreateWithoutVideoSessionInput>
    where?: ConsultationSessionWhereInput
  }

  export type ConsultationSessionUpdateToOneWithWhereWithoutVideoSessionInput = {
    where?: ConsultationSessionWhereInput
    data: XOR<ConsultationSessionUpdateWithoutVideoSessionInput, ConsultationSessionUncheckedUpdateWithoutVideoSessionInput>
  }

  export type ConsultationSessionUpdateWithoutVideoSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduledStart?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    actualStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    sessionType?: StringFieldUpdateOperationsInput | string
    studentVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    consultantVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    studentNotes?: NullableStringFieldUpdateOperationsInput | string | null
    consultantNotes?: NullableStringFieldUpdateOperationsInput | string | null
    sessionRating?: NullableIntFieldUpdateOperationsInput | number | null
    technicalIssuesReported?: BoolFieldUpdateOperationsInput | boolean
    makeupSessionFor?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutConsultationSessionsNestedInput
    consultant?: ConsultantUpdateOneRequiredWithoutConsultationSessionsNestedInput
  }

  export type ConsultationSessionUncheckedUpdateWithoutVideoSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    consultantId?: StringFieldUpdateOperationsInput | string
    scheduledStart?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    actualStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    sessionType?: StringFieldUpdateOperationsInput | string
    studentVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    consultantVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    studentNotes?: NullableStringFieldUpdateOperationsInput | string | null
    consultantNotes?: NullableStringFieldUpdateOperationsInput | string | null
    sessionRating?: NullableIntFieldUpdateOperationsInput | number | null
    technicalIssuesReported?: BoolFieldUpdateOperationsInput | boolean
    makeupSessionFor?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoParticipantUpsertWithWhereUniqueWithoutVideoSessionInput = {
    where: VideoParticipantWhereUniqueInput
    update: XOR<VideoParticipantUpdateWithoutVideoSessionInput, VideoParticipantUncheckedUpdateWithoutVideoSessionInput>
    create: XOR<VideoParticipantCreateWithoutVideoSessionInput, VideoParticipantUncheckedCreateWithoutVideoSessionInput>
  }

  export type VideoParticipantUpdateWithWhereUniqueWithoutVideoSessionInput = {
    where: VideoParticipantWhereUniqueInput
    data: XOR<VideoParticipantUpdateWithoutVideoSessionInput, VideoParticipantUncheckedUpdateWithoutVideoSessionInput>
  }

  export type VideoParticipantUpdateManyWithWhereWithoutVideoSessionInput = {
    where: VideoParticipantScalarWhereInput
    data: XOR<VideoParticipantUpdateManyMutationInput, VideoParticipantUncheckedUpdateManyWithoutVideoSessionInput>
  }

  export type VideoParticipantScalarWhereInput = {
    AND?: VideoParticipantScalarWhereInput | VideoParticipantScalarWhereInput[]
    OR?: VideoParticipantScalarWhereInput[]
    NOT?: VideoParticipantScalarWhereInput | VideoParticipantScalarWhereInput[]
    id?: StringFilter<"VideoParticipant"> | string
    videoSessionId?: StringFilter<"VideoParticipant"> | string
    userId?: StringFilter<"VideoParticipant"> | string
    userType?: EnumUserTypeFilter<"VideoParticipant"> | $Enums.UserType
    joinTime?: DateTimeFilter<"VideoParticipant"> | Date | string
    leaveTime?: DateTimeNullableFilter<"VideoParticipant"> | Date | string | null
    totalDurationSeconds?: IntNullableFilter<"VideoParticipant"> | number | null
    audioQualityAvg?: FloatNullableFilter<"VideoParticipant"> | number | null
    videoQualityAvg?: FloatNullableFilter<"VideoParticipant"> | number | null
    screenShareDurationSeconds?: IntFilter<"VideoParticipant"> | number
    chatMessagesCount?: IntFilter<"VideoParticipant"> | number
    connectionInterruptions?: IntFilter<"VideoParticipant"> | number
    createdAt?: DateTimeFilter<"VideoParticipant"> | Date | string
  }

  export type VideoSessionCreateWithoutVideoParticipantsInput = {
    id?: string
    roomId: string
    recordingEnabled?: boolean
    recordingUrl?: string | null
    recordingDurationSeconds?: number | null
    videoQuality?: string
    connectionQualityAvg?: number | null
    bandwidthUsageMb?: number | null
    technicalIssues?: NullableJsonNullValueInput | InputJsonValue
    sessionMetadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    consultationSession: ConsultationSessionCreateNestedOneWithoutVideoSessionInput
  }

  export type VideoSessionUncheckedCreateWithoutVideoParticipantsInput = {
    id?: string
    consultationSessionId: string
    roomId: string
    recordingEnabled?: boolean
    recordingUrl?: string | null
    recordingDurationSeconds?: number | null
    videoQuality?: string
    connectionQualityAvg?: number | null
    bandwidthUsageMb?: number | null
    technicalIssues?: NullableJsonNullValueInput | InputJsonValue
    sessionMetadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type VideoSessionCreateOrConnectWithoutVideoParticipantsInput = {
    where: VideoSessionWhereUniqueInput
    create: XOR<VideoSessionCreateWithoutVideoParticipantsInput, VideoSessionUncheckedCreateWithoutVideoParticipantsInput>
  }

  export type VideoSessionUpsertWithoutVideoParticipantsInput = {
    update: XOR<VideoSessionUpdateWithoutVideoParticipantsInput, VideoSessionUncheckedUpdateWithoutVideoParticipantsInput>
    create: XOR<VideoSessionCreateWithoutVideoParticipantsInput, VideoSessionUncheckedCreateWithoutVideoParticipantsInput>
    where?: VideoSessionWhereInput
  }

  export type VideoSessionUpdateToOneWithWhereWithoutVideoParticipantsInput = {
    where?: VideoSessionWhereInput
    data: XOR<VideoSessionUpdateWithoutVideoParticipantsInput, VideoSessionUncheckedUpdateWithoutVideoParticipantsInput>
  }

  export type VideoSessionUpdateWithoutVideoParticipantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    recordingEnabled?: BoolFieldUpdateOperationsInput | boolean
    recordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    recordingDurationSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    videoQuality?: StringFieldUpdateOperationsInput | string
    connectionQualityAvg?: NullableFloatFieldUpdateOperationsInput | number | null
    bandwidthUsageMb?: NullableFloatFieldUpdateOperationsInput | number | null
    technicalIssues?: NullableJsonNullValueInput | InputJsonValue
    sessionMetadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    consultationSession?: ConsultationSessionUpdateOneRequiredWithoutVideoSessionNestedInput
  }

  export type VideoSessionUncheckedUpdateWithoutVideoParticipantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    consultationSessionId?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    recordingEnabled?: BoolFieldUpdateOperationsInput | boolean
    recordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    recordingDurationSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    videoQuality?: StringFieldUpdateOperationsInput | string
    connectionQualityAvg?: NullableFloatFieldUpdateOperationsInput | number | null
    bandwidthUsageMb?: NullableFloatFieldUpdateOperationsInput | number | null
    technicalIssues?: NullableJsonNullValueInput | InputJsonValue
    sessionMetadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConsultantCreateWithoutConsultantAvailabilityInput = {
    id?: string
    bio?: string | null
    specialties?: ConsultantCreatespecialtiesInput | string[]
    hourlyRate?: number
    isActive?: boolean
    timezone?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutConsultantInput
    consultationSessions?: ConsultationSessionCreateNestedManyWithoutConsultantInput
    consultantPayments?: ConsultantPaymentCreateNestedManyWithoutConsultantInput
  }

  export type ConsultantUncheckedCreateWithoutConsultantAvailabilityInput = {
    id?: string
    userId: string
    bio?: string | null
    specialties?: ConsultantCreatespecialtiesInput | string[]
    hourlyRate?: number
    isActive?: boolean
    timezone?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    consultationSessions?: ConsultationSessionUncheckedCreateNestedManyWithoutConsultantInput
    consultantPayments?: ConsultantPaymentUncheckedCreateNestedManyWithoutConsultantInput
  }

  export type ConsultantCreateOrConnectWithoutConsultantAvailabilityInput = {
    where: ConsultantWhereUniqueInput
    create: XOR<ConsultantCreateWithoutConsultantAvailabilityInput, ConsultantUncheckedCreateWithoutConsultantAvailabilityInput>
  }

  export type ConsultantUpsertWithoutConsultantAvailabilityInput = {
    update: XOR<ConsultantUpdateWithoutConsultantAvailabilityInput, ConsultantUncheckedUpdateWithoutConsultantAvailabilityInput>
    create: XOR<ConsultantCreateWithoutConsultantAvailabilityInput, ConsultantUncheckedCreateWithoutConsultantAvailabilityInput>
    where?: ConsultantWhereInput
  }

  export type ConsultantUpdateToOneWithWhereWithoutConsultantAvailabilityInput = {
    where?: ConsultantWhereInput
    data: XOR<ConsultantUpdateWithoutConsultantAvailabilityInput, ConsultantUncheckedUpdateWithoutConsultantAvailabilityInput>
  }

  export type ConsultantUpdateWithoutConsultantAvailabilityInput = {
    id?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    specialties?: ConsultantUpdatespecialtiesInput | string[]
    hourlyRate?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    timezone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutConsultantNestedInput
    consultationSessions?: ConsultationSessionUpdateManyWithoutConsultantNestedInput
    consultantPayments?: ConsultantPaymentUpdateManyWithoutConsultantNestedInput
  }

  export type ConsultantUncheckedUpdateWithoutConsultantAvailabilityInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    specialties?: ConsultantUpdatespecialtiesInput | string[]
    hourlyRate?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    timezone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    consultationSessions?: ConsultationSessionUncheckedUpdateManyWithoutConsultantNestedInput
    consultantPayments?: ConsultantPaymentUncheckedUpdateManyWithoutConsultantNestedInput
  }

  export type StudentCreateWithoutStudentDocumentsInput = {
    id?: string
    kajabiUserId?: string | null
    courseCompletionDate: Date | string
    totalVerifiedHours?: number
    totalVideoHours?: number
    certificationStatus?: $Enums.StudentStatus
    preferredSessionLength?: number
    consultationPreferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutStudentInput
    consultationSessions?: ConsultationSessionCreateNestedManyWithoutStudentInput
    sessionHistory?: SessionHistoryCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutStudentDocumentsInput = {
    id?: string
    userId: string
    kajabiUserId?: string | null
    courseCompletionDate: Date | string
    totalVerifiedHours?: number
    totalVideoHours?: number
    certificationStatus?: $Enums.StudentStatus
    preferredSessionLength?: number
    consultationPreferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    consultationSessions?: ConsultationSessionUncheckedCreateNestedManyWithoutStudentInput
    sessionHistory?: SessionHistoryUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutStudentDocumentsInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutStudentDocumentsInput, StudentUncheckedCreateWithoutStudentDocumentsInput>
  }

  export type StudentUpsertWithoutStudentDocumentsInput = {
    update: XOR<StudentUpdateWithoutStudentDocumentsInput, StudentUncheckedUpdateWithoutStudentDocumentsInput>
    create: XOR<StudentCreateWithoutStudentDocumentsInput, StudentUncheckedCreateWithoutStudentDocumentsInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutStudentDocumentsInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutStudentDocumentsInput, StudentUncheckedUpdateWithoutStudentDocumentsInput>
  }

  export type StudentUpdateWithoutStudentDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    kajabiUserId?: NullableStringFieldUpdateOperationsInput | string | null
    courseCompletionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalVerifiedHours?: FloatFieldUpdateOperationsInput | number
    totalVideoHours?: FloatFieldUpdateOperationsInput | number
    certificationStatus?: EnumStudentStatusFieldUpdateOperationsInput | $Enums.StudentStatus
    preferredSessionLength?: IntFieldUpdateOperationsInput | number
    consultationPreferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStudentNestedInput
    consultationSessions?: ConsultationSessionUpdateManyWithoutStudentNestedInput
    sessionHistory?: SessionHistoryUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutStudentDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    kajabiUserId?: NullableStringFieldUpdateOperationsInput | string | null
    courseCompletionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalVerifiedHours?: FloatFieldUpdateOperationsInput | number
    totalVideoHours?: FloatFieldUpdateOperationsInput | number
    certificationStatus?: EnumStudentStatusFieldUpdateOperationsInput | $Enums.StudentStatus
    preferredSessionLength?: IntFieldUpdateOperationsInput | number
    consultationPreferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    consultationSessions?: ConsultationSessionUncheckedUpdateManyWithoutStudentNestedInput
    sessionHistory?: SessionHistoryUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type StudentCreateWithoutSessionHistoryInput = {
    id?: string
    kajabiUserId?: string | null
    courseCompletionDate: Date | string
    totalVerifiedHours?: number
    totalVideoHours?: number
    certificationStatus?: $Enums.StudentStatus
    preferredSessionLength?: number
    consultationPreferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutStudentInput
    consultationSessions?: ConsultationSessionCreateNestedManyWithoutStudentInput
    studentDocuments?: StudentDocumentCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutSessionHistoryInput = {
    id?: string
    userId: string
    kajabiUserId?: string | null
    courseCompletionDate: Date | string
    totalVerifiedHours?: number
    totalVideoHours?: number
    certificationStatus?: $Enums.StudentStatus
    preferredSessionLength?: number
    consultationPreferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    consultationSessions?: ConsultationSessionUncheckedCreateNestedManyWithoutStudentInput
    studentDocuments?: StudentDocumentUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutSessionHistoryInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutSessionHistoryInput, StudentUncheckedCreateWithoutSessionHistoryInput>
  }

  export type StudentUpsertWithoutSessionHistoryInput = {
    update: XOR<StudentUpdateWithoutSessionHistoryInput, StudentUncheckedUpdateWithoutSessionHistoryInput>
    create: XOR<StudentCreateWithoutSessionHistoryInput, StudentUncheckedCreateWithoutSessionHistoryInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutSessionHistoryInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutSessionHistoryInput, StudentUncheckedUpdateWithoutSessionHistoryInput>
  }

  export type StudentUpdateWithoutSessionHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    kajabiUserId?: NullableStringFieldUpdateOperationsInput | string | null
    courseCompletionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalVerifiedHours?: FloatFieldUpdateOperationsInput | number
    totalVideoHours?: FloatFieldUpdateOperationsInput | number
    certificationStatus?: EnumStudentStatusFieldUpdateOperationsInput | $Enums.StudentStatus
    preferredSessionLength?: IntFieldUpdateOperationsInput | number
    consultationPreferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStudentNestedInput
    consultationSessions?: ConsultationSessionUpdateManyWithoutStudentNestedInput
    studentDocuments?: StudentDocumentUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutSessionHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    kajabiUserId?: NullableStringFieldUpdateOperationsInput | string | null
    courseCompletionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalVerifiedHours?: FloatFieldUpdateOperationsInput | number
    totalVideoHours?: FloatFieldUpdateOperationsInput | number
    certificationStatus?: EnumStudentStatusFieldUpdateOperationsInput | $Enums.StudentStatus
    preferredSessionLength?: IntFieldUpdateOperationsInput | number
    consultationPreferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    consultationSessions?: ConsultationSessionUncheckedUpdateManyWithoutStudentNestedInput
    studentDocuments?: StudentDocumentUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type ConsultantCreateWithoutConsultantPaymentsInput = {
    id?: string
    bio?: string | null
    specialties?: ConsultantCreatespecialtiesInput | string[]
    hourlyRate?: number
    isActive?: boolean
    timezone?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutConsultantInput
    consultationSessions?: ConsultationSessionCreateNestedManyWithoutConsultantInput
    consultantAvailability?: ConsultantAvailabilityCreateNestedManyWithoutConsultantInput
  }

  export type ConsultantUncheckedCreateWithoutConsultantPaymentsInput = {
    id?: string
    userId: string
    bio?: string | null
    specialties?: ConsultantCreatespecialtiesInput | string[]
    hourlyRate?: number
    isActive?: boolean
    timezone?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    consultationSessions?: ConsultationSessionUncheckedCreateNestedManyWithoutConsultantInput
    consultantAvailability?: ConsultantAvailabilityUncheckedCreateNestedManyWithoutConsultantInput
  }

  export type ConsultantCreateOrConnectWithoutConsultantPaymentsInput = {
    where: ConsultantWhereUniqueInput
    create: XOR<ConsultantCreateWithoutConsultantPaymentsInput, ConsultantUncheckedCreateWithoutConsultantPaymentsInput>
  }

  export type ConsultantUpsertWithoutConsultantPaymentsInput = {
    update: XOR<ConsultantUpdateWithoutConsultantPaymentsInput, ConsultantUncheckedUpdateWithoutConsultantPaymentsInput>
    create: XOR<ConsultantCreateWithoutConsultantPaymentsInput, ConsultantUncheckedCreateWithoutConsultantPaymentsInput>
    where?: ConsultantWhereInput
  }

  export type ConsultantUpdateToOneWithWhereWithoutConsultantPaymentsInput = {
    where?: ConsultantWhereInput
    data: XOR<ConsultantUpdateWithoutConsultantPaymentsInput, ConsultantUncheckedUpdateWithoutConsultantPaymentsInput>
  }

  export type ConsultantUpdateWithoutConsultantPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    specialties?: ConsultantUpdatespecialtiesInput | string[]
    hourlyRate?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    timezone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutConsultantNestedInput
    consultationSessions?: ConsultationSessionUpdateManyWithoutConsultantNestedInput
    consultantAvailability?: ConsultantAvailabilityUpdateManyWithoutConsultantNestedInput
  }

  export type ConsultantUncheckedUpdateWithoutConsultantPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    specialties?: ConsultantUpdatespecialtiesInput | string[]
    hourlyRate?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    timezone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    consultationSessions?: ConsultationSessionUncheckedUpdateManyWithoutConsultantNestedInput
    consultantAvailability?: ConsultantAvailabilityUncheckedUpdateManyWithoutConsultantNestedInput
  }

  export type ConsultationSessionCreateManyStudentInput = {
    id?: string
    consultantId: string
    scheduledStart: Date | string
    scheduledEnd: Date | string
    actualStart?: Date | string | null
    actualEnd?: Date | string | null
    status?: $Enums.SessionStatus
    sessionType?: string
    studentVerifiedAt?: Date | string | null
    consultantVerifiedAt?: Date | string | null
    studentNotes?: string | null
    consultantNotes?: string | null
    sessionRating?: number | null
    technicalIssuesReported?: boolean
    makeupSessionFor?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentDocumentCreateManyStudentInput = {
    id?: string
    documentType: $Enums.DocumentType
    fileName: string
    fileSizeBytes: number
    filePath: string
    mimeType: string
    extractedText?: string | null
    uploadTimestamp?: Date | string
    reviewStatus?: $Enums.ReviewStatus
    reviewedBy?: string | null
    reviewedAt?: Date | string | null
    reviewNotes?: string | null
    versionNumber?: number
    replacesDocumentId?: string | null
    autoValidationScore?: number | null
    requiresManualReview?: boolean
    createdAt?: Date | string
  }

  export type SessionHistoryCreateManyStudentInput = {
    id?: string
    sessionDate: Date | string
    sessionDuration: number
    consultantId: string
    sessionType: string
    status: string
    rating?: number | null
    createdAt?: Date | string
  }

  export type ConsultationSessionUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduledStart?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    actualStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    sessionType?: StringFieldUpdateOperationsInput | string
    studentVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    consultantVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    studentNotes?: NullableStringFieldUpdateOperationsInput | string | null
    consultantNotes?: NullableStringFieldUpdateOperationsInput | string | null
    sessionRating?: NullableIntFieldUpdateOperationsInput | number | null
    technicalIssuesReported?: BoolFieldUpdateOperationsInput | boolean
    makeupSessionFor?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    consultant?: ConsultantUpdateOneRequiredWithoutConsultationSessionsNestedInput
    videoSession?: VideoSessionUpdateOneWithoutConsultationSessionNestedInput
  }

  export type ConsultationSessionUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    consultantId?: StringFieldUpdateOperationsInput | string
    scheduledStart?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    actualStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    sessionType?: StringFieldUpdateOperationsInput | string
    studentVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    consultantVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    studentNotes?: NullableStringFieldUpdateOperationsInput | string | null
    consultantNotes?: NullableStringFieldUpdateOperationsInput | string | null
    sessionRating?: NullableIntFieldUpdateOperationsInput | number | null
    technicalIssuesReported?: BoolFieldUpdateOperationsInput | boolean
    makeupSessionFor?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    videoSession?: VideoSessionUncheckedUpdateOneWithoutConsultationSessionNestedInput
  }

  export type ConsultationSessionUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    consultantId?: StringFieldUpdateOperationsInput | string
    scheduledStart?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    actualStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    sessionType?: StringFieldUpdateOperationsInput | string
    studentVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    consultantVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    studentNotes?: NullableStringFieldUpdateOperationsInput | string | null
    consultantNotes?: NullableStringFieldUpdateOperationsInput | string | null
    sessionRating?: NullableIntFieldUpdateOperationsInput | number | null
    technicalIssuesReported?: BoolFieldUpdateOperationsInput | boolean
    makeupSessionFor?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentDocumentUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    fileName?: StringFieldUpdateOperationsInput | string
    fileSizeBytes?: IntFieldUpdateOperationsInput | number
    filePath?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    extractedText?: NullableStringFieldUpdateOperationsInput | string | null
    uploadTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewStatus?: EnumReviewStatusFieldUpdateOperationsInput | $Enums.ReviewStatus
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null
    versionNumber?: IntFieldUpdateOperationsInput | number
    replacesDocumentId?: NullableStringFieldUpdateOperationsInput | string | null
    autoValidationScore?: NullableFloatFieldUpdateOperationsInput | number | null
    requiresManualReview?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentDocumentUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    fileName?: StringFieldUpdateOperationsInput | string
    fileSizeBytes?: IntFieldUpdateOperationsInput | number
    filePath?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    extractedText?: NullableStringFieldUpdateOperationsInput | string | null
    uploadTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewStatus?: EnumReviewStatusFieldUpdateOperationsInput | $Enums.ReviewStatus
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null
    versionNumber?: IntFieldUpdateOperationsInput | number
    replacesDocumentId?: NullableStringFieldUpdateOperationsInput | string | null
    autoValidationScore?: NullableFloatFieldUpdateOperationsInput | number | null
    requiresManualReview?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentDocumentUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentType?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    fileName?: StringFieldUpdateOperationsInput | string
    fileSizeBytes?: IntFieldUpdateOperationsInput | number
    filePath?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    extractedText?: NullableStringFieldUpdateOperationsInput | string | null
    uploadTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewStatus?: EnumReviewStatusFieldUpdateOperationsInput | $Enums.ReviewStatus
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewNotes?: NullableStringFieldUpdateOperationsInput | string | null
    versionNumber?: IntFieldUpdateOperationsInput | number
    replacesDocumentId?: NullableStringFieldUpdateOperationsInput | string | null
    autoValidationScore?: NullableFloatFieldUpdateOperationsInput | number | null
    requiresManualReview?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionHistoryUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionDuration?: IntFieldUpdateOperationsInput | number
    consultantId?: StringFieldUpdateOperationsInput | string
    sessionType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionHistoryUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionDuration?: IntFieldUpdateOperationsInput | number
    consultantId?: StringFieldUpdateOperationsInput | string
    sessionType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionHistoryUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionDuration?: IntFieldUpdateOperationsInput | number
    consultantId?: StringFieldUpdateOperationsInput | string
    sessionType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConsultationSessionCreateManyConsultantInput = {
    id?: string
    studentId: string
    scheduledStart: Date | string
    scheduledEnd: Date | string
    actualStart?: Date | string | null
    actualEnd?: Date | string | null
    status?: $Enums.SessionStatus
    sessionType?: string
    studentVerifiedAt?: Date | string | null
    consultantVerifiedAt?: Date | string | null
    studentNotes?: string | null
    consultantNotes?: string | null
    sessionRating?: number | null
    technicalIssuesReported?: boolean
    makeupSessionFor?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConsultantAvailabilityCreateManyConsultantInput = {
    id?: string
    availabilityType: $Enums.AvailabilityType
    dayOfWeek?: number | null
    specificDate?: Date | string | null
    startTime: string
    endTime: string
    maxSessions?: number
    bufferMinutes?: number
    isAvailable?: boolean
    bookingWindowDays?: number
    minimumNoticeHours?: number
    autoApprove?: boolean
    timezone: string
    recurringPattern?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConsultantPaymentCreateManyConsultantInput = {
    id?: string
    paymentPeriod: string
    totalHours: number
    hourlyRate: number
    totalAmount: number
    paymentStatus?: $Enums.PaymentStatus
    paymentDate?: Date | string | null
    sessionBreakdown?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ConsultationSessionUpdateWithoutConsultantInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduledStart?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    actualStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    sessionType?: StringFieldUpdateOperationsInput | string
    studentVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    consultantVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    studentNotes?: NullableStringFieldUpdateOperationsInput | string | null
    consultantNotes?: NullableStringFieldUpdateOperationsInput | string | null
    sessionRating?: NullableIntFieldUpdateOperationsInput | number | null
    technicalIssuesReported?: BoolFieldUpdateOperationsInput | boolean
    makeupSessionFor?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutConsultationSessionsNestedInput
    videoSession?: VideoSessionUpdateOneWithoutConsultationSessionNestedInput
  }

  export type ConsultationSessionUncheckedUpdateWithoutConsultantInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    scheduledStart?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    actualStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    sessionType?: StringFieldUpdateOperationsInput | string
    studentVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    consultantVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    studentNotes?: NullableStringFieldUpdateOperationsInput | string | null
    consultantNotes?: NullableStringFieldUpdateOperationsInput | string | null
    sessionRating?: NullableIntFieldUpdateOperationsInput | number | null
    technicalIssuesReported?: BoolFieldUpdateOperationsInput | boolean
    makeupSessionFor?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    videoSession?: VideoSessionUncheckedUpdateOneWithoutConsultationSessionNestedInput
  }

  export type ConsultationSessionUncheckedUpdateManyWithoutConsultantInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    scheduledStart?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    actualStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    sessionType?: StringFieldUpdateOperationsInput | string
    studentVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    consultantVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    studentNotes?: NullableStringFieldUpdateOperationsInput | string | null
    consultantNotes?: NullableStringFieldUpdateOperationsInput | string | null
    sessionRating?: NullableIntFieldUpdateOperationsInput | number | null
    technicalIssuesReported?: BoolFieldUpdateOperationsInput | boolean
    makeupSessionFor?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConsultantAvailabilityUpdateWithoutConsultantInput = {
    id?: StringFieldUpdateOperationsInput | string
    availabilityType?: EnumAvailabilityTypeFieldUpdateOperationsInput | $Enums.AvailabilityType
    dayOfWeek?: NullableIntFieldUpdateOperationsInput | number | null
    specificDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    maxSessions?: IntFieldUpdateOperationsInput | number
    bufferMinutes?: IntFieldUpdateOperationsInput | number
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    bookingWindowDays?: IntFieldUpdateOperationsInput | number
    minimumNoticeHours?: IntFieldUpdateOperationsInput | number
    autoApprove?: BoolFieldUpdateOperationsInput | boolean
    timezone?: StringFieldUpdateOperationsInput | string
    recurringPattern?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConsultantAvailabilityUncheckedUpdateWithoutConsultantInput = {
    id?: StringFieldUpdateOperationsInput | string
    availabilityType?: EnumAvailabilityTypeFieldUpdateOperationsInput | $Enums.AvailabilityType
    dayOfWeek?: NullableIntFieldUpdateOperationsInput | number | null
    specificDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    maxSessions?: IntFieldUpdateOperationsInput | number
    bufferMinutes?: IntFieldUpdateOperationsInput | number
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    bookingWindowDays?: IntFieldUpdateOperationsInput | number
    minimumNoticeHours?: IntFieldUpdateOperationsInput | number
    autoApprove?: BoolFieldUpdateOperationsInput | boolean
    timezone?: StringFieldUpdateOperationsInput | string
    recurringPattern?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConsultantAvailabilityUncheckedUpdateManyWithoutConsultantInput = {
    id?: StringFieldUpdateOperationsInput | string
    availabilityType?: EnumAvailabilityTypeFieldUpdateOperationsInput | $Enums.AvailabilityType
    dayOfWeek?: NullableIntFieldUpdateOperationsInput | number | null
    specificDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    maxSessions?: IntFieldUpdateOperationsInput | number
    bufferMinutes?: IntFieldUpdateOperationsInput | number
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    bookingWindowDays?: IntFieldUpdateOperationsInput | number
    minimumNoticeHours?: IntFieldUpdateOperationsInput | number
    autoApprove?: BoolFieldUpdateOperationsInput | boolean
    timezone?: StringFieldUpdateOperationsInput | string
    recurringPattern?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConsultantPaymentUpdateWithoutConsultantInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentPeriod?: StringFieldUpdateOperationsInput | string
    totalHours?: FloatFieldUpdateOperationsInput | number
    hourlyRate?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessionBreakdown?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConsultantPaymentUncheckedUpdateWithoutConsultantInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentPeriod?: StringFieldUpdateOperationsInput | string
    totalHours?: FloatFieldUpdateOperationsInput | number
    hourlyRate?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessionBreakdown?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConsultantPaymentUncheckedUpdateManyWithoutConsultantInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentPeriod?: StringFieldUpdateOperationsInput | string
    totalHours?: FloatFieldUpdateOperationsInput | number
    hourlyRate?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessionBreakdown?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoParticipantCreateManyVideoSessionInput = {
    id?: string
    userId: string
    userType: $Enums.UserType
    joinTime: Date | string
    leaveTime?: Date | string | null
    totalDurationSeconds?: number | null
    audioQualityAvg?: number | null
    videoQualityAvg?: number | null
    screenShareDurationSeconds?: number
    chatMessagesCount?: number
    connectionInterruptions?: number
    createdAt?: Date | string
  }

  export type VideoParticipantUpdateWithoutVideoSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    joinTime?: DateTimeFieldUpdateOperationsInput | Date | string
    leaveTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalDurationSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    audioQualityAvg?: NullableFloatFieldUpdateOperationsInput | number | null
    videoQualityAvg?: NullableFloatFieldUpdateOperationsInput | number | null
    screenShareDurationSeconds?: IntFieldUpdateOperationsInput | number
    chatMessagesCount?: IntFieldUpdateOperationsInput | number
    connectionInterruptions?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoParticipantUncheckedUpdateWithoutVideoSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    joinTime?: DateTimeFieldUpdateOperationsInput | Date | string
    leaveTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalDurationSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    audioQualityAvg?: NullableFloatFieldUpdateOperationsInput | number | null
    videoQualityAvg?: NullableFloatFieldUpdateOperationsInput | number | null
    screenShareDurationSeconds?: IntFieldUpdateOperationsInput | number
    chatMessagesCount?: IntFieldUpdateOperationsInput | number
    connectionInterruptions?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoParticipantUncheckedUpdateManyWithoutVideoSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    joinTime?: DateTimeFieldUpdateOperationsInput | Date | string
    leaveTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalDurationSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    audioQualityAvg?: NullableFloatFieldUpdateOperationsInput | number | null
    videoQualityAvg?: NullableFloatFieldUpdateOperationsInput | number | null
    screenShareDurationSeconds?: IntFieldUpdateOperationsInput | number
    chatMessagesCount?: IntFieldUpdateOperationsInput | number
    connectionInterruptions?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use StudentCountOutputTypeDefaultArgs instead
     */
    export type StudentCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StudentCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ConsultantCountOutputTypeDefaultArgs instead
     */
    export type ConsultantCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ConsultantCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VideoSessionCountOutputTypeDefaultArgs instead
     */
    export type VideoSessionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VideoSessionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StudentDefaultArgs instead
     */
    export type StudentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StudentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ConsultantDefaultArgs instead
     */
    export type ConsultantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ConsultantDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AdminDefaultArgs instead
     */
    export type AdminArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AdminDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ConsultationSessionDefaultArgs instead
     */
    export type ConsultationSessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ConsultationSessionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VideoSessionDefaultArgs instead
     */
    export type VideoSessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VideoSessionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VideoParticipantDefaultArgs instead
     */
    export type VideoParticipantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VideoParticipantDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ConsultantAvailabilityDefaultArgs instead
     */
    export type ConsultantAvailabilityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ConsultantAvailabilityDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StudentDocumentDefaultArgs instead
     */
    export type StudentDocumentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StudentDocumentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SessionHistoryDefaultArgs instead
     */
    export type SessionHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SessionHistoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ConsultantPaymentDefaultArgs instead
     */
    export type ConsultantPaymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ConsultantPaymentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SystemHealthMetricDefaultArgs instead
     */
    export type SystemHealthMetricArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SystemHealthMetricDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InAppNotificationDefaultArgs instead
     */
    export type InAppNotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InAppNotificationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ScheduledNotificationDefaultArgs instead
     */
    export type ScheduledNotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ScheduledNotificationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NotificationLogDefaultArgs instead
     */
    export type NotificationLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NotificationLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserNotificationPreferencesDefaultArgs instead
     */
    export type UserNotificationPreferencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserNotificationPreferencesDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}